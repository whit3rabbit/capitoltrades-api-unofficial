---
phase: 02-trade-extraction
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - capitoltraders_lib/src/db.rs
autonomous: true

must_haves:
  truths:
    - "update_trade_detail persists all extracted fields to the trades table"
    - "update_trade_detail updates asset_type on the assets table (using tx_id as asset_id)"
    - "update_trade_detail inserts committees into trade_committees join table"
    - "update_trade_detail inserts labels into trade_labels join table"
    - "update_trade_detail sets enriched_at timestamp"
    - "update_trade_detail does not overwrite existing non-NULL values with NULL (COALESCE pattern)"
    - "update_trade_detail does not overwrite real asset_type with 'unknown'"
  artifacts:
    - path: "capitoltraders_lib/src/db.rs"
      provides: "Db::update_trade_detail method and tests"
      contains: "fn update_trade_detail"
  key_links:
    - from: "capitoltraders_lib/src/db.rs (update_trade_detail)"
      to: "capitoltraders_lib/src/scrape.rs (ScrapedTradeDetail)"
      via: "accepts ScrapedTradeDetail reference"
      pattern: "ScrapedTradeDetail"
    - from: "capitoltraders_lib/src/db.rs (update_trade_detail)"
      to: "schema/sqlite.sql (trades, assets, trade_committees, trade_labels)"
      via: "UPDATE and INSERT statements"
      pattern: "UPDATE trades SET"
---

<objective>
Add a Db::update_trade_detail() method that persists all extracted trade detail fields to the database with sentinel protection, plus comprehensive tests.

Purpose: Plan 02-01 extracts fields from the RSC payload into ScrapedTradeDetail. This plan persists those fields to the SQLite database following Phase 1's established sentinel/COALESCE patterns, ensuring enriched values are never overwritten by NULLs or defaults.

Output: Db::update_trade_detail() method that updates the trades table, assets table (asset_type), trade_committees join table, and trade_labels join table. Unit tests covering all update paths, sentinel protection, and edge cases.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-trade-extraction/02-RESEARCH.md
@.planning/phases/02-trade-extraction/02-01-SUMMARY.md
@capitoltraders_lib/src/db.rs
@capitoltraders_lib/src/scrape.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Db::update_trade_detail() method</name>
  <files>capitoltraders_lib/src/db.rs</files>
  <action>
Add a `use crate::scrape::ScrapedTradeDetail;` import at the top of db.rs (if not already present).

Add a public method `update_trade_detail` to the `impl Db` block. This method takes a tx_id (i64) and a reference to ScrapedTradeDetail, and updates 4 tables in a single transaction:

```rust
pub fn update_trade_detail(
    &self,
    tx_id: i64,
    detail: &ScrapedTradeDetail,
) -> Result<(), DbError> {
```

The method should:

1. **Update trades table** -- Use COALESCE for nullable fields so that a NULL incoming value does not overwrite existing non-NULL data. Use CASE for sentinel-protected fields (filing_id != 0, filing_url != ''):

```sql
UPDATE trades SET
  price = COALESCE(?1, price),
  size = COALESCE(?2, size),
  size_range_high = COALESCE(?3, size_range_high),
  size_range_low = COALESCE(?4, size_range_low),
  filing_id = CASE WHEN ?5 > 0 THEN ?5 ELSE filing_id END,
  filing_url = CASE WHEN ?6 != '' THEN ?6 ELSE filing_url END,
  has_capital_gains = COALESCE(?7, has_capital_gains),
  enriched_at = ?8
WHERE tx_id = ?9
```

For parameter binding:
- price: `detail.price` (Option<f64>, COALESCE handles None)
- size: `detail.size` (Option<i64>)
- size_range_high: `detail.size_range_high` (Option<i64>)
- size_range_low: `detail.size_range_low` (Option<i64>)
- filing_id: `detail.filing_id.unwrap_or(0)` (sentinel is 0)
- filing_url: `detail.filing_url.as_deref().unwrap_or("")` (sentinel is empty string)
- has_capital_gains: `detail.has_capital_gains.map(|b| if b { 1 } else { 0 })` (Option<i32>)
- enriched_at: `chrono::Utc::now().to_rfc3339()` (always set by this method)
- tx_id: the parameter

2. **Update assets table** -- Only update asset_type if the incoming value is not "unknown" and the existing value IS "unknown". This prevents overwriting a previously enriched asset_type:

```sql
UPDATE assets SET asset_type = ?1
WHERE asset_id = ?2 AND asset_type = 'unknown'
```

Use `asset_id = tx_id` because that is how `upsert_scraped_trades` sets asset_id (db.rs line 449). Only execute this if `detail.asset_type` is Some and not "unknown".

3. **Update trade_committees** -- Delete existing rows for this tx_id, then insert new ones. Only if `detail.committees` is non-empty:

```sql
DELETE FROM trade_committees WHERE tx_id = ?1
INSERT INTO trade_committees (tx_id, committee) VALUES (?1, ?2)
```

Use a prepared statement in a loop for the inserts.

4. **Update trade_labels** -- Same delete+insert pattern as committees. Only if `detail.labels` is non-empty:

```sql
DELETE FROM trade_labels WHERE tx_id = ?1
INSERT INTO trade_labels (tx_id, label) VALUES (?1, ?2)
```

Wrap the entire operation in a transaction (`self.conn.execute_batch("BEGIN")` ... `COMMIT` or use rusqlite's transaction support if available). If any step fails, the transaction should roll back.

Return `Ok(())` on success. Map rusqlite errors through the existing `DbError` type.
  </action>
  <verify>
`cargo check -p capitoltraders_lib` compiles without errors. `cargo clippy -p capitoltraders_lib` has no new warnings.
  </verify>
  <done>
Db::update_trade_detail() method exists, compiles, and updates all 4 tables (trades, assets, trade_committees, trade_labels) with sentinel protection and COALESCE patterns matching Phase 1 conventions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for update_trade_detail</name>
  <files>capitoltraders_lib/src/db.rs</files>
  <action>
Add tests to the existing `#[cfg(test)] mod tests` block in db.rs. Use the existing `Db::open_in_memory()` test constructor and the `make_test_scraped_trade` helper established in Phase 1.

Write these tests:

1. `test_update_trade_detail_basic` -- Insert a trade via `upsert_scraped_trades`, then call `update_trade_detail` with a ScrapedTradeDetail containing all fields populated. Query the trades table directly and verify all fields were updated. Verify enriched_at is not NULL.

2. `test_update_trade_detail_coalesce_preserves_existing` -- Insert a trade, call update_trade_detail with price=Some(50.0) and size=Some(100). Then call update_trade_detail again with price=None and size=None. Query and verify price is still 50.0 and size is still 100 (COALESCE prevented NULL from overwriting).

3. `test_update_trade_detail_asset_type_update` -- Insert a trade (which creates an asset with type "unknown"). Call update_trade_detail with asset_type=Some("stock"). Query assets table and verify asset_type is now "stock".

4. `test_update_trade_detail_asset_type_no_overwrite` -- Insert a trade, call update_trade_detail with asset_type=Some("stock"). Then call update_trade_detail again with asset_type=Some("etf"). Query assets table and verify asset_type is still "stock" (the WHERE clause prevents overwriting non-"unknown" values).

5. `test_update_trade_detail_asset_type_unknown_ignored` -- Insert a trade, call update_trade_detail with asset_type=Some("unknown"). Query assets table and verify asset_type is still "unknown" (the method does not execute the update when incoming is "unknown").

6. `test_update_trade_detail_committees` -- Insert a trade, call update_trade_detail with committees=vec!["ssfi", "hsag"]. Query trade_committees and verify 2 rows exist with correct tx_id and committee values.

7. `test_update_trade_detail_committees_replace` -- Insert a trade, call update_trade_detail with committees=vec!["ssfi"]. Then call again with committees=vec!["hsag", "hsap"]. Query trade_committees and verify only 2 rows exist (the old one was deleted, the new ones inserted).

8. `test_update_trade_detail_labels` -- Insert a trade, call update_trade_detail with labels=vec!["faang", "crypto"]. Query trade_labels and verify 2 rows exist.

9. `test_update_trade_detail_filing_sentinel` -- Insert a trade, call update_trade_detail with filing_id=Some(12345) and filing_url=Some("https://example.com/12345"). Then call again with filing_id=None and filing_url=None. Query and verify filing_id is still 12345 and filing_url is still the URL (sentinel CASE prevented overwrite).

10. `test_update_trade_detail_enriched_at_set` -- Insert a trade, verify enriched_at is NULL. Call update_trade_detail. Verify enriched_at is now a non-empty string (RFC3339 timestamp).

For querying results in tests, use `self.conn.query_row("SELECT ... FROM trades WHERE tx_id = ?1", ...)` directly on the Db's connection. The test helper already provides access to the db instance.

For constructing ScrapedTradeDetail in tests, create a helper function:
```rust
fn make_test_trade_detail() -> ScrapedTradeDetail {
    ScrapedTradeDetail {
        filing_url: Some("https://efts.sec.gov/12345".to_string()),
        filing_id: Some(12345),
        asset_type: Some("stock".to_string()),
        size: Some(50000),
        size_range_high: Some(100000),
        size_range_low: Some(15001),
        price: Some(150.50),
        has_capital_gains: Some(false),
        committees: vec!["ssfi".to_string()],
        labels: vec!["faang".to_string()],
    }
}
```
  </action>
  <verify>
`cargo test -p capitoltraders_lib update_trade_detail` -- all 10 new tests pass. `cargo test --workspace` -- full suite passes. `cargo clippy --workspace` -- no warnings.
  </verify>
  <done>
10 tests cover: basic update, COALESCE preservation, asset_type update and protection, committees insert and replace, labels insert, filing sentinel protection, and enriched_at timestamping. All existing tests (209+) continue to pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with 0 failures
2. `cargo clippy --workspace` has no warnings
3. `cargo test -p capitoltraders_lib update_trade_detail` shows all 10 new tests passing
4. `Db::update_trade_detail` method exists and is public
5. The method updates trades, assets, trade_committees, and trade_labels tables
6. COALESCE/CASE patterns match Phase 1 sentinel protection conventions
</verification>

<success_criteria>
- Db::update_trade_detail() persists all ScrapedTradeDetail fields with sentinel protection
- asset_type updates on assets table only when current value is "unknown"
- Committees and labels use delete+insert pattern on join tables
- enriched_at is always set by the method
- 10 new tests pass covering all update paths and edge cases
- All existing tests (209+) continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-trade-extraction/02-02-SUMMARY.md`
</output>
