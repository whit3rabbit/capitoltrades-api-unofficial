---
phase: 01-schema-migration-data-model
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - capitoltraders_lib/src/db.rs
  - schema/sqlite.sql
  - capitoltraders_cli/src/output_tests.rs
autonomous: true

must_haves:
  truths:
    - "trades table has trade_date_price, current_price, price_enriched_at, estimated_shares, estimated_value columns after migration"
    - "positions table exists with politician_id, issuer_ticker, shares_held, cost_basis, realized_pnl, last_updated columns"
    - "Migration from v1 to v2 succeeds on existing DB without data loss"
    - "Re-running migration on already-migrated DB is safe (idempotent)"
    - "DbTradeRow struct includes new price fields as Option types"
    - "query_trades() SELECT returns new price columns correctly"
  artifacts:
    - path: "capitoltraders_lib/src/db.rs"
      provides: "migrate_v2() function, updated init(), updated DbTradeRow, updated query_trades()"
      contains: "fn migrate_v2"
    - path: "schema/sqlite.sql"
      provides: "positions table DDL with indexes"
      contains: "CREATE TABLE IF NOT EXISTS positions"
    - path: "capitoltraders_cli/src/output_tests.rs"
      provides: "Updated sample_db_trade_row() with new fields"
      contains: "trade_date_price"
  key_links:
    - from: "capitoltraders_lib/src/db.rs (init)"
      to: "capitoltraders_lib/src/db.rs (migrate_v2)"
      via: "version < 2 check calls migrate_v2()"
      pattern: "if version < 2.*migrate_v2"
    - from: "capitoltraders_lib/src/db.rs (query_trades SELECT)"
      to: "capitoltraders_lib/src/db.rs (DbTradeRow)"
      via: "row.get() column indices map to struct fields"
      pattern: "trade_date_price.*row\\.get"
    - from: "schema/sqlite.sql (positions table)"
      to: "capitoltraders_lib/src/db.rs (init)"
      via: "include_str! executes schema DDL including positions CREATE TABLE"
      pattern: "include_str.*sqlite\\.sql"
---

<objective>
Add price storage columns to the trades table via v2 migration and create the materialized positions table for portfolio tracking.

Purpose: Phase 1 foundation -- all downstream price enrichment, Yahoo Finance integration, and portfolio calculation depend on these schema changes existing. Without price columns, we cannot store trade-date or current prices. Without the positions table, we cannot materialize FIFO portfolio calculations (locked user decision: materialized positions table).

Output: Working v2 migration that adds 5 nullable columns to trades, creates positions table with composite PK and CASCADE DELETE, updates DbTradeRow struct and query_trades() to include new fields, and passes all existing + new tests.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-schema-migration-data-model/01-RESEARCH.md

@capitoltraders_lib/src/db.rs
@schema/sqlite.sql
@capitoltraders_cli/src/output_tests.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema migration v2 and positions table DDL</name>
  <files>capitoltraders_lib/src/db.rs, schema/sqlite.sql</files>
  <action>
1. In `capitoltraders_lib/src/db.rs`, add a `migrate_v2(&self)` method to the `Db` impl block (after the existing `migrate_v1` method around line 66-81). The method should:
   - Execute 5 ALTER TABLE statements individually (NOT batch):
     - `ALTER TABLE trades ADD COLUMN trade_date_price REAL`
     - `ALTER TABLE trades ADD COLUMN current_price REAL`
     - `ALTER TABLE trades ADD COLUMN price_enriched_at TEXT`
     - `ALTER TABLE trades ADD COLUMN estimated_shares REAL`
     - `ALTER TABLE trades ADD COLUMN estimated_value REAL`
   - NOTE: Use REAL (not INTEGER) for estimated_shares. The research anti-patterns section explicitly says "Use REAL for shares_held, estimated_shares to preserve precision" because midpoint/price rarely divides evenly into whole shares. Map to `Option<f64>` in Rust.
   - For each statement, match on errors exactly like migrate_v1: catch `rusqlite::Error::SqliteFailure(_, Some(ref msg))` where msg contains "duplicate column name" (silently skip). Also catch "no such table" like v1 does. Return any other error.

2. Update the `init(&self)` method (around line 48-64) to call migrate_v2 after migrate_v1:
   - After the `if version < 1` block, add: `if version < 2 { self.migrate_v2()?; self.conn.pragma_update(None, "user_version", 2)?; }`
   - Keep the existing `include_str!("../../schema/sqlite.sql")` and `execute_batch` call AFTER both migration blocks (it runs on every open, creating tables if missing).

3. In `schema/sqlite.sql`, add the positions table and its indexes BEFORE the `ingest_meta` table (around line 137). Add:
   ```sql
   CREATE TABLE IF NOT EXISTS positions (
       politician_id TEXT NOT NULL,
       issuer_ticker TEXT NOT NULL,
       shares_held REAL NOT NULL,
       cost_basis REAL NOT NULL,
       realized_pnl REAL NOT NULL DEFAULT 0.0,
       last_updated TEXT NOT NULL,
       PRIMARY KEY (politician_id, issuer_ticker),
       FOREIGN KEY (politician_id) REFERENCES politicians(politician_id) ON DELETE CASCADE
   );
   ```
   And add three indexes after the existing CREATE INDEX block (after the idx_issuers_enriched line):
   ```sql
   CREATE INDEX IF NOT EXISTS idx_positions_politician ON positions(politician_id);
   CREATE INDEX IF NOT EXISTS idx_positions_ticker ON positions(issuer_ticker);
   CREATE INDEX IF NOT EXISTS idx_positions_updated ON positions(last_updated);
   ```
   Also add an index for the new price_enriched_at column on trades:
   ```sql
   CREATE INDEX IF NOT EXISTS idx_trades_price_enriched ON trades(price_enriched_at);
   ```
  </action>
  <verify>
  Run `cargo check -p capitoltraders_lib` -- should compile without errors. The migrate_v2 function and updated init() must compile. The sqlite.sql must be valid SQL (verified when execute_batch runs in tests).
  </verify>
  <done>
  - migrate_v2() method exists on Db, adds 5 nullable REAL/TEXT columns to trades
  - init() calls migrate_v2 when version < 2, bumps user_version to 2
  - sqlite.sql contains positions table DDL with composite PK, CASCADE DELETE, and 3 indexes
  - sqlite.sql contains idx_trades_price_enriched index
  </done>
</task>

<task type="auto">
  <name>Task 2: Update DbTradeRow, query_trades, and all tests</name>
  <files>capitoltraders_lib/src/db.rs, capitoltraders_cli/src/output_tests.rs</files>
  <action>
1. Update `DbTradeRow` struct (around line 1625) to add 5 new fields AFTER the `enriched_at` field and BEFORE `politician_name`:
   ```rust
   pub trade_date_price: Option<f64>,
   pub current_price: Option<f64>,
   pub price_enriched_at: Option<String>,
   pub estimated_shares: Option<f64>,
   pub estimated_value: Option<f64>,
   ```
   The struct already derives `Serialize`, so these will appear in JSON/XML output automatically.

2. Update `query_trades()` SELECT statement (around line 1270) to include the 5 new columns. Insert them after `t.enriched_at` (column index 9) and before the politician JOIN columns:
   ```sql
   t.trade_date_price, t.current_price, t.price_enriched_at,
   t.estimated_shares, t.estimated_value,
   ```
   This shifts all subsequent column indices by 5.

3. Update the row mapping in `query_trades()` (around line 1344-1377). The current mapping has:
   - Indices 0-9: trade fields (tx_id through enriched_at)
   - Indices 10-16: joined fields (politician_name through asset_type)
   - Indices 17-18: GROUP_CONCAT (committees, labels)

   After adding 5 columns after index 9, the new mapping becomes:
   - Indices 0-9: trade fields (unchanged)
   - Index 10: trade_date_price (Option<f64>)
   - Index 11: current_price (Option<f64>)
   - Index 12: price_enriched_at (Option<String>)
   - Index 13: estimated_shares (Option<f64>)
   - Index 14: estimated_value (Option<f64>)
   - Index 15: politician_name
   - Index 16: party
   - Index 17: state
   - Index 18: chamber
   - Index 19: issuer_name
   - Index 20: issuer_ticker (keep the `.unwrap_or_default()` pattern)
   - Index 21: asset_type
   - Index 22: committees (GROUP_CONCAT)
   - Index 23: labels (GROUP_CONCAT)

   The committees_str/labels_str extraction at the top of the closure must also update to use the new indices (22 and 23 instead of 17 and 18).

4. Update `sample_db_trade_row()` in `capitoltraders_cli/src/output_tests.rs` (around line 286) to include the 5 new fields with `None` values, placed after `enriched_at` and before `politician_name`:
   ```rust
   trade_date_price: None,
   current_price: None,
   price_enriched_at: None,
   estimated_shares: None,
   estimated_value: None,
   ```

5. Add new tests in the `mod tests` block in db.rs (after the existing test_migration_on_existing_db test). Add:

   a. `test_migration_v1_to_v2`: Similar to existing test_migration_on_existing_db but starts with a v1 database (user_version=1, enriched_at columns present). Verifies:
      - New columns exist after migration: trade_date_price, current_price, price_enriched_at, estimated_shares, estimated_value on trades
      - positions table exists with expected columns
      - user_version is 2 after migration
      - Pre-existing trade data is preserved (insert a trade before migration, verify after)

   b. `test_migration_v2_idempotent`: Run init() twice on same DB. Second call should succeed without errors. Verify user_version is still 2.

   c. `test_query_trades_price_fields`: Insert a trade (with all FK parent rows), manually UPDATE the trade to set trade_date_price=150.25, current_price=175.50, price_enriched_at='2025-06-01T00:00:00Z', estimated_shares=100.0, estimated_value=15025.0. Then call query_trades() with default filter and verify the returned DbTradeRow has the correct values in the new Option fields.

   d. `test_query_trades_price_fields_null`: Insert a trade without setting price fields. Query and verify all 5 new fields are None.

   For the v1-to-v2 migration test, you need a V1_SCHEMA constant. Create it by copying the current OLD_SCHEMA and adding the enriched_at columns that v1 adds (trades.enriched_at, politicians.enriched_at, issuers.enriched_at). This represents a database that has already been migrated to v1 but not yet to v2.

   Use the existing helper functions: has_column(), get_user_version(), open_test_db().
  </action>
  <verify>
  Run `cargo test --workspace` -- all existing tests must pass, plus the 4 new tests. Run `cargo clippy --workspace` -- no new warnings. Specifically verify:
  - `cargo test -p capitoltraders_lib migration` -- migration tests pass
  - `cargo test -p capitoltraders_lib query_trades_price` -- price field tests pass
  - `cargo test -p capitoltraders_cli output_tests` -- output tests pass with updated fixture
  </verify>
  <done>
  - DbTradeRow has 5 new Option fields (trade_date_price, current_price, price_enriched_at, estimated_shares, estimated_value)
  - query_trades() SELECT includes new columns, row mapping indices are correct
  - sample_db_trade_row() in output_tests.rs includes new fields with None values
  - 4 new tests pass: v1-to-v2 migration, idempotency, price fields populated, price fields null
  - All 294+ existing tests still pass
  - No clippy warnings
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `cargo test --workspace` -- all tests pass (existing 294+ plus 4 new)
2. `cargo clippy --workspace` -- no warnings
3. `cargo check --workspace` -- clean compilation
4. Verify schema version progression:
   - Fresh DB: init() creates schema, user_version = 2
   - v0 DB (pre-migration): init() runs migrate_v1 then migrate_v2, user_version = 2
   - v1 DB (has enriched_at): init() skips v1, runs migrate_v2, user_version = 2
   - v2 DB (already migrated): init() skips both migrations, user_version = 2
5. Verify positions table: `PRAGMA table_info(positions)` shows 6 columns with correct types
6. Verify trades columns: `PRAGMA table_info(trades)` shows 5 new columns (all nullable)
</verification>

<success_criteria>
- trades table has trade_date_price REAL, current_price REAL, price_enriched_at TEXT, estimated_shares REAL, estimated_value REAL columns
- positions table exists with composite PK (politician_id, issuer_ticker), CASCADE DELETE, 3 indexes
- Migration from v1 to v2 succeeds without data loss (tested)
- Migration is idempotent -- re-running on v2 DB succeeds silently (tested)
- DbTradeRow includes all 5 new fields as Option types
- query_trades() returns new fields correctly (tested with populated and null values)
- All existing tests pass unchanged (except output_tests fixture update)
- cargo clippy clean
</success_criteria>

<output>
After completion, create `.planning/phases/01-schema-migration-data-model/01-01-SUMMARY.md`
</output>
