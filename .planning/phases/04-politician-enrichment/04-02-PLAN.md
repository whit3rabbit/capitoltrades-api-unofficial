---
phase: 04-politician-enrichment
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - capitoltraders_cli/src/commands/sync.rs
autonomous: true

must_haves:
  truths:
    - "Running sync automatically enriches politician committee memberships without any opt-in flag"
    - "Committee enrichment iterates all 48 committee codes from COMMITTEE_MAP"
    - "Pagination is handled for committees with more than 12 members"
    - "Progress is reported to stderr during committee enrichment"
  artifacts:
    - path: "capitoltraders_cli/src/commands/sync.rs"
      provides: "enrich_politician_committees() async function wired into sync::run()"
      contains: "enrich_politician_committees"
  key_links:
    - from: "sync.rs::enrich_politician_committees"
      to: "scrape.rs::politicians_by_committee"
      via: "iterates COMMITTEE_MAP codes"
      pattern: "politicians_by_committee"
    - from: "sync.rs::enrich_politician_committees"
      to: "db.rs::replace_all_politician_committees"
      via: "collects memberships then persists atomically"
      pattern: "replace_all_politician_committees"
    - from: "sync.rs::run"
      to: "sync.rs::enrich_politician_committees"
      via: "unconditional call after trade sync"
      pattern: "enrich_politician_committees"
---

<objective>
Wire politician committee enrichment into the sync pipeline as an automatic post-ingest step.

Purpose: POL-03 requires that politician enrichment runs automatically during sync without an opt-in flag. Committee enrichment is fast (~48 requests at 500ms = ~25 seconds), so it should always run. This plan adds the orchestration function that iterates all 48 committee codes, scrapes each listing page, collects politician-to-committee mappings, and persists them via the methods created in plan 04-01.

Output: enrich_politician_committees() function in sync.rs, wired unconditionally into sync::run().
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-politician-enrichment/04-RESEARCH.md
@.planning/phases/04-politician-enrichment/04-01-SUMMARY.md
@capitoltraders_cli/src/commands/sync.rs
@capitoltraders_lib/src/validation.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add enrich_politician_committees and wire into sync::run</name>
  <files>capitoltraders_cli/src/commands/sync.rs</files>
  <action>
1. Add `use capitoltraders_lib::validation;` import to sync.rs (if not already present).

2. Add `enrich_politician_committees()` async function:
   ```rust
   async fn enrich_politician_committees(
       scraper: &ScrapeClient,
       db: &Db,
       throttle_ms: u64,
   ) -> Result<usize>
   ```
   Implementation:
   - Collect all memberships into a `Vec<(String, String)>` (politician_id, committee_code).
   - Iterate over `validation::COMMITTEE_MAP` (48 entries).
   - For each committee code:
     - Fetch page 1 via `scraper.politicians_by_committee(code, 1).await?`
     - Extract politician_ids from returned cards, push (politician_id, code) pairs into the memberships vec.
     - Handle pagination: if total_pages > 1, fetch subsequent pages (check `resp.total_pages.unwrap_or(1)`). Most committees fit on 1 page (12 per page), but some (like Appropriations) may have 20-30+ members.
     - Print progress: `eprintln!("  {}: {} members", name, count)` for each committee.
     - Sleep throttle_ms between requests (if throttle_ms > 0). Use `tokio::time::sleep(Duration::from_millis(throttle_ms))`.
   - After iterating all committees, call `db.replace_all_politician_committees(&memberships)?`.
   - Call `db.mark_politicians_enriched()?`.
   - Print summary: `eprintln!("Committee enrichment: {} memberships across 48 committees", memberships.len())`.
   - Return total membership count.

3. Wire into `sync::run()`:
   - Add the call AFTER trade sync (and any trade enrichment) but before the final "Sync complete" message. This means after the `if should_enrich { ... }` block.
   - The call should be unconditional (POL-03: no opt-in flag needed):
     ```rust
     let committee_count = enrich_politician_committees(
         &scraper,
         &db,
         args.details_delay_ms,
     ).await?;
     ```
   - Note: `db` needs to be passed as `&db` (not `&mut db`). The replace_all_politician_committees method uses unchecked_transaction which works with &self. Check that `db` is not consumed or exclusively borrowed at this point in run(). Currently `db` is `let mut db = Db::open(...)`. After sync_trades (which takes `&mut db`), the mutable borrow is released and `&db` should work fine for the committee call.
   - Update the final eprintln to include committee count if desired, or keep the committee enrichment's own progress output.

4. Error handling: If committee enrichment fails, let it propagate via `?`. A network failure during committee scraping should fail the sync, not silently continue. The retry logic in ScrapeClient::with_retry will handle transient failures.
  </action>
  <verify>
    `cargo build -p capitoltraders_cli` compiles without errors.
    `cargo clippy -p capitoltraders_cli` produces no warnings.
    `cargo test --workspace` -- all tests pass (no runtime test for this since it requires network; the unit tests from 04-01 cover the DB layer).
  </verify>
  <done>
    sync::run() unconditionally calls enrich_politician_committees() after trade sync. The function iterates all 48 committee codes, handles pagination, respects throttle delay, and persists results via replace_all_politician_committees + mark_politicians_enriched. No --enrich flag required for politician enrichment.
  </done>
</task>

</tasks>

<verification>
- `cargo build --workspace` compiles
- `cargo clippy --workspace` -- no warnings
- Reading sync.rs confirms enrich_politician_committees is called unconditionally after trade sync
- The function iterates COMMITTEE_MAP, handles pagination, uses throttle delay
- No new CLI flags added (POL-03: automatic)
</verification>

<success_criteria>
- enrich_politician_committees() exists in sync.rs and iterates all 48 committee codes
- Pagination is handled (loops if total_pages > 1)
- Throttle delay is respected between requests
- replace_all_politician_committees + mark_politicians_enriched called after all committees scraped
- sync::run() calls enrich_politician_committees unconditionally (no flag)
- Code compiles, no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/04-politician-enrichment/04-02-SUMMARY.md`
</output>
