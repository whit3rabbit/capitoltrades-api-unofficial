---
phase: 04-politician-enrichment
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - capitoltraders_cli/src/commands/sync.rs
autonomous: true

must_haves:
  truths:
    - "Running sync automatically enriches politician committee memberships without any opt-in flag"
    - "Committee enrichment iterates all 48 committee codes from COMMITTEE_MAP"
    - "Pagination is handled for committees with more than 12 members"
    - "Progress is reported to stderr during committee enrichment"
  artifacts:
    - path: "capitoltraders_cli/src/commands/sync.rs"
      provides: "enrich_politician_committees() async function wired into sync::run()"
      contains: "enrich_politician_committees"
  key_links:
    - from: "sync.rs::enrich_politician_committees"
      to: "scrape.rs::politicians_by_committee"
      via: "iterates COMMITTEE_MAP codes"
      pattern: "politicians_by_committee"
    - from: "sync.rs::enrich_politician_committees"
      to: "db.rs::replace_all_politician_committees"
      via: "collects memberships then persists atomically"
      pattern: "replace_all_politician_committees"
    - from: "sync.rs::run"
      to: "sync.rs::enrich_politician_committees"
      via: "unconditional call after trade sync"
      pattern: "enrich_politician_committees"
---

<objective>
Wire politician committee enrichment into the sync pipeline as an automatic post-ingest step.

Purpose: POL-03 requires that politician enrichment runs automatically during sync without an opt-in flag. Committee enrichment is fast (~48 requests at 500ms = ~25 seconds), so it should always run. This plan adds the orchestration function that iterates all 48 committee codes, scrapes each listing page, collects politician-to-committee mappings, and persists them via the methods created in plan 04-01.

Output: enrich_politician_committees() function in sync.rs, wired unconditionally into sync::run().
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-politician-enrichment/04-RESEARCH.md
@.planning/phases/04-politician-enrichment/04-01-SUMMARY.md
@capitoltraders_cli/src/commands/sync.rs
@capitoltraders_lib/src/validation.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add enrich_politician_committees and wire into sync::run</name>
  <files>capitoltraders_cli/src/commands/sync.rs</files>
  <action>
**Step 0: Read sync.rs and verify db borrow state at the insertion point (MANDATORY FIRST)**

Read `capitoltraders_cli/src/commands/sync.rs` in full. Verify the following before writing any code:

The current sync::run() structure (verified by checker review of the file):
- Line 65: `let mut db = Db::open(&args.db)?;` -- db is declared as mutable local.
- Lines 105-112: `sync_trades(&scraper, &mut db, ...)` takes `&mut db`. The mutable borrow is released when sync_trades returns at line 112.
- Lines 114-116: `db.set_meta(...)` calls take `&self` (shared borrow) -- works fine after mut borrow released.
- Lines 125-138: `enrich_trades(&scraper, &db, ...)` takes `&Db` (shared borrow) -- works fine.
- Line 140: `Ok(())` -- end of function.

The insertion point for enrich_politician_committees is AFTER line 138 (after the `if should_enrich { ... }` block) and BEFORE line 140 (`Ok(())`). At this point, `db` is a local `mut Db` with no outstanding borrows. Passing `&db` (shared borrow) is valid.

If the file has changed since this review (different line numbers or structure), locate the equivalent point: after trade enrichment, before the final `Ok(())`. Verify `db` is available for `&db` borrow at that point.

1. Add `use capitoltraders_lib::validation;` import to sync.rs (if not already present).

2. Add `enrich_politician_committees()` async function:
   ```rust
   async fn enrich_politician_committees(
       scraper: &ScrapeClient,
       db: &Db,
       throttle_ms: u64,
   ) -> Result<usize>
   ```
   Implementation:
   - Collect all memberships into a `Vec<(String, String)>` (politician_id, committee_code).
   - Iterate over `validation::COMMITTEE_MAP` (48 entries).
   - For each committee code:
     - Fetch page 1 via `scraper.politicians_by_committee(code, 1).await?`
     - Extract politician_ids from returned cards, push (politician_id, code) pairs into the memberships vec.
     - Handle pagination: if total_pages > 1, fetch subsequent pages (check `resp.total_pages.unwrap_or(1)`). Most committees fit on 1 page (12 per page), but some (like Appropriations) may have 20-30+ members.
     - Print progress: `eprintln!("  {}: {} members", name, count)` for each committee.
     - Sleep throttle_ms between requests (if throttle_ms > 0). Use `tokio::time::sleep(Duration::from_millis(throttle_ms))`.
   - After iterating all committees, call `db.replace_all_politician_committees(&memberships)?`.
   - Call `db.mark_politicians_enriched()?`.
   - Print summary: `eprintln!("Committee enrichment: {} memberships across 48 committees", memberships.len())`.
   - Return total membership count.

3. Wire into `sync::run()`:
   - Insert the call AFTER the `if should_enrich { ... }` block (after trade enrichment) and BEFORE `Ok(())`.
   - The call is unconditional (POL-03: no opt-in flag needed):
     ```rust
     eprintln!("Syncing politician committee memberships...");
     let committee_count = enrich_politician_committees(
         &scraper,
         &db,
         args.details_delay_ms,
     ).await?;
     ```
   - `&db` is passed as a shared borrow. This is valid because the prior `&mut db` borrow (from sync_trades) was released, and `enrich_trades` also used `&db` successfully.

4. Error handling: If committee enrichment fails, let it propagate via `?`. A network failure during committee scraping should fail the sync, not silently continue. The retry logic in ScrapeClient::with_retry will handle transient failures.
  </action>
  <verify>
    `cargo build -p capitoltraders_cli` compiles without errors.
    `cargo clippy -p capitoltraders_cli` produces no warnings.
    `cargo test --workspace` -- all tests pass (no runtime test for this since it requires network; the unit tests from 04-01 cover the DB layer).
  </verify>
  <done>
    sync::run() unconditionally calls enrich_politician_committees() after trade sync. The function iterates all 48 committee codes, handles pagination, respects throttle delay, and persists results via replace_all_politician_committees + mark_politicians_enriched. No --enrich flag required for politician enrichment.
  </done>
</task>

</tasks>

<verification>
- `cargo build --workspace` compiles
- `cargo clippy --workspace` -- no warnings
- Reading sync.rs confirms enrich_politician_committees is called unconditionally after trade sync
- The function iterates COMMITTEE_MAP, handles pagination, uses throttle delay
- No new CLI flags added (POL-03: automatic)
</verification>

<success_criteria>
- enrich_politician_committees() exists in sync.rs and iterates all 48 committee codes
- Pagination is handled (loops if total_pages > 1)
- Throttle delay is respected between requests
- replace_all_politician_committees + mark_politicians_enriched called after all committees scraped
- sync::run() calls enrich_politician_committees unconditionally (no flag)
- Code compiles, no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/04-politician-enrichment/04-02-SUMMARY.md`
</output>
