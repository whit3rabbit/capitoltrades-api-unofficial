---
phase: 05-portfolio-calculator-fifo
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - capitoltraders_lib/src/portfolio.rs
  - capitoltraders_lib/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "FIFO accounting produces correct net shares per politician per ticker"
    - "Sells consume oldest lots first (FIFO order)"
    - "Realized P&L accumulates correctly from closed lots"
    - "Average cost basis reflects weighted average of remaining lots"
    - "Oversold positions log warning and do not panic"
    - "Exchange transactions are treated as no-op"
    - "Receive transactions add shares like buys"
  artifacts:
    - path: "capitoltraders_lib/src/portfolio.rs"
      provides: "FIFO calculator with Lot, Position, TradeFIFO, calculate_positions"
      exports: ["Lot", "Position", "TradeFIFO", "calculate_positions"]
    - path: "capitoltraders_lib/src/lib.rs"
      provides: "Module registration and public exports for portfolio types"
      contains: "pub mod portfolio"
  key_links:
    - from: "capitoltraders_lib/src/portfolio.rs"
      to: "std::collections::VecDeque"
      via: "FIFO lot queue in Position"
      pattern: "VecDeque<Lot>"
    - from: "capitoltraders_lib/src/portfolio.rs"
      to: "std::collections::HashMap"
      via: "Position lookup by (politician_id, ticker)"
      pattern: "HashMap<.*Position>"
    - from: "capitoltraders_lib/src/lib.rs"
      to: "capitoltraders_lib/src/portfolio.rs"
      via: "pub mod and pub use"
      pattern: "pub use portfolio"
---

<objective>
Implement the FIFO portfolio calculator as a pure logic module with comprehensive tests using TDD.

Purpose: The FIFO calculator is the core business logic for Phase 5 -- it processes chronologically-ordered trades and maintains per-politician per-ticker positions with lot-level cost basis tracking and realized P&L accumulation. This is a textbook TDD candidate: defined inputs (Vec<TradeFIFO>), defined outputs (HashMap of Positions), and many edge cases that benefit from test-first design.

Output: `capitoltraders_lib/src/portfolio.rs` with Lot, Position, TradeFIFO structs and calculate_positions function, all fully tested.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-portfolio-calculator-fifo/05-RESEARCH.md
@capitoltraders_lib/src/lib.rs
</context>

<tasks>

<feature>
  <name>Feature: FIFO Portfolio Calculator</name>
  <files>capitoltraders_lib/src/portfolio.rs, capitoltraders_lib/src/lib.rs</files>
  <behavior>
    The FIFO calculator processes a chronologically-ordered vector of TradeFIFO records
    and produces a HashMap of (politician_id, ticker) -> Position entries. Each Position
    tracks a VecDeque of Lot entries (FIFO queue) and accumulated realized_pnl.

    Types:

    - Lot { shares: f64, cost_basis: f64, tx_date: String } -- a single buy lot
    - Position { politician_id: String, ticker: String, lots: VecDeque<Lot>, realized_pnl: f64 }
    - TradeFIFO { tx_id: i64, politician_id: String, ticker: String, tx_type: String, tx_date: String, estimated_shares: f64, trade_date_price: f64 }

    Position methods:
    - buy(shares, price, tx_date): push_back a new Lot
    - sell(shares, price) -> Result<(), String>: consume lots FIFO, accumulate realized P&L. Return Err on oversold (empty queue).
    - shares_held() -> f64: sum of all lot shares
    - avg_cost_basis() -> f64: weighted average (total_cost / total_shares), return 0.0 when empty

    calculate_positions(trades: Vec<TradeFIFO>) -> HashMap<(String, String), Position>:
    - Iterates trades in order (caller must provide chronological order)
    - Groups by (politician_id, ticker) via HashMap::entry
    - "buy" and "receive" -> Position::buy()
    - "sell" -> Position::sell(), log warning on Err (eprintln), continue
    - "exchange" -> skip (no-op, log occurrence)
    - Unknown tx_type -> skip (log warning)

    Epsilon constant: 0.0001 for floating-point zero checks.

    Test cases (input -> expected output):

    1. Single buy: buy 100 shares @ $50 -> shares_held=100, avg_cost_basis=50, realized_pnl=0
    2. Buy then full sell: buy 100 @ $50, sell 100 @ $75 -> shares_held=0, realized_pnl=2500
    3. Buy then partial sell: buy 100 @ $50, sell 40 @ $75 -> shares_held=60, avg_cost_basis=50, realized_pnl=1000
    4. Multiple buys then sell (FIFO): buy 50 @ $40, buy 50 @ $60, sell 70 @ $80 -> shares_held=30, avg_cost_basis=60, realized_pnl=(50*40 + 20*20)=2400
    5. Sell from empty (oversold): sell 10 @ $50 with no prior buys -> Err, realized_pnl unchanged
    6. Sell more than held: buy 30 @ $50, sell 50 @ $70 -> partial fill (30 sold), then Err for remaining 20, realized_pnl=600
    7. Receive adds shares: receive 100 @ $45 -> shares_held=100, avg_cost_basis=45
    8. Exchange is no-op: exchange 50 @ $60 -> shares_held unchanged
    9. Multiple politicians same ticker: politician A buys AAPL, politician B buys AAPL -> two separate Position entries
    10. Same politician different tickers: politician A buys AAPL and MSFT -> two separate Position entries
    11. Epsilon zero check: buy 100 @ $50, sell 99.99999 @ $75 -> shares_held rounds to effectively 0 (less than epsilon)
    12. avg_cost_basis when empty: no lots -> returns 0.0
    13. Unknown tx_type: skipped, no effect on position
    14. Full lifecycle: buy 100 @ $50, buy 50 @ $60, sell 80 @ $70, sell 30 @ $80 -> shares_held=40, avg_cost_basis=60, realized_pnl correctly accumulated from FIFO matching
  </behavior>
  <implementation>
    Create capitoltraders_lib/src/portfolio.rs:

    1. Define const EPSILON: f64 = 0.0001;
    2. Define Lot struct with Debug, Clone derives
    3. Define Position struct with Debug, Clone derives and new(), buy(), sell(), shares_held(), avg_cost_basis() methods
       - sell() uses while loop: remaining > EPSILON, pop from front of VecDeque, calculate partial P&L
       - When lot.shares < EPSILON after subtraction, pop_front() the exhausted lot
       - On empty VecDeque (front() returns None), return Err with descriptive message including politician_id, ticker, remaining shares
    4. Define TradeFIFO struct with Debug derive
    5. Define calculate_positions(trades: Vec<TradeFIFO>) -> HashMap<(String, String), Position>
       - Use HashMap::entry().or_insert_with() pattern
       - Match tx_type.as_str() for "buy"|"receive", "sell", "exchange", and wildcard
       - eprintln! warnings for oversold and unknown types
    6. Register module in lib.rs: add `pub mod portfolio;` and add exports to pub use block

    Use std::collections::{HashMap, VecDeque} only. No external dependencies needed.

    Do NOT use strict f64 equality (== 0.0). Always compare with EPSILON.
    Do NOT fail on oversold positions. Log and continue.
    Do NOT process exchange transactions (treat as no-op per research recommendation).
  </implementation>
</feature>

</tasks>

<verification>
- `cargo test -p capitoltraders_lib portfolio` runs all portfolio tests and they pass
- `cargo clippy --workspace` has no new warnings
- `cargo check --workspace` compiles cleanly (portfolio types are exported)
- At least 14 test cases covering all behaviors listed above
</verification>

<success_criteria>
- Position::buy() adds lot to back of VecDeque
- Position::sell() consumes lots from front (FIFO), accumulates realized P&L
- Position::sell() returns Err on oversold, does not panic
- Position::shares_held() sums all lot shares
- Position::avg_cost_basis() returns weighted average or 0.0 when empty
- calculate_positions() groups by (politician_id, ticker) and dispatches by tx_type
- Exchange transactions skipped, unknown tx_types skipped
- Receive transactions add shares like buys
- All epsilon comparisons use 0.0001 constant, no exact f64 equality
- Module registered in lib.rs with public exports
</success_criteria>

<output>
After completion, create `.planning/phases/05-portfolio-calculator-fifo/05-01-SUMMARY.md`
</output>
