---
phase: 05-portfolio-calculator-fifo
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - capitoltraders_lib/src/db.rs
  - capitoltraders_lib/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Trades are queried in chronological order with stock-only filtering for FIFO input"
    - "Calculated positions are upserted to the positions table with ON CONFLICT handling"
    - "Portfolio query joins positions with current prices for unrealized P&L"
    - "Option trades are counted separately per politician for reporting"
    - "Closed positions (shares_held near zero) are stored but filtered in portfolio queries"
  artifacts:
    - path: "capitoltraders_lib/src/db.rs"
      provides: "Portfolio DB operations: query_trades_for_portfolio, upsert_positions, get_portfolio, count_option_trades"
      exports: ["PortfolioPosition"]
    - path: "capitoltraders_lib/src/lib.rs"
      provides: "PortfolioPosition export added to pub use db block"
      contains: "PortfolioPosition"
  key_links:
    - from: "capitoltraders_lib/src/db.rs::query_trades_for_portfolio"
      to: "capitoltraders_lib/src/portfolio.rs::TradeFIFO"
      via: "Returns Vec<TradeFIFO> for calculate_positions input"
      pattern: "Vec<TradeFIFO>"
    - from: "capitoltraders_lib/src/db.rs::upsert_positions"
      to: "capitoltraders_lib/src/portfolio.rs::Position"
      via: "Reads Position HashMap to write to positions table"
      pattern: "HashMap.*Position"
    - from: "capitoltraders_lib/src/db.rs::get_portfolio"
      to: "positions table + trades table"
      via: "JOIN for current_price lookup"
      pattern: "LEFT JOIN trades"
---

<objective>
Add DB operations for the portfolio calculator: querying trades for FIFO input, upserting calculated positions, and querying portfolio with unrealized P&L.

Purpose: The FIFO calculator from Plan 01 needs data from SQLite and writes results back. This plan wires the calculator to the database with four operations: (1) query trades ordered for FIFO processing, (2) bulk upsert positions, (3) query portfolio with current price join for unrealized P&L, and (4) count option trades for reporting. These operations complete the Phase 5 requirements and prepare data access for Phase 6's CLI command.

Output: Four new methods on Db, PortfolioPosition struct, option trade counting, all with comprehensive tests.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-portfolio-calculator-fifo/05-RESEARCH.md
@.planning/phases/05-portfolio-calculator-fifo/05-01-SUMMARY.md
@capitoltraders_lib/src/db.rs
@capitoltraders_lib/src/portfolio.rs
@capitoltraders_lib/src/lib.rs
@schema/sqlite.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add query_trades_for_portfolio and upsert_positions DB methods</name>
  <files>capitoltraders_lib/src/db.rs, capitoltraders_lib/src/lib.rs</files>
  <action>
    Add two methods to Db impl in db.rs:

    1. **query_trades_for_portfolio(&self) -> Result<Vec<TradeFIFO>, DbError>**
       - Import TradeFIFO from crate::portfolio (add `use crate::portfolio::TradeFIFO;` at top)
       - SQL query:
         ```sql
         SELECT t.tx_id, t.politician_id, i.issuer_ticker, t.tx_type, t.tx_date,
                t.estimated_shares, t.trade_date_price
         FROM trades t
         JOIN issuers i ON t.issuer_id = i.issuer_id
         JOIN assets a ON t.asset_id = a.asset_id
         WHERE t.estimated_shares IS NOT NULL
           AND t.trade_date_price IS NOT NULL
           AND a.asset_type = 'stock'
         ORDER BY t.tx_date ASC, t.tx_id ASC
         ```
       - IMPORTANT: JOIN assets table to filter by asset_type = 'stock' (exact match, not LIKE)
       - IMPORTANT: JOIN issuers table for issuer_ticker (ticker lives on issuers, not trades)
       - IMPORTANT: ORDER BY tx_date ASC, tx_id ASC for deterministic FIFO ordering
       - Filter WHERE estimated_shares IS NOT NULL AND trade_date_price IS NOT NULL (skip un-enriched trades)
       - Map rows to TradeFIFO struct using row.get() pattern matching existing code style
       - issuer_ticker: use row.get::<_, String>() (NOT Option -- WHERE already ensures non-null via JOIN)

    2. **upsert_positions(&self, positions: &std::collections::HashMap<(String, String), crate::portfolio::Position>) -> Result<usize, DbError>**
       - Use unchecked_transaction() pattern (consistent with existing db.rs code)
       - Prepare statement:
         ```sql
         INSERT INTO positions (politician_id, issuer_ticker, shares_held, cost_basis, realized_pnl, last_updated)
         VALUES (?1, ?2, ?3, ?4, ?5, datetime('now'))
         ON CONFLICT(politician_id, issuer_ticker)
         DO UPDATE SET
           shares_held = excluded.shares_held,
           cost_basis = excluded.cost_basis,
           realized_pnl = excluded.realized_pnl,
           last_updated = excluded.last_updated
         ```
       - Iterate over positions HashMap. For each position:
         - Call pos.shares_held() and pos.avg_cost_basis() from portfolio module
         - Include ALL positions (even closed ones with shares_held < EPSILON) for audit trail
         - Store realized_pnl from pos.realized_pnl
       - Commit transaction
       - Return count of upserted rows (for progress reporting)

    Add import at top of db.rs: `use crate::portfolio::TradeFIFO;`
    (Do NOT import Position in the use block -- use full path in the method signature to avoid circular dependency confusion. The method signature uses &HashMap<(String, String), crate::portfolio::Position>.)

    Add PortfolioPosition to lib.rs exports: add `PortfolioPosition` to the `pub use db::{...}` block. (PortfolioPosition is defined in Task 2, but update lib.rs exports here or in Task 2.)

    Write tests in the #[cfg(test)] mod tests block at the bottom of db.rs:

    Test 1: test_query_trades_for_portfolio_empty -- empty DB returns empty vec
    Test 2: test_query_trades_for_portfolio_filters_options -- insert stock and option trades, verify only stock trades returned
    Test 3: test_query_trades_for_portfolio_ordering -- insert trades with different dates, verify ASC order
    Test 4: test_query_trades_for_portfolio_skips_unenriched -- insert trade with NULL estimated_shares, verify excluded
    Test 5: test_upsert_positions_basic -- create Position via portfolio::Position::new() + buy(), upsert, verify row in positions table
    Test 6: test_upsert_positions_updates_existing -- upsert twice, verify ON CONFLICT updates values

    For test setup: use the existing test helper pattern from db.rs. Create minimal rows:
    - Insert into politicians (politician_id, state_id, party, first_name, last_name, dob, gender, chamber)
    - Insert into issuers (issuer_id, issuer_name, issuer_ticker)
    - Insert into assets (asset_id, asset_type) -- use 'stock' and 'stock-option' for filtering tests
    - Insert into trades (tx_id, politician_id, asset_id, issuer_id, pub_date, filing_date, tx_date, tx_type, has_capital_gains, owner, chamber, value, filing_id, filing_url, reporting_gap, estimated_shares, trade_date_price)
  </action>
  <verify>
    `cargo test -p capitoltraders_lib query_trades_for_portfolio` passes
    `cargo test -p capitoltraders_lib upsert_positions` passes
    `cargo check --workspace` compiles
  </verify>
  <done>
    query_trades_for_portfolio returns only stock trades with non-null estimated_shares and trade_date_price, ordered by tx_date ASC then tx_id ASC. upsert_positions writes Position data to positions table with ON CONFLICT update. All 6 tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add get_portfolio and count_option_trades DB methods</name>
  <files>capitoltraders_lib/src/db.rs, capitoltraders_lib/src/lib.rs</files>
  <action>
    Add PortfolioPosition struct and two more methods to Db impl in db.rs:

    1. **PortfolioPosition struct** (above the Db impl, near other row structs):
       ```rust
       #[derive(Debug, Clone, Serialize)]
       pub struct PortfolioPosition {
           pub politician_id: String,
           pub ticker: String,
           pub shares_held: f64,
           pub cost_basis: f64,
           pub realized_pnl: f64,
           pub unrealized_pnl: Option<f64>,
           pub unrealized_pnl_pct: Option<f64>,
           pub current_price: Option<f64>,
           pub current_value: Option<f64>,
           pub price_date: Option<String>,
           pub last_updated: String,
       }
       ```
       Derive Debug, Clone, Serialize (matches existing DbTradeRow pattern).

    2. **get_portfolio(&self, filter: &PortfolioFilter) -> Result<Vec<PortfolioPosition>, DbError>**
       - Define PortfolioFilter struct:
         ```rust
         #[derive(Debug, Default)]
         pub struct PortfolioFilter {
             pub politician_id: Option<String>,
             pub ticker: Option<String>,
             pub party: Option<String>,
             pub state: Option<String>,
             pub include_closed: bool,
         }
         ```
       - SQL query with dynamic WHERE clauses (follow existing DbTradeFilter pattern):
         ```sql
         SELECT
           p.politician_id,
           p.issuer_ticker,
           p.shares_held,
           p.cost_basis,
           p.realized_pnl,
           (SELECT t2.current_price
            FROM trades t2
            JOIN issuers i2 ON t2.issuer_id = i2.issuer_id
            WHERE i2.issuer_ticker = p.issuer_ticker
              AND t2.current_price IS NOT NULL
            ORDER BY t2.price_enriched_at DESC
            LIMIT 1) as current_price,
           (SELECT t2.price_enriched_at
            FROM trades t2
            JOIN issuers i2 ON t2.issuer_id = i2.issuer_id
            WHERE i2.issuer_ticker = p.issuer_ticker
              AND t2.current_price IS NOT NULL
            ORDER BY t2.price_enriched_at DESC
            LIMIT 1) as price_date,
           p.last_updated
         FROM positions p
         ```
       - Dynamic WHERE clauses:
         - Default: `WHERE p.shares_held > 0.0001` (unless include_closed=true)
         - politician_id: `AND p.politician_id = ?N`
         - ticker: `AND p.issuer_ticker = ?N`
         - party: `JOIN politicians pol ON p.politician_id = pol.politician_id` + `AND pol.party = ?N`
         - state: (same JOIN) + `AND UPPER(pol.state_id) = UPPER(?N)`
       - Compute unrealized P&L in row mapping:
         - unrealized_pnl = current_price.map(|price| (price - cost_basis) * shares_held)
         - unrealized_pnl_pct = current_price.map(|price| if cost_basis > 0.0001 { ((price - cost_basis) / cost_basis) * 100.0 } else { 0.0 })
         - current_value = current_price.map(|price| price * shares_held)
       - ORDER BY p.shares_held * p.cost_basis DESC (largest positions first)

    3. **count_option_trades(&self, politician_id: Option<&str>) -> Result<i64, DbError>**
       - Simple count query:
         ```sql
         SELECT COUNT(*)
         FROM trades t
         JOIN assets a ON t.asset_id = a.asset_id
         WHERE a.asset_type != 'stock'
           AND a.asset_type != 'unknown'
         ```
       - If politician_id is Some, add `AND t.politician_id = ?1`
       - Returns count as i64

    Update lib.rs: add PortfolioPosition and PortfolioFilter to the `pub use db::{...}` block.

    Write tests:

    Test 1: test_get_portfolio_empty -- empty positions table returns empty vec
    Test 2: test_get_portfolio_with_unrealized_pnl -- insert position row + trade with current_price, verify unrealized_pnl calculated correctly
    Test 3: test_get_portfolio_filters_closed -- insert position with shares_held=0, verify excluded by default, included with include_closed=true
    Test 4: test_get_portfolio_filter_by_politician -- insert two politician positions, filter by one, verify only that one returned
    Test 5: test_count_option_trades -- insert stock and option asset trades, verify count returns only non-stock non-unknown count
    Test 6: test_get_portfolio_missing_current_price -- position exists but no trade has current_price, verify unrealized_pnl is None

    For test setup involving positions table: directly INSERT into positions (politician_id, issuer_ticker, shares_held, cost_basis, realized_pnl, last_updated). For current_price tests, also insert trades with current_price and price_enriched_at set, linked via issuers.issuer_ticker.
  </action>
  <verify>
    `cargo test -p capitoltraders_lib get_portfolio` passes
    `cargo test -p capitoltraders_lib count_option_trades` passes
    `cargo test --workspace` passes (all existing + new tests)
    `cargo clippy --workspace` has no warnings
  </verify>
  <done>
    get_portfolio returns PortfolioPosition rows with computed unrealized P&L (dollar and percent) and current_value. Closed positions filtered by default. Dynamic filtering by politician_id, ticker, party, state works. count_option_trades returns count of non-stock non-unknown asset type trades. PortfolioPosition and PortfolioFilter exported from lib.rs. All 6 tests pass. Full workspace test suite green.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` -- all tests pass (existing + ~12 new)
- `cargo clippy --workspace` -- no warnings
- Verify portfolio types are exported: `grep 'PortfolioPosition' capitoltraders_lib/src/lib.rs`
- Verify query_trades_for_portfolio filters options: test inserts both stock and option trades, only stock returned
- Verify upsert_positions round-trips data: write positions, read back from positions table, values match
- Verify get_portfolio computes unrealized P&L: position with cost_basis=50, current_price=75, shares_held=100 -> unrealized_pnl=2500
</verification>

<success_criteria>
- query_trades_for_portfolio returns Vec<TradeFIFO> filtered to stock-only with non-null prices, ordered chronologically
- upsert_positions writes all positions (open and closed) with ON CONFLICT update
- get_portfolio returns PortfolioPosition with computed unrealized_pnl, unrealized_pnl_pct, current_value
- get_portfolio filters work: politician_id, ticker, party, state, include_closed
- count_option_trades returns count of non-stock trades
- PortfolioPosition and PortfolioFilter exported from lib.rs
- No clippy warnings, full test suite green
</success_criteria>

<output>
After completion, create `.planning/phases/05-portfolio-calculator-fifo/05-02-SUMMARY.md`
</output>
