---
phase: 03-trade-sync-and-output
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - capitoltraders_lib/src/db.rs
  - capitoltraders_lib/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "query_trades() returns enriched trade data with joined committees and labels from the database"
    - "query_trades() supports basic filters: party, state, tx_type, name search, date range"
    - "Trades without committees or labels return empty vecs, not NULL or panic"
    - "DbTradeRow contains asset_type, committees, and labels fields"
  artifacts:
    - path: "capitoltraders_lib/src/db.rs"
      provides: "DbTradeRow struct and query_trades() method"
      contains: "pub struct DbTradeRow"
    - path: "capitoltraders_lib/src/lib.rs"
      provides: "Re-export of DbTradeRow"
      contains: "DbTradeRow"
  key_links:
    - from: "capitoltraders_lib/src/db.rs query_trades()"
      to: "trades, politicians, issuers, assets, trade_committees, trade_labels tables"
      via: "SQL JOINs with GROUP_CONCAT"
      pattern: "LEFT JOIN trade_committees|LEFT JOIN trade_labels|GROUP_CONCAT"
---

<objective>
Add a database read path for enriched trades with JOINed committees, labels, and asset_type, supporting basic filters for downstream CLI output.

Purpose: The sync pipeline writes enriched data into SQLite but there is no way to read it back out with the joined committee/label data. This plan creates the query method that Plan 03-03 will use to power the `trades --db` output path.

Output: `DbTradeRow` struct and `query_trades()` method in db.rs, re-exported from lib.rs.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-trade-sync-and-output/03-RESEARCH.md
@capitoltraders_lib/src/db.rs
@capitoltraders_lib/src/lib.rs
@schema/sqlite.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DbTradeRow struct and query_trades method</name>
  <files>capitoltraders_lib/src/db.rs, capitoltraders_lib/src/lib.rs</files>
  <action>
1. In db.rs, add a `DbTradeRow` struct (after the existing `IssuerStatsRow` struct, near the bottom of the file, before the tests module). Derive `Debug, Clone, Serialize` (add serde::Serialize to imports at top). Fields:

```rust
#[derive(Debug, Clone, Serialize)]
pub struct DbTradeRow {
    pub tx_id: i64,
    pub pub_date: String,
    pub tx_date: String,
    pub tx_type: String,
    pub value: i64,
    pub price: Option<f64>,
    pub size: Option<i64>,
    pub filing_url: String,
    pub reporting_gap: i64,
    pub enriched_at: Option<String>,
    pub politician_name: String,
    pub party: String,
    pub state: String,
    pub chamber: String,
    pub issuer_name: String,
    pub issuer_ticker: String,
    pub asset_type: String,
    pub committees: Vec<String>,
    pub labels: Vec<String>,
}
```

2. Add a `DbTradeFilter` struct for query parameters:

```rust
#[derive(Debug, Default)]
pub struct DbTradeFilter {
    pub party: Option<String>,
    pub state: Option<String>,
    pub tx_type: Option<String>,
    pub name: Option<String>,
    pub issuer: Option<String>,
    pub since: Option<String>,
    pub until: Option<String>,
    pub limit: Option<i64>,
}
```

3. Add `query_trades(&self, filter: &DbTradeFilter) -> Result<Vec<DbTradeRow>, DbError>` method to the `impl Db` block. Implementation:

   Base SQL query (use a String builder approach):
   ```sql
   SELECT t.tx_id, t.pub_date, t.tx_date, t.tx_type, t.value,
          t.price, t.size, t.filing_url, t.reporting_gap, t.enriched_at,
          p.first_name || ' ' || p.last_name AS politician_name,
          p.party, p.state_id, p.chamber,
          i.issuer_name, i.issuer_ticker,
          a.asset_type,
          COALESCE(GROUP_CONCAT(DISTINCT tc.committee), '') AS committees,
          COALESCE(GROUP_CONCAT(DISTINCT tl.label), '') AS labels
   FROM trades t
   JOIN politicians p ON t.politician_id = p.politician_id
   JOIN issuers i ON t.issuer_id = i.issuer_id
   JOIN assets a ON t.asset_id = a.asset_id
   LEFT JOIN trade_committees tc ON t.tx_id = tc.tx_id
   LEFT JOIN trade_labels tl ON t.tx_id = tl.tx_id
   ```

   Build WHERE clauses dynamically. Use a `Vec<Box<dyn rusqlite::types::ToSql>>` for parameters. For each filter:
   - party: `AND p.party = ?N` (exact match, case-sensitive -- the DB stores "Democrat", "Republican", etc.)
   - state: `AND UPPER(p.state_id) = UPPER(?N)`
   - tx_type: `AND t.tx_type = ?N`
   - name: `AND (p.first_name || ' ' || p.last_name) LIKE ?N` with `%needle%` wildcard
   - issuer: `AND (i.issuer_name LIKE ?N OR i.issuer_ticker LIKE ?N)` with `%needle%`
   - since: `AND t.pub_date >= ?N`
   - until: `AND t.pub_date <= ?N`

   Append: `GROUP BY t.tx_id ORDER BY t.pub_date DESC`

   If filter.limit is Some(n): append `LIMIT {n}` (safe to interpolate directly since it is i64).

   Map rows. Use positional indices (0-18). Handle the committees/labels split:
   ```rust
   let committees_str: String = row.get(17)?;
   let labels_str: String = row.get(18)?;
   // ...
   committees: if committees_str.is_empty() { Vec::new() } else {
       committees_str.split(',').map(|s| s.to_string()).collect()
   },
   labels: if labels_str.is_empty() { Vec::new() } else {
       labels_str.split(',').map(|s| s.to_string()).collect()
   },
   ```

   Handle Option fields: `price` is `row.get::<_, Option<f64>>(5)?`, `size` is `row.get::<_, Option<i64>>(6)?`, `enriched_at` is `row.get::<_, Option<String>>(9)?`, `issuer_ticker` is `row.get::<_, Option<String>>(15)?.unwrap_or_default()`.

4. In lib.rs, add `DbTradeRow` and `DbTradeFilter` to the re-export line:
   `pub use db::{Db, DbError, DbTradeFilter, DbTradeRow, IssuerStatsRow, PoliticianStatsRow};`
  </action>
  <verify>
Run `cargo check --workspace` to verify compilation. Run `cargo clippy --workspace` for lint.
  </verify>
  <done>
DbTradeRow and DbTradeFilter structs exist in db.rs. query_trades() method compiles and handles JOINs with GROUP_CONCAT. Both types are re-exported from lib.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for query_trades with filters</name>
  <files>capitoltraders_lib/src/db.rs</files>
  <action>
Add tests to the existing `#[cfg(test)] mod tests` block in db.rs. These tests verify the query_trades method with various filters.

Test setup helper: Create a helper function `setup_test_db_with_trades() -> Db` that:
- Opens an in-memory Db, calls init()
- Inserts 3 trades using upsert_scraped_trades with distinct:
  - Trade 100: politician "John Smith" (Democrat, CA, senate), issuer "Apple Inc" (AAPL), tx_type "buy", pub_date "2024-01-15T00:00:00Z", value 50000
  - Trade 200: politician "Jane Doe" (Republican, TX, house), issuer "Microsoft Corp" (MSFT), tx_type "sell", pub_date "2024-02-20T00:00:00Z", value 100000
  - Trade 300: politician "John Smith" (Democrat, CA, senate), issuer "Tesla Inc" (TSLA), tx_type "buy", pub_date "2024-03-10T00:00:00Z", value 25000
- Enriches trade 100 with update_trade_detail providing asset_type="stock", committees=["ssfi"], labels=["faang"]
- Returns the Db

Tests to write:

1. `test_query_trades_no_filter` -- call with DbTradeFilter::default(), assert 3 rows, check ordering is pub_date DESC (trade 300 first)

2. `test_query_trades_filter_party` -- filter by party "Democrat", assert 2 rows (trades 100 and 300)

3. `test_query_trades_filter_state` -- filter by state "TX", assert 1 row (trade 200)

4. `test_query_trades_filter_tx_type` -- filter by tx_type "sell", assert 1 row (trade 200)

5. `test_query_trades_filter_name` -- filter by name "john", assert 2 rows (case-insensitive LIKE)

6. `test_query_trades_filter_issuer` -- filter by issuer "AAPL", assert 1 row (ticker match)

7. `test_query_trades_filter_date_range` -- filter since "2024-02-01" until "2024-02-28", assert 1 row (trade 200)

8. `test_query_trades_limit` -- filter with limit=2, assert 2 rows

9. `test_query_trades_enriched_fields` -- query trade 100 (the enriched one), verify asset_type="stock", committees=["ssfi"], labels=["faang"]. For unenriched trades (200, 300), verify asset_type="unknown", committees=[], labels=[].

10. `test_query_trades_combined_filters` -- filter party="Democrat" AND tx_type="buy", assert 2 rows

Note: When building the ScrapedTrade structs for setup, you need all required fields. Look at the existing test helpers in db.rs for the field structure. The politician, issuer, and asset data are embedded in the ScrapedTrade and extracted during upsert. Make sure politician_id, issuer_id, and other FK fields are consistent.
  </action>
  <verify>
Run `cargo test --workspace query_trades` to verify all 10 tests pass. Run `cargo test --workspace` to confirm no regressions.
  </verify>
  <done>
10 tests cover: no filter, party, state, tx_type, name search, issuer search, date range, limit, enriched field verification, and combined filters. All pass. Total workspace tests increased.
  </done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles without errors
- `cargo test --workspace` all tests pass
- `cargo clippy --workspace` no new warnings
- query_trades with no filters returns all trades ordered by pub_date DESC
- query_trades with each individual filter returns correct subset
- Enriched trades show asset_type, committees, labels from join tables
- Unenriched trades show asset_type="unknown", empty committees, empty labels
</verification>

<success_criteria>
- DbTradeRow struct exists with all 19 fields including asset_type, committees, labels
- DbTradeFilter supports party, state, tx_type, name, issuer, since, until, limit
- query_trades uses JOINs + GROUP_CONCAT to merge data from 6 tables
- COALESCE handles NULL GROUP_CONCAT results (no panics on empty join tables)
- 10 tests verify filter combinations and enriched field correctness
</success_criteria>

<output>
After completion, create `.planning/phases/03-trade-sync-and-output/03-02-SUMMARY.md`
</output>
