---
phase: 03-trade-sync-and-output
plan: 03
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - capitoltraders_cli/src/commands/trades.rs
  - capitoltraders_cli/src/output.rs
  - capitoltraders_cli/src/main.rs
autonomous: true

must_haves:
  truths:
    - "capitoltraders trades --db shows trades from SQLite with asset_type, committees, and labels columns"
    - "trades --db --output json serializes DbTradeRow with committees as JSON array"
    - "trades --db --output csv produces CSV with Asset, Committees, Labels columns"
    - "trades --db --output md produces markdown table with enriched columns"
    - "trades --db --output xml produces XML with enriched elements"
    - "trades --db supports --party, --state, --tx-type, --name, --issuer, --since, --until filters"
    - "trades --db --output table shows enriched columns in ASCII table"
  artifacts:
    - path: "capitoltraders_cli/src/output.rs"
      provides: "DbTradeOutputRow struct and print_db_trades_* functions for all 5 formats"
      contains: "pub fn print_db_trades_table"
    - path: "capitoltraders_cli/src/commands/trades.rs"
      provides: "--db flag and DB query code path"
      contains: "fn run_db"
    - path: "capitoltraders_cli/src/main.rs"
      provides: "Db import and --db flag wiring in trades command dispatch"
      contains: "run_db"
  key_links:
    - from: "capitoltraders_cli/src/commands/trades.rs run_db()"
      to: "capitoltraders_lib/src/db.rs query_trades()"
      via: "db.query_trades(&filter)"
      pattern: "query_trades"
    - from: "capitoltraders_cli/src/commands/trades.rs run_db()"
      to: "capitoltraders_cli/src/output.rs"
      via: "print_db_trades_table/json/csv/markdown/xml"
      pattern: "print_db_trades"
---

<objective>
Extend the CLI trades command with a --db flag that reads enriched trades from SQLite and displays asset_type, committees, and labels in all output formats.

Purpose: Users who have run `sync --enrich` can view enriched data instantly from the local database, with committees and labels visible in table, JSON, CSV, markdown, and XML output. This completes the OUT-01 requirement.

Output: `trades --db` command path with full output format support for enriched fields.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-trade-sync-and-output/03-RESEARCH.md
@.planning/phases/03-trade-sync-and-output/03-02-SUMMARY.md
@capitoltraders_cli/src/commands/trades.rs
@capitoltraders_cli/src/output.rs
@capitoltraders_cli/src/xml_output.rs
@capitoltraders_cli/src/main.rs
@capitoltraders_lib/src/db.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --db flag and DB query code path to trades command</name>
  <files>capitoltraders_cli/src/commands/trades.rs, capitoltraders_cli/src/main.rs</files>
  <action>
1. In trades.rs, add a `--db` flag to `TradesArgs`:
   ```rust
   /// Read trades from local SQLite database (requires prior sync)
   #[arg(long)]
   pub db: Option<PathBuf>,
   ```
   Add `use std::path::PathBuf;` to imports.

2. In trades.rs, add a new async function `run_db` that handles the database path:
   ```rust
   pub async fn run_db(args: &TradesArgs, db_path: &std::path::Path, format: &OutputFormat) -> Result<()>
   ```
   This function:
   - Opens the database: `let db = capitoltraders_lib::Db::open(db_path)?;`
   - Builds a `DbTradeFilter` from the TradesArgs fields that are supported on the DB path:
     - party: validate each comma-separated value, join as single string for filter (note: DB stores "Democrat"/"Republican", so map the validated party value to the DB format. The validation returns lowercase "democrat"/"republican". Capitalize the first letter for DB match. Or better: use case-insensitive SQL -- but the current query_trades uses exact match. Either adjust query_trades to do case-insensitive party match, or capitalize here. Capitalizing here is simpler: `val.chars().next().map(|c| c.to_uppercase().to_string()).unwrap_or_default() + &val[1..]`)

     Actually, looking more carefully: the DB party field stores whatever the API returns. The API Trade type has a `party` field that is a string. Looking at the politician fixture data and ScrapedTrade, the party is stored as-is from the scrape. For scraped data, `trade.politician.party` is the raw string from HTML (e.g., "Democrat", "Republican"). So the filter should match these capitalized forms.

     Simplest approach: If the user passes --party democrat, validate it, then capitalize first letter for the DB filter. Use a helper: `fn capitalize_party(s: &str) -> String` that maps "democrat" -> "Democrat", "republican" -> "Republican", "other" -> "Other".

   - state: validate, pass as uppercase string
   - tx_type: validate, pass as string (DB stores API format: "buy", "sell", etc.)
   - name: validate search string, pass to filter
   - issuer: validate search string, pass to filter
   - since/until: validate dates, pass as "YYYY-MM-DD" strings. Handle --days by converting to since date (today - days).
   - limit: use page_size from args (default 12)

   - Bail with a helpful message for filters not supported on DB path: --committee, --trade-size, --market-cap, --asset-type, --label, --sector, --gender, --chamber, --politician-id, --issuer-state, --country, --issuer-id, --politician. Check each; if any is Some, bail with "--{flag} is not yet supported with --db. Supported filters: --party, --state, --tx-type, --name, --issuer, --since, --until, --days"

   - Call `db.query_trades(&filter)?`
   - Print result count to stderr: "{count} trades from database"
   - Dispatch to output functions based on format (these will be created in Task 2):
     ```rust
     match format {
         OutputFormat::Table => output::print_db_trades_table(&rows),
         OutputFormat::Json => output::print_json(&rows),
         OutputFormat::Csv => output::print_db_trades_csv(&rows)?,
         OutputFormat::Markdown => output::print_db_trades_markdown(&rows),
         OutputFormat::Xml => output::print_db_trades_xml(&rows),
     }
     ```

   Note: For JSON output, DbTradeRow already derives Serialize, so print_json (which is generic over Serialize) works directly. For XML, we need a new function since the XML bridge uses serde_json::Value.

3. In main.rs, modify the `Commands::Trades` match arm to check for the --db flag:
   ```rust
   Commands::Trades(args) => {
       if let Some(ref db_path) = args.db {
           commands::trades::run_db(args.as_ref(), db_path, &format).await?
       } else {
           commands::trades::run(args.as_ref(), &scraper, &format).await?
       }
   }
   ```
   This way, when --db is provided, we skip creating the ScrapeClient entirely and go straight to the DB path. Add `use capitoltraders_lib::Db;` if needed (though the Db is opened inside run_db, so main.rs may not need it directly).

   Actually, looking at main.rs more carefully: the scraper is created unconditionally before the match. To avoid creating a scraper when --db is used, restructure slightly:

   Option A (simpler): Keep creating the scraper regardless. It is cheap (just creates an HTTP client). The run_db function ignores it.

   Option B: Move scraper creation inside the match arms that need it. This is cleaner but requires more changes to main.rs.

   Use Option A for simplicity. The match arm just needs to check args.db and dispatch accordingly. No changes to scraper creation.
  </action>
  <verify>
Run `cargo check --workspace` to verify compilation. The output functions called in run_db do not exist yet -- Task 2 will create them. For this task to compile, either: (a) create stub output functions that compile but are empty, or (b) implement Task 1 and Task 2 together. Prefer (b): implement both tasks in sequence within this plan. If compiling after Task 1 alone, temporarily comment out the output dispatch and just return Ok(()).
  </verify>
  <done>
trades.rs has --db flag on TradesArgs, run_db() function that opens DB, builds filter from args, calls query_trades, dispatches to output. main.rs routes to run_db when --db is present.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add DB trade output functions for all formats</name>
  <files>capitoltraders_cli/src/output.rs, capitoltraders_cli/src/xml_output.rs</files>
  <action>
1. In output.rs, add `use capitoltraders_lib::DbTradeRow;` to imports.

2. Add a `DbTradeOutputRow` struct for tabular display (table, CSV, markdown). This is separate from the existing `TradeRow` because it includes enriched fields:

```rust
#[derive(Tabled, Serialize)]
struct DbTradeOutputRow {
    #[tabled(rename = "Date")]
    #[serde(rename = "Date")]
    tx_date: String,
    #[tabled(rename = "Politician")]
    #[serde(rename = "Politician")]
    politician: String,
    #[tabled(rename = "Party")]
    #[serde(rename = "Party")]
    party: String,
    #[tabled(rename = "Issuer")]
    #[serde(rename = "Issuer")]
    issuer: String,
    #[tabled(rename = "Ticker")]
    #[serde(rename = "Ticker")]
    ticker: String,
    #[tabled(rename = "Type")]
    #[serde(rename = "Type")]
    tx_type: String,
    #[tabled(rename = "Asset")]
    #[serde(rename = "Asset")]
    asset_type: String,
    #[tabled(rename = "Value")]
    #[serde(rename = "Value")]
    value: String,
    #[tabled(rename = "Committees")]
    #[serde(rename = "Committees")]
    committees: String,
    #[tabled(rename = "Labels")]
    #[serde(rename = "Labels")]
    labels: String,
}
```

3. Add a row builder function:

```rust
fn build_db_trade_rows(trades: &[DbTradeRow]) -> Vec<DbTradeOutputRow> {
    trades.iter().map(|t| DbTradeOutputRow {
        tx_date: t.tx_date.clone(),
        politician: t.politician_name.clone(),
        party: t.party.clone(),
        issuer: t.issuer_name.clone(),
        ticker: t.issuer_ticker.clone(),
        tx_type: t.tx_type.clone(),
        asset_type: t.asset_type.clone(),
        value: format_value(t.value),
        committees: t.committees.join(", "),
        labels: t.labels.join(", "),
    }).collect()
}
```

4. Add output functions:

```rust
pub fn print_db_trades_table(trades: &[DbTradeRow]) {
    println!("{}", Table::new(build_db_trade_rows(trades)));
}

pub fn print_db_trades_markdown(trades: &[DbTradeRow]) {
    let mut table = Table::new(build_db_trade_rows(trades));
    table.with(Style::markdown());
    println!("{}", table);
}

pub fn print_db_trades_csv(trades: &[DbTradeRow]) -> Result<()> {
    let mut wtr = csv::Writer::from_writer(std::io::stdout());
    for mut row in build_db_trade_rows(trades) {
        row.politician = sanitize_csv_field(&row.politician);
        row.issuer = sanitize_csv_field(&row.issuer);
        row.ticker = sanitize_csv_field(&row.ticker);
        row.committees = sanitize_csv_field(&row.committees);
        row.labels = sanitize_csv_field(&row.labels);
        wtr.serialize(row)?;
    }
    wtr.flush()?;
    Ok(())
}
```

5. For XML output, add a function in xml_output.rs:

```rust
pub fn db_trades_to_xml(trades: &[DbTradeRow]) -> String {
    // Use the same JSON-to-XML bridge pattern as trades_to_xml
    // Serialize DbTradeRow vec to serde_json::Value, then pass through the XML writer
    let value = serde_json::to_value(trades).unwrap_or(serde_json::Value::Array(vec![]));
    // Wrap in a root object for consistent XML structure
    to_xml("trades", "trade", &value)
}
```

Actually, looking at the existing xml_output.rs more carefully -- it uses `trades_to_xml(trades: &[Trade])` which serializes the Trade type. For DbTradeRow, since it already derives Serialize, we can use the same bridge. Add `use capitoltraders_lib::DbTradeRow;` to xml_output.rs imports, then add the function. The existing `to_xml` helper (or the pattern used by `trades_to_xml`) should work.

Check the existing `trades_to_xml` implementation to understand the pattern and replicate it for `db_trades_to_xml`.

Then in output.rs, add:
```rust
pub fn print_db_trades_xml(trades: &[DbTradeRow]) {
    println!("{}", xml_output::db_trades_to_xml(trades));
}
```

6. For JSON output: `print_json(&rows)` already works because DbTradeRow derives Serialize. No new function needed. The JSON output will include all fields including the Vec<String> for committees and labels as JSON arrays.

7. Add unit tests in output_tests.rs:
   - `test_build_db_trade_rows_mapping` -- create a DbTradeRow, call build_db_trade_rows, verify fields are mapped correctly, committees joined with ", "
   - `test_build_db_trade_rows_empty_committees` -- verify empty committees/labels produce empty string, not "[]"
   - `test_db_trade_row_json_serialization` -- serialize a DbTradeRow to JSON, verify committees is a JSON array, verify asset_type is present
   - `test_db_trade_csv_headers` -- build rows, serialize one to CSV, verify "Asset", "Committees", "Labels" headers appear

Note: To make build_db_trade_rows accessible from tests, either make it pub(crate) or test it indirectly through the print functions.
  </action>
  <verify>
Run `cargo check --workspace` to verify full compilation with all output functions wired up. Run `cargo test --workspace db_trade` to run the new output tests. Run `cargo test --workspace` for full regression. Run `cargo clippy --workspace` for lint. Verify `capitoltraders trades --help` shows the --db flag.
  </verify>
  <done>
trades --db works with all 5 output formats. Table/markdown show Asset, Committees, Labels columns. JSON serializes committees and labels as arrays. CSV includes enriched columns with formula sanitization. XML uses the JSON-to-XML bridge for DbTradeRow. 4 new output tests pass.
  </done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles without errors
- `cargo test --workspace` all tests pass
- `cargo clippy --workspace` no new warnings
- `capitoltraders trades --help` shows --db flag
- `capitoltraders trades --db capitoltraders.db` (after a sync) shows enriched columns in table format
- `capitoltraders trades --db capitoltraders.db --output json` produces JSON with committees array
- `capitoltraders trades --db capitoltraders.db --party democrat` filters correctly
- Unsupported filters on --db path produce helpful error message
</verification>

<success_criteria>
- trades --db reads from SQLite, not live scraping
- All 5 output formats (table, json, csv, md, xml) display asset_type, committees, labels
- Supported filters (party, state, tx_type, name, issuer, since, until, days) work on DB path
- Unsupported filters bail with a clear message listing supported alternatives
- Empty committees/labels display as empty string in table/csv/md, empty array in JSON/XML
- CSV output sanitizes formula-injection-prone fields
- 4+ new output tests verify the enriched row mapping
</success_criteria>

<output>
After completion, create `.planning/phases/03-trade-sync-and-output/03-03-SUMMARY.md`
</output>
