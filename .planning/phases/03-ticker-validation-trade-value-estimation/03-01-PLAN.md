---
phase: 03-ticker-validation-trade-value-estimation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - capitoltraders_lib/src/pricing.rs
  - capitoltraders_lib/src/lib.rs
  - capitoltraders_lib/src/db.rs
autonomous: true

must_haves:
  truths:
    - "Dollar range bounds are extracted from size_range_low/size_range_high columns, falling back to value column when range is NULL"
    - "Estimated shares = midpoint / trade_date_price, with estimated_value = estimated_shares * trade_date_price"
    - "Estimation is skipped (returns None) when price is zero, negative, or range is missing"
    - "Validation check confirms estimated_value falls within original range bounds"
    - "DB can count and fetch trades needing price enrichment (has ticker + date, no price_enriched_at)"
    - "DB can atomically update trade_date_price, estimated_shares, estimated_value, and price_enriched_at"
    - "Trades with NULL issuer_ticker or NULL tx_date are excluded from enrichment queue"
  artifacts:
    - path: "capitoltraders_lib/src/pricing.rs"
      provides: "Dollar range parsing and share estimation logic"
      exports: ["parse_trade_range", "estimate_shares", "TradeRange"]
    - path: "capitoltraders_lib/src/lib.rs"
      provides: "Module registration for pricing"
      contains: "pub mod pricing"
    - path: "capitoltraders_lib/src/db.rs"
      provides: "Price enrichment DB operations"
      exports: ["count_unenriched_prices", "get_unenriched_price_trades", "update_trade_prices", "PriceEnrichmentRow"]
  key_links:
    - from: "capitoltraders_lib/src/pricing.rs"
      to: "capitoltraders_lib/src/db.rs"
      via: "PriceEnrichmentRow fields feed into estimate_shares"
      pattern: "estimate_shares.*range_low.*range_high.*price"
    - from: "capitoltraders_lib/src/db.rs"
      to: "trades table"
      via: "SQL queries joining issuers for ticker"
      pattern: "JOIN issuers.*issuer_ticker"
---

<objective>
Implement dollar range parsing, share estimation logic, and database operations for price enrichment.

Purpose: Phase 3 provides the calculation layer and data access layer that Phase 4's enrichment pipeline will orchestrate. Without this, the pipeline has no way to estimate share counts from dollar ranges or persist price data.

Output: pricing.rs module with tested estimation functions, db.rs extended with price enrichment queries/updates, all with comprehensive unit tests.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ticker-validation-trade-value-estimation/03-RESEARCH.md
@.planning/phases/01-schema-migration-data-model/01-01-SUMMARY.md
@.planning/phases/02-yahoo-finance-client-integration/02-01-SUMMARY.md
@capitoltraders_lib/src/db.rs
@capitoltraders_lib/src/yahoo.rs
@capitoltraders_lib/src/lib.rs
@schema/sqlite.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pricing module with dollar range parsing and share estimation</name>
  <files>capitoltraders_lib/src/pricing.rs, capitoltraders_lib/src/lib.rs</files>
  <action>
Create `capitoltraders_lib/src/pricing.rs` with the following:

1. **TradeRange struct:**
```rust
pub struct TradeRange {
    pub low: f64,
    pub high: f64,
}
impl TradeRange {
    pub fn midpoint(&self) -> f64 { (self.low + self.high) / 2.0 }
}
```

2. **parse_trade_range function:**
```rust
pub fn parse_trade_range(
    size_range_low: Option<i64>,
    size_range_high: Option<i64>,
    value: i64,
) -> Option<TradeRange>
```
- If both `size_range_low` and `size_range_high` are Some, use them as f64 bounds
- If either is None, fall back to the `value` field. Capitol Trades `value` is the midpoint integer of the bracket. Without bounds, we cannot estimate a meaningful range. Return None in this case -- estimation requires both bounds to validate the result against the original range.
- Important: `value` alone is NOT sufficient because we need the range bounds for validation (REQ-E4 success criterion 4). If only `value` is available, return None to skip estimation.
- Return None if low > high (invalid data) or if both are zero

3. **ShareEstimate struct:**
```rust
pub struct ShareEstimate {
    pub estimated_shares: f64,
    pub estimated_value: f64,
}
```

4. **estimate_shares function:**
```rust
pub fn estimate_shares(range: &TradeRange, trade_date_price: f64) -> Option<ShareEstimate>
```
- Return None if `trade_date_price <= 0.0` (division by zero / negative price guard)
- Calculate: `estimated_shares = range.midpoint() / trade_date_price`
- Calculate: `estimated_value = estimated_shares * trade_date_price`
- Validation: if `estimated_value < range.low` or `estimated_value > range.high`, log a warning (use eprintln for now, will be replaced with proper logging later) and return None per research recommendation (store price but NULL shares/value)
- Note: `estimated_value` should always equal the midpoint mathematically (shares = mid/price, value = shares*price = mid). The validation is a sanity check against floating-point edge cases. It should virtually never fail with correct inputs, but protects against NaN/Inf scenarios.
- Return Some(ShareEstimate) on success
- estimated_shares is stored as REAL (f64), NOT rounded to integer -- per Phase 1 decision

5. **Unit tests (aim for 10-15 tests):**
- `test_parse_range_both_bounds` -- normal case with size_range_low=15001, size_range_high=50000
- `test_parse_range_missing_low` -- low is None, should return None
- `test_parse_range_missing_high` -- high is None, should return None
- `test_parse_range_both_none` -- both None, should return None
- `test_parse_range_inverted` -- low > high, should return None
- `test_parse_range_zero_bounds` -- both zero, should return None
- `test_midpoint_calculation` -- verify (15001 + 50000) / 2.0 = 32500.5
- `test_estimate_shares_normal` -- range (15001, 50000), price 150.0, expect shares ~216.67, value ~32500.5
- `test_estimate_shares_zero_price` -- price 0.0, should return None
- `test_estimate_shares_negative_price` -- price -10.0, should return None
- `test_estimate_shares_small_range` -- range (1001, 15000), price 25.0, verify math
- `test_estimate_shares_large_range` -- range (500001, 1000000), price 3500.0, verify math
- `test_estimate_value_matches_midpoint` -- verify estimated_value == midpoint (within f64 epsilon)

Register the module in lib.rs: add `pub mod pricing;` and add `pub use pricing::{estimate_shares, parse_trade_range, ShareEstimate, TradeRange};` to the pub use exports.
  </action>
  <verify>
`cargo test -p capitoltraders_lib pricing -- --nocapture` runs all pricing tests and they pass.
`cargo clippy -p capitoltraders_lib` shows no warnings.
  </verify>
  <done>
pricing.rs exists with parse_trade_range and estimate_shares functions. All unit tests pass. Module is registered in lib.rs and exported publicly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add price enrichment DB operations and tests</name>
  <files>capitoltraders_lib/src/db.rs</files>
  <action>
Add the following to `capitoltraders_lib/src/db.rs`:

1. **PriceEnrichmentRow struct** (add near the other row structs like DbTradeRow):
```rust
#[derive(Debug)]
pub struct PriceEnrichmentRow {
    pub tx_id: i64,
    pub issuer_ticker: String,
    pub tx_date: String,
    pub size_range_low: Option<i64>,
    pub size_range_high: Option<i64>,
    pub value: i64,
}
```
Export it from lib.rs: add `PriceEnrichmentRow` to the `pub use db::{...}` line.

2. **count_unenriched_prices method** on Db:
```rust
pub fn count_unenriched_prices(&self) -> Result<i64, DbError>
```
SQL: `SELECT COUNT(*) FROM trades t JOIN issuers i ON t.issuer_id = i.issuer_id WHERE i.issuer_ticker IS NOT NULL AND t.tx_date IS NOT NULL AND t.price_enriched_at IS NULL`
- Note: ticker lives on the issuers table, not trades table. Must JOIN to check.
- Excludes trades without ticker or without tx_date (can't look up price without both).

3. **get_unenriched_price_trades method** on Db:
```rust
pub fn get_unenriched_price_trades(&self, limit: Option<i64>) -> Result<Vec<PriceEnrichmentRow>, DbError>
```
SQL: `SELECT t.tx_id, i.issuer_ticker, t.tx_date, t.size_range_low, t.size_range_high, t.value FROM trades t JOIN issuers i ON t.issuer_id = i.issuer_id WHERE i.issuer_ticker IS NOT NULL AND t.tx_date IS NOT NULL AND t.price_enriched_at IS NULL ORDER BY t.tx_id`
- Add `LIMIT ?` clause only when limit is Some
- Follow existing pattern from `get_unenriched_trade_ids` for the limit handling
- Use format! for the optional LIMIT clause, same as the existing pattern

4. **update_trade_prices method** on Db:
```rust
pub fn update_trade_prices(
    &self,
    tx_id: i64,
    trade_date_price: Option<f64>,
    estimated_shares: Option<f64>,
    estimated_value: Option<f64>,
) -> Result<(), DbError>
```
SQL: `UPDATE trades SET trade_date_price = ?1, estimated_shares = ?2, estimated_value = ?3, price_enriched_at = datetime('now') WHERE tx_id = ?4`
- Always sets price_enriched_at to mark the trade as processed (even if price is None / invalid ticker)
- This prevents re-processing on subsequent runs (REQ-E3: "Resume after failure: skip already-enriched trades on re-run")
- trade_date_price can be None (invalid ticker), in which case estimated_shares and estimated_value should also be None

5. **Unit tests (8-10 tests)** -- add in the `#[cfg(test)] mod tests` block:

For test setup: the existing `make_test_scraped_trade` helper creates trades but does NOT set issuer_ticker. Need to manually UPDATE the issuer to set ticker for these tests. Check how open_test_db() works and what data helpers exist.

- `test_count_unenriched_prices_empty` -- no trades, count is 0
- `test_count_unenriched_prices_excludes_no_ticker` -- insert trade, issuer has NULL ticker, count is 0
- `test_count_unenriched_prices_with_ticker` -- insert trade, UPDATE issuer to have ticker, count is 1
- `test_count_unenriched_prices_excludes_already_enriched` -- insert trade with ticker, call update_trade_prices, count is 0
- `test_get_unenriched_price_trades_basic` -- insert 2 trades with tickers, verify returns both with correct fields
- `test_get_unenriched_price_trades_with_limit` -- insert 3 trades, limit=2, verify returns 2
- `test_get_unenriched_price_trades_has_range_fields` -- insert trade, enrich with ScrapedTradeDetail that sets size_range_low/high, verify PriceEnrichmentRow has the range values
- `test_update_trade_prices_stores_values` -- call update_trade_prices with price+shares+value, query back via raw SQL, verify all fields set including price_enriched_at
- `test_update_trade_prices_stores_none` -- call update_trade_prices with all None (invalid ticker), verify price_enriched_at is still set (marks as processed)
- `test_update_trade_prices_skips_on_rerun` -- call update_trade_prices, then count_unenriched_prices should return 0

For test helpers: use `open_test_db()` + `make_test_scraped_trade()` for base data. After inserting trades, UPDATE issuers SET issuer_ticker = 'AAPL' WHERE issuer_id = X to set tickers. For range data, use `update_trade_detail()` with a ScrapedTradeDetail that has size_range_low/high.
  </action>
  <verify>
`cargo test -p capitoltraders_lib "unenriched_price\|update_trade_price" -- --nocapture` runs all new tests and they pass.
`cargo test --workspace` passes all tests (existing + new).
`cargo clippy --workspace` shows no warnings.
  </verify>
  <done>
PriceEnrichmentRow struct exists with tx_id, issuer_ticker, tx_date, size_range_low, size_range_high, value fields. count_unenriched_prices, get_unenriched_price_trades, and update_trade_prices methods work correctly. All tests pass including: trades without tickers are excluded, already-enriched trades are excluded, limit parameter works, range fields are populated from enrichment, update stores all values including price_enriched_at, and None values mark trade as processed.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass (existing + new pricing + new DB tests)
2. `cargo clippy --workspace` -- no warnings
3. New pricing module is registered in lib.rs and exports are accessible
4. PriceEnrichmentRow is exported from lib.rs
5. count_unenriched_prices correctly JOINs issuers to check ticker availability
6. update_trade_prices always sets price_enriched_at (resumability)
</verification>

<success_criteria>
- pricing.rs module exists with parse_trade_range and estimate_shares functions
- Both functions handle edge cases (None bounds, zero/negative price, inverted ranges)
- DB operations correctly identify trades needing price enrichment (has ticker + date, not yet enriched)
- DB update atomically writes price, shares, value, and enrichment timestamp
- All new tests pass alongside existing 309 tests
- No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/03-ticker-validation-trade-value-estimation/03-01-SUMMARY.md`
</output>
