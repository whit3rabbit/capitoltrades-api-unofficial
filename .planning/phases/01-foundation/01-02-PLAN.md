---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - capitoltraders_lib/src/db.rs
autonomous: true

must_haves:
  truths:
    - "Running an incremental sync after a full enrichment run preserves all enriched field values"
    - "Sentinel values (filing_id=0, filing_url='', asset_type='unknown', has_capital_gains=0) do not overwrite previously enriched non-sentinel values"
    - "COALESCE-protected nullable columns (price, size, size_range_high, size_range_low) preserve existing non-NULL values when incoming is NULL"
    - "enriched_at is never clobbered by listing-page upserts"
    - "A Db query can return the list of trade/politician/issuer IDs that need enrichment"
  artifacts:
    - path: "capitoltraders_lib/src/db.rs"
      provides: "Fixed upsert_trades with sentinel CASE expressions and COALESCE for nullable columns"
      contains: "CASE"
    - path: "capitoltraders_lib/src/db.rs"
      provides: "Fixed upsert_scraped_trades with sentinel CASE expressions and COALESCE for nullable columns"
      contains: "WHEN excluded.filing_id"
    - path: "capitoltraders_lib/src/db.rs"
      provides: "Fixed asset upsert with asset_type sentinel protection in both upsert functions"
      contains: "WHEN excluded.asset_type"
    - path: "capitoltraders_lib/src/db.rs"
      provides: "enriched_at preservation in all upsert ON CONFLICT clauses"
      contains: "enriched_at = trades.enriched_at"
    - path: "capitoltraders_lib/src/db.rs"
      provides: "get_unenriched_trade_ids, get_unenriched_politician_ids, get_unenriched_issuer_ids methods"
      exports: ["get_unenriched_trade_ids", "get_unenriched_politician_ids", "get_unenriched_issuer_ids"]
  key_links:
    - from: "upsert_trades ON CONFLICT"
      to: "enriched_at column"
      via: "enriched_at = trades.enriched_at"
      pattern: "enriched_at = trades\\.enriched_at"
    - from: "upsert_scraped_trades ON CONFLICT"
      to: "enriched_at column"
      via: "enriched_at = trades.enriched_at"
      pattern: "enriched_at = trades\\.enriched_at"
    - from: "upsert_politicians ON CONFLICT"
      to: "enriched_at column"
      via: "enriched_at = politicians.enriched_at"
      pattern: "enriched_at = politicians\\.enriched_at"
    - from: "upsert_issuers ON CONFLICT"
      to: "enriched_at column"
      via: "enriched_at = issuers.enriched_at"
      pattern: "enriched_at = issuers\\.enriched_at"
---

<objective>
Fix upsert sentinel protection in all trade/asset upsert functions and add enrichment query methods.

Purpose: FOUND-01 (data corruption fix) and FOUND-03 (enrichment work queue). This is the critical correctness fix that prevents re-syncs from overwriting enriched data with default/sentinel values.
Output: Corrected SQL in 4 upsert functions, enriched_at preservation in all 4 upsert functions, 3 new query methods, comprehensive tests
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@capitoltraders_lib/src/db.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1a: Fix sentinel protection and enriched_at in trade upsert functions</name>
  <files>capitoltraders_lib/src/db.rs</files>
  <action>
Fix the ON CONFLICT DO UPDATE clauses in upsert_trades and upsert_scraped_trades. Reference the column-by-column fix map from the research document. These two functions handle the trade-path upserts where sentinel values are the primary corruption risk.

**A. upsert_trades (API path)**

1. Asset upsert (the `stmt_asset` prepared statement): In the ON CONFLICT clause, change `asset_type = excluded.asset_type` to:
   ```sql
   asset_type = CASE
     WHEN excluded.asset_type != 'unknown' THEN excluded.asset_type
     ELSE assets.asset_type
   END
   ```

2. Issuer upsert (the `stmt_issuer` prepared statement): The ON CONFLICT SET clause currently ends with `country = COALESCE(excluded.country, issuers.country)`. Add a comma after that line and a new line:
   ```sql
               country = COALESCE(excluded.country, issuers.country),
               enriched_at = issuers.enriched_at
   ```

3. Politician upsert (the `stmt_politician` prepared statement): The ON CONFLICT SET clause currently ends with `chamber = excluded.chamber`. Add a comma after that line and a new line:
   ```sql
               chamber = excluded.chamber,
               enriched_at = politicians.enriched_at
   ```

4. Trade upsert (the `stmt_trade` prepared statement): In the ON CONFLICT clause, make these column replacements:
   - Change `has_capital_gains = excluded.has_capital_gains` to:
     ```sql
     has_capital_gains = CASE
       WHEN excluded.has_capital_gains = 1 THEN excluded.has_capital_gains
       ELSE trades.has_capital_gains
     END
     ```
   - Change `price = excluded.price` to `price = COALESCE(excluded.price, trades.price)`
   - Change `size = excluded.size` to `size = COALESCE(excluded.size, trades.size)`
   - Change `size_range_high = excluded.size_range_high` to `size_range_high = COALESCE(excluded.size_range_high, trades.size_range_high)`
   - Change `size_range_low = excluded.size_range_low` to `size_range_low = COALESCE(excluded.size_range_low, trades.size_range_low)`
   - Change `filing_id = excluded.filing_id` to:
     ```sql
     filing_id = CASE
       WHEN excluded.filing_id > 0 THEN excluded.filing_id
       ELSE trades.filing_id
     END
     ```
   - Change `filing_url = excluded.filing_url` to:
     ```sql
     filing_url = CASE
       WHEN excluded.filing_url != '' THEN excluded.filing_url
       ELSE trades.filing_url
     END
     ```
   - The ON CONFLICT SET clause currently ends with `comment = excluded.comment`. Add a comma after that line and a new line:
     ```sql
                   comment = excluded.comment,
                   enriched_at = trades.enriched_at
     ```

**B. upsert_scraped_trades (scraper path)**

5. Asset upsert (the `stmt_asset` prepared statement): Same fix as A.1 above -- replace `asset_type = excluded.asset_type` with the CASE expression guarding against 'unknown'.

6. Issuer upsert (the `stmt_issuer` prepared statement): The ON CONFLICT SET clause currently ends with `country = COALESCE(excluded.country, issuers.country)`. Add a comma after that line and a new line:
   ```sql
                   country = COALESCE(excluded.country, issuers.country),
                   enriched_at = issuers.enriched_at
   ```

7. Politician upsert (the `stmt_politician` prepared statement): The ON CONFLICT SET clause currently ends with `chamber = excluded.chamber`. Add a comma after that line and a new line:
   ```sql
                   chamber = excluded.chamber,
                   enriched_at = politicians.enriched_at
   ```

8. Trade upsert (the `stmt_trade` prepared statement): Apply the SAME column changes as A.4:
   - has_capital_gains: CASE expression (keep existing if incoming = 0)
   - price: COALESCE(excluded.price, trades.price)
   - size: COALESCE(excluded.size, trades.size)
   - size_range_high: COALESCE(excluded.size_range_high, trades.size_range_high)
   - size_range_low: COALESCE(excluded.size_range_low, trades.size_range_low)
   - filing_id: CASE expression (keep existing if incoming > 0)
   - filing_url: CASE expression (keep existing if incoming != '')
   - The ON CONFLICT SET clause currently ends with `comment = excluded.comment`. Add a comma after that line and a new line:
     ```sql
                       comment = excluded.comment,
                       enriched_at = trades.enriched_at
     ```

**IMPORTANT**: Do not change columns that the research marked as "No change needed" (politician_id, pub_date, tx_date, tx_type, owner, chamber, value, reporting_gap, comment, etc.). Only change the specific columns listed above.
  </action>
  <verify>
Run `cargo check --workspace` -- must compile.
Run `cargo test --workspace` -- all existing tests must pass (SQL changes are in string literals, no signature changes).
Run `cargo clippy --workspace` -- no new warnings.
Manually inspect both upsert_trades and upsert_scraped_trades in db.rs to confirm:
- Every ON CONFLICT clause for trades has `enriched_at = trades.enriched_at`
- Every ON CONFLICT clause for politicians has `enriched_at = politicians.enriched_at`
- Every ON CONFLICT clause for issuers has `enriched_at = issuers.enriched_at`
- filing_id uses CASE with > 0 check
- filing_url uses CASE with != '' check
- asset_type uses CASE with != 'unknown' check
- has_capital_gains uses CASE with = 1 check
- price, size, size_range_high, size_range_low use COALESCE
  </verify>
  <done>
- upsert_trades and upsert_scraped_trades have sentinel-protected columns via CASE expressions
- upsert_trades and upsert_scraped_trades have COALESCE for nullable columns (price, size, size_range_*)
- All ON CONFLICT clauses in both functions preserve enriched_at for trades, politicians, issuers, and assets
- No functional regressions in existing tests
  </done>
</task>

<task type="auto">
  <name>Task 1b: Add enriched_at preservation to upsert_politicians and upsert_issuers</name>
  <files>capitoltraders_lib/src/db.rs</files>
  <action>
Add enriched_at preservation to the remaining two standalone upsert functions. These functions receive complete data from the detail API, so all other columns can be unconditionally overwritten -- only enriched_at needs protection.

**C. upsert_politicians**

1. In the `stmt_politician` prepared statement inside upsert_politicians: The ON CONFLICT SET clause currently ends with `chamber = excluded.chamber`. Add a comma after that line and a new line:
   ```sql
               chamber = excluded.chamber,
               enriched_at = politicians.enriched_at
   ```
   Do NOT change any other columns in this function.

**D. upsert_issuers**

2. In the `stmt_issuer` prepared statement inside upsert_issuers: The ON CONFLICT SET clause currently ends with `sector = excluded.sector`. Add a comma after that line and a new line:
   ```sql
               sector = excluded.sector,
               enriched_at = issuers.enriched_at
   ```
   Do NOT change any other columns in this function.
  </action>
  <verify>
Run `cargo check --workspace` -- must compile.
Run `cargo test --workspace` -- all existing tests must pass.
Manually inspect upsert_politicians and upsert_issuers in db.rs to confirm each ON CONFLICT SET clause ends with `enriched_at = {table}.enriched_at`.
  </verify>
  <done>
- upsert_politicians ON CONFLICT SET clause preserves enriched_at = politicians.enriched_at
- upsert_issuers ON CONFLICT SET clause preserves enriched_at = issuers.enriched_at
- All 4 upsert functions now preserve enriched_at across the entire codebase
- No functional regressions
  </done>
</task>

<task type="auto">
  <name>Task 2: Add enrichment query methods and comprehensive tests</name>
  <files>capitoltraders_lib/src/db.rs</files>
  <action>
**A. Add 3 enrichment query methods** to the `impl Db` block:

1. `get_unenriched_trade_ids(&self, limit: Option<i64>) -> Result<Vec<i64>, DbError>`:
   - SQL: `SELECT tx_id FROM trades WHERE enriched_at IS NULL ORDER BY tx_id`
   - With limit: append `LIMIT {n}`
   - Use prepared statement, query_map to collect Vec<i64>

2. `get_unenriched_politician_ids(&self, limit: Option<i64>) -> Result<Vec<String>, DbError>`:
   - SQL: `SELECT politician_id FROM politicians WHERE enriched_at IS NULL ORDER BY politician_id`
   - Same limit pattern. Returns Vec<String> because politician_id is TEXT.

3. `get_unenriched_issuer_ids(&self, limit: Option<i64>) -> Result<Vec<i64>, DbError>`:
   - SQL: `SELECT issuer_id FROM issuers WHERE enriched_at IS NULL ORDER BY issuer_id`
   - Same limit pattern.

**B. Add comprehensive tests** to the existing `#[cfg(test)] mod tests` block (created by Plan 01). Add these tests:

**Upsert sentinel protection tests (using upsert_scraped_trades):**

5. `test_upsert_preserves_enriched_filing_id` -- Insert a ScrapedTrade with filing_id=Some(12345). Manually UPDATE the trade to set filing_id=12345 (simulating enrichment). Then upsert the same trade again with filing_id=None (which becomes 0 via `unwrap_or(0)`). Assert filing_id is still 12345, not 0.

6. `test_upsert_preserves_enriched_filing_url` -- Same pattern: insert with filing_url=Some("https://example.com"), then re-upsert with filing_url=None (becomes ""). Assert the URL is preserved.

7. `test_upsert_preserves_enriched_price` -- Insert with price=Some(150.0), re-upsert with price=None. Assert price is still 150.0.

8. `test_upsert_preserves_enriched_at_timestamp` -- Insert a trade, manually UPDATE to set enriched_at = '2026-01-15T12:00:00Z'. Re-upsert the same trade. Assert enriched_at is still '2026-01-15T12:00:00Z'.

9. `test_upsert_asset_type_sentinel_protection` -- Insert a trade with asset_type="stock" (via direct SQL on assets table). Re-upsert a ScrapedTrade whose asset inserts with asset_type="unknown". Assert asset_type is still "stock".

10. `test_upsert_overwrites_sentinel_with_real_value` -- Insert with filing_id=0. Re-upsert with filing_id=Some(99999). Assert filing_id is now 99999 (the CASE expression should pick the non-sentinel value).

**Enrichment query tests:**

11. `test_get_unenriched_trade_ids_returns_all` -- Insert 3 trades via upsert. All should have enriched_at=NULL. Call get_unenriched_trade_ids(None). Assert returns all 3 IDs.

12. `test_get_unenriched_trade_ids_excludes_enriched` -- Insert 3 trades. Manually UPDATE one to set enriched_at = '2026-01-15T12:00:00Z'. Call get_unenriched_trade_ids(None). Assert returns only 2 IDs.

13. `test_get_unenriched_trade_ids_with_limit` -- Insert 5 trades. Call get_unenriched_trade_ids(Some(2)). Assert returns exactly 2 IDs.

14. `test_get_unenriched_politician_ids` -- Insert 2 politicians (via upsert_scraped_trades with different politician_ids). Call get_unenriched_politician_ids(None). Assert returns both IDs.

15. `test_get_unenriched_issuer_ids` -- Insert 2 issuers (via upsert_scraped_trades with different issuer_ids). Call get_unenriched_issuer_ids(None). Assert returns both IDs.

**Test helper:** Create a helper function to build a minimal ScrapedTrade for testing:
```rust
fn make_test_scraped_trade(tx_id: i64, politician_id: &str, issuer_id: i64) -> ScrapedTrade {
    // Fill in minimal required fields -- use the ScrapedTrade struct fields
    // from scrape.rs. Set filing_id=None, filing_url=None, price=None
    // to simulate listing-page data.
}
```

Look at the ScrapedTrade struct definition in `capitoltraders_lib/src/scrape.rs` to understand the exact fields needed. If ScrapedTrade fields are not all pub, the test module (being in db.rs which is in the same crate) can still access them via `use crate::scrape::ScrapedTrade`.

Note: The `upsert_scraped_trades` and `upsert_trades` methods take `&mut self`. The test helper `open_test_db()` from Plan 01 returns a `Db` -- make sure it is bound as `let mut db = open_test_db()`.
  </action>
  <verify>
Run `cargo test -p capitoltraders_lib -- db::tests` -- all tests pass (4 from Plan 01 + 11 new = 15 total).
Run `cargo test --workspace` -- all tests pass.
Run `cargo clippy --workspace` -- no new warnings.
  </verify>
  <done>
- 3 enrichment query methods: get_unenriched_trade_ids, get_unenriched_politician_ids, get_unenriched_issuer_ids
- 11 new tests covering sentinel protection, COALESCE behavior, enriched_at preservation, and enrichment queries
- All existing + new tests pass
- FOUND-01 (upsert corruption) verified by tests showing enriched values survive re-upsert
- FOUND-03 (enrichment work queue) verified by tests showing correct ID filtering
  </done>
</task>

</tasks>

<verification>
After all tasks, verify ALL four phase success criteria from ROADMAP.md:

1. **"Running an incremental sync after a full enrichment run preserves all enriched field values"**
   - Verified by: test_upsert_preserves_enriched_filing_id, test_upsert_preserves_enriched_filing_url, test_upsert_preserves_enriched_price, test_upsert_preserves_enriched_at_timestamp, test_upsert_asset_type_sentinel_protection

2. **"Each trade, politician, and issuer row has an enriched_at column"**
   - Verified by: test_init_creates_enriched_at_columns (from Plan 01), test_enriched_at_defaults_to_null (from Plan 01)

3. **"A Db query can return the list of trade/politician/issuer IDs that need enrichment"**
   - Verified by: test_get_unenriched_trade_ids_returns_all, test_get_unenriched_trade_ids_excludes_enriched, test_get_unenriched_trade_ids_with_limit, test_get_unenriched_politician_ids, test_get_unenriched_issuer_ids

4. **"Opening an existing database (pre-migration) with the new code applies schema changes without data loss"**
   - Verified by: test_migration_on_existing_db (from Plan 01)

Full verification command:
```bash
cargo test --workspace && cargo clippy --workspace
```
</verification>

<success_criteria>
- Sentinel protection via CASE expressions for: filing_id (>0), filing_url (!=''), asset_type (!='unknown'), has_capital_gains (=1)
- COALESCE for nullable: price, size, size_range_high, size_range_low
- enriched_at preserved in ALL ON CONFLICT clauses across all 4 upsert functions (upsert_trades, upsert_scraped_trades, upsert_politicians, upsert_issuers)
- 3 enrichment query methods returning Vec of IDs where enriched_at IS NULL
- 15 total tests in db::tests module (4 migration + 11 upsert/query)
- All 194 existing tests still pass
- Zero clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
