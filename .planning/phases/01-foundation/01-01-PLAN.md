---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - schema/sqlite.sql
  - capitoltraders_lib/src/db.rs
autonomous: true

must_haves:
  truths:
    - "Opening an existing database (pre-migration) with the new code applies enriched_at columns without data loss"
    - "Opening a brand-new database creates enriched_at columns from the start"
    - "Re-opening an already-migrated database does not error or re-run migration"
  artifacts:
    - path: "schema/sqlite.sql"
      provides: "enriched_at TEXT columns in trades, politicians, issuers CREATE TABLE definitions"
      contains: "enriched_at TEXT"
    - path: "capitoltraders_lib/src/db.rs"
      provides: "Version-gated migration in Db::init() using PRAGMA user_version"
      contains: "user_version"
  key_links:
    - from: "capitoltraders_lib/src/db.rs"
      to: "schema/sqlite.sql"
      via: "include_str! in init()"
      pattern: "include_str!"
---

<objective>
Add enriched_at timestamp columns to trades, politicians, and issuers tables with schema migration support for existing databases.

Purpose: FOUND-02 and FOUND-04 -- enrichment tracking columns must exist before upsert fixes can reference them, and existing databases must gain the columns without data loss.
Output: Updated sqlite.sql schema, version-gated migration in Db::init()
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@schema/sqlite.sql
@capitoltraders_lib/src/db.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add enriched_at columns to schema DDL and implement version-gated migration</name>
  <files>schema/sqlite.sql, capitoltraders_lib/src/db.rs</files>
  <action>
1. In `schema/sqlite.sql`, add `enriched_at TEXT` as the last column (before the closing paren or FOREIGN KEY clauses) in three CREATE TABLE definitions:
   - `trades` table: after the line `comment TEXT,` (currently the last column before FOREIGN KEY lines), add a new line: `enriched_at TEXT,`
   - `politicians` table: change `chamber TEXT NOT NULL` to `chamber TEXT NOT NULL,` (add trailing comma) and add a new line after it: `enriched_at TEXT`
   - `issuers` table: change `sector TEXT` to `sector TEXT,` (add trailing comma) and add a new line after it: `enriched_at TEXT`

   The column is nullable TEXT. NULL means "not yet enriched." A non-NULL value is an ISO 8601 timestamp.

2. In `capitoltraders_lib/src/db.rs`, rewrite the `init()` method to:
   a. Run the existing `include_str!("../../schema/sqlite.sql")` batch as before.
   b. Read the current schema version: `self.conn.pragma_query_value(None, "user_version", |row| row.get(0))?` into an `i32`.
   c. If version < 1, call a new private method `migrate_v1()` then set `PRAGMA user_version = 1`.

3. Add the `migrate_v1` private method to `Db`:
   ```rust
   fn migrate_v1(&self) -> Result<(), DbError> {
       for sql in &[
           "ALTER TABLE trades ADD COLUMN enriched_at TEXT",
           "ALTER TABLE politicians ADD COLUMN enriched_at TEXT",
           "ALTER TABLE issuers ADD COLUMN enriched_at TEXT",
       ] {
           match self.conn.execute(sql, []) {
               Ok(_) => {}
               Err(rusqlite::Error::SqliteFailure(_, Some(ref msg)))
                   if msg.contains("duplicate column name") => {}
               Err(e) => return Err(e.into()),
           }
       }
       Ok(())
   }
   ```
   The "duplicate column name" catch is a safety net for edge cases where user_version was not set but columns already exist.

4. Add three enrichment indexes to the end of `schema/sqlite.sql`, after the last existing CREATE INDEX statement (`CREATE INDEX IF NOT EXISTS idx_eod_prices_date ON issuer_eod_prices(price_date);` on the final line). Append these three lines:
   ```sql
   CREATE INDEX IF NOT EXISTS idx_trades_enriched ON trades(enriched_at);
   CREATE INDEX IF NOT EXISTS idx_politicians_enriched ON politicians(enriched_at);
   CREATE INDEX IF NOT EXISTS idx_issuers_enriched ON issuers(enriched_at);
   ```
  </action>
  <verify>
Run `cargo check --workspace` -- must compile with no errors.
Run `cargo test --workspace` -- all 194 existing tests must pass (schema change is additive, no existing behavior changes).
Run `cargo clippy --workspace` -- no new warnings.
  </verify>
  <done>
- sqlite.sql has enriched_at TEXT in trades, politicians, and issuers CREATE TABLE definitions
- sqlite.sql has three new enrichment indexes after the existing idx_eod_prices_date index
- Db::init() checks PRAGMA user_version and runs migrate_v1() for version < 1
- migrate_v1() adds enriched_at via ALTER TABLE with duplicate-column safety catch
- All existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for migration and enriched_at column behavior</name>
  <files>capitoltraders_lib/src/db.rs</files>
  <action>
Add a `#[cfg(test)] mod tests` block at the bottom of `db.rs` (before the closing of the file, after the existing struct definitions). The tests use in-memory SQLite databases.

Write the following tests:

1. `test_init_creates_enriched_at_columns` -- Open an in-memory Db, call init(), then verify the three enriched_at columns exist by running `PRAGMA table_info(trades)`, `PRAGMA table_info(politicians)`, `PRAGMA table_info(issuers)` and asserting each result set contains a row with name = "enriched_at".

2. `test_init_idempotent` -- Open an in-memory Db, call init() twice. Second call must not error. Verify PRAGMA user_version = 1 after both calls.

3. `test_migration_on_existing_db` -- Open an in-memory Db, manually execute the OLD schema (without enriched_at columns -- copy the CREATE TABLE statements from the current sqlite.sql but omit enriched_at). Leave PRAGMA user_version at 0. Then call init(). Verify:
   - enriched_at column exists in all three tables
   - PRAGMA user_version = 1
   - Any data previously inserted is preserved (insert a test politician row before init(), verify it still exists after)

4. `test_enriched_at_defaults_to_null` -- After init(), insert a trade row (with all required fields). Query back and assert enriched_at IS NULL.

Helper: Create a helper function `fn open_test_db() -> Db` that opens `:memory:` and calls init(). For tests that need the pre-migration schema, create the schema manually without enriched_at and without calling init().

Note: Db::open currently takes `impl AsRef<Path>`. For in-memory databases, pass ":memory:" which rusqlite supports. If `Db::open` does not accept this, add a `Db::open_in_memory()` constructor:
```rust
#[cfg(test)]
pub fn open_in_memory() -> Result<Self, DbError> {
    let conn = Connection::open_in_memory()?;
    conn.execute_batch(
        "PRAGMA foreign_keys = ON;
         PRAGMA journal_mode = WAL;
         PRAGMA synchronous = NORMAL;",
    )?;
    Ok(Self { conn })
}
```
  </action>
  <verify>
Run `cargo test -p capitoltraders_lib -- db::tests` -- all 4 new tests pass.
Run `cargo test --workspace` -- all tests (existing + new) pass.
  </verify>
  <done>
- 4 tests covering: column creation, idempotency, migration on existing DB, NULL default
- Tests use in-memory SQLite (no disk I/O, no cleanup)
- All tests pass
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `cargo check --workspace` compiles cleanly
2. `cargo test --workspace` passes all tests (194 existing + 4 new = 198)
3. `cargo clippy --workspace` has no new warnings
4. `schema/sqlite.sql` contains enriched_at in all three entity table definitions
5. `db.rs` init() reads PRAGMA user_version and conditionally runs migration
</verification>

<success_criteria>
- enriched_at TEXT column defined in sqlite.sql for trades, politicians, issuers
- Version-gated migration via PRAGMA user_version in Db::init()
- Duplicate column name errors safely caught in migrate_v1()
- 4 passing tests for migration behavior
- All 194 existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
