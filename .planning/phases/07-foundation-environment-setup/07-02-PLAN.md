---
phase: 07-foundation-environment-setup
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - capitoltraders_lib/src/fec_mapping.rs
  - capitoltraders_lib/src/lib.rs
  - capitoltraders_lib/src/db.rs
  - capitoltraders_cli/src/commands/sync_fec.rs
  - capitoltraders_cli/src/commands/mod.rs
  - capitoltraders_cli/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Congress-legislators YAML dataset (current + historical) is downloaded and parsed into typed Rust structs"
    - "Legislators are matched to existing CapitolTrades politicians via (last_name, state) composite key"
    - "FEC candidate IDs are stored in fec_mappings table with bioguide_id for audit trail"
    - "A lookup by politician_id returns all associated FEC candidate IDs"
    - "A lookup by bioguide_id returns the associated politician_id"
    - "Running `capitoltraders sync-fec --db trades.db` downloads congress-legislators data, matches politicians, and populates fec_mappings"
    - "Politicians with zero FEC IDs in the dataset are skipped gracefully (no error)"
    - "Politicians with multiple FEC IDs across election cycles produce multiple rows in fec_mappings"
  artifacts:
    - path: "capitoltraders_lib/src/fec_mapping.rs"
      provides: "Legislator YAML types, download, parse, and name-matching logic"
      contains: "Legislator"
    - path: "capitoltraders_lib/src/db.rs"
      provides: "upsert_fec_mappings, get_fec_ids_for_politician, get_politician_id_for_bioguide methods"
      contains: "upsert_fec_mappings"
    - path: "capitoltraders_cli/src/commands/sync_fec.rs"
      provides: "sync-fec CLI command handler"
      contains: "SyncFecArgs"
    - path: "capitoltraders_cli/src/main.rs"
      provides: "SyncFec variant in Commands enum"
      contains: "SyncFec"
  key_links:
    - from: "capitoltraders_cli/src/commands/sync_fec.rs"
      to: "capitoltraders_lib/src/fec_mapping.rs"
      via: "calls download_and_parse_legislators() then match_legislators_to_politicians()"
      pattern: "download_and_parse|match_legislators"
    - from: "capitoltraders_cli/src/commands/sync_fec.rs"
      to: "capitoltraders_lib/src/db.rs"
      via: "calls db.upsert_fec_mappings() to persist matched FEC IDs"
      pattern: "upsert_fec_mappings"
    - from: "capitoltraders_lib/src/fec_mapping.rs"
      to: "https://raw.githubusercontent.com/unitedstates/congress-legislators/main/"
      via: "reqwest HTTP GET for YAML files"
      pattern: "legislators-current.yaml|legislators-historical.yaml"
---

<objective>
Create the FEC mapping module with YAML parsing for the congress-legislators dataset, implement name-based politician matching, add DB operations for FEC ID storage/lookup, and wire up the sync-fec CLI command.

Purpose: Enable the system to resolve any CapitolTrades politician to their FEC candidate IDs, which is the prerequisite for all donation-related queries in Phases 8-12.
Output: Working sync-fec command that populates fec_mappings table, plus library functions for FEC ID lookup.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-foundation-environment-setup/07-RESEARCH.md
@.planning/phases/07-foundation-environment-setup/07-01-SUMMARY.md
@capitoltraders_lib/src/lib.rs
@capitoltraders_lib/src/db.rs
@capitoltraders_cli/src/main.rs
@capitoltraders_cli/src/commands/mod.rs
@capitoltraders_cli/src/commands/sync.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: FEC mapping module with YAML types, download, parse, and matching logic</name>
  <files>
    capitoltraders_lib/src/fec_mapping.rs
    capitoltraders_lib/src/lib.rs
  </files>
  <action>
1. Create capitoltraders_lib/src/fec_mapping.rs with the following components:

   a. Error type (following existing YahooError, DbError patterns):
   ```rust
   use thiserror::Error;

   #[derive(Error, Debug)]
   pub enum FecMappingError {
       #[error("Failed to download congress-legislators dataset: {0}")]
       Download(String),
       #[error("Failed to parse YAML: {0}")]
       YamlParse(#[from] serde_yml::Error),
       #[error("HTTP request failed: {0}")]
       Http(#[from] reqwest::Error),
       #[error("No FEC IDs found for politician: {0}")]
       NoFecIds(String),
   }
   ```

   b. YAML deserialization types matching the congress-legislators dataset structure:
   ```rust
   #[derive(Deserialize, Debug, Clone)]
   pub struct Legislator {
       pub id: LegislatorId,
       pub name: LegislatorName,
       pub terms: Vec<Term>,
   }

   #[derive(Deserialize, Debug, Clone)]
   pub struct LegislatorId {
       pub bioguide: String,
       pub fec: Option<Vec<String>>,
       // Other ID fields are optional and not needed for Phase 7
   }

   #[derive(Deserialize, Debug, Clone)]
   pub struct LegislatorName {
       pub first: String,
       pub last: String,
       pub official_full: Option<String>,
   }

   #[derive(Deserialize, Debug, Clone)]
   pub struct Term {
       #[serde(rename = "type")]
       pub term_type: String,
       pub start: String,
       pub end: String,
       pub state: String,
       pub party: String,
   }
   ```

   c. Download function (async, uses reqwest which is already in workspace deps):
   ```rust
   const CURRENT_LEGISLATORS_URL: &str =
       "https://raw.githubusercontent.com/unitedstates/congress-legislators/main/legislators-current.yaml";
   const HISTORICAL_LEGISLATORS_URL: &str =
       "https://raw.githubusercontent.com/unitedstates/congress-legislators/main/legislators-historical.yaml";

   pub async fn download_legislators(client: &reqwest::Client) -> Result<Vec<Legislator>, FecMappingError> {
       let mut all = Vec::new();

       for url in &[CURRENT_LEGISLATORS_URL, HISTORICAL_LEGISLATORS_URL] {
           let response = client.get(*url).send().await?;
           if !response.status().is_success() {
               return Err(FecMappingError::Download(
                   format!("HTTP {} from {}", response.status(), url)
               ));
           }
           let yaml_content = response.text().await?;
           let legislators: Vec<Legislator> = serde_yml::from_str(&yaml_content)?;
           all.extend(legislators);
       }

       Ok(all)
   }
   ```

   d. Matching result type:
   ```rust
   #[derive(Debug, Clone)]
   pub struct FecMapping {
       pub politician_id: String,
       pub fec_candidate_id: String,
       pub bioguide_id: String,
   }
   ```

   e. Name-based matching function. Takes legislators + a list of (politician_id, last_name, state_id) tuples from the DB:
   ```rust
   use std::collections::HashMap;

   pub fn match_legislators_to_politicians(
       legislators: &[Legislator],
       politicians: &[(String, String, String)], // (politician_id, last_name, state_id)
   ) -> Vec<FecMapping> {
       // Build lookup: (lowercase_last_name, uppercase_state) -> politician_id
       let mut lookup: HashMap<(String, String), Vec<String>> = HashMap::new();
       for (pol_id, last_name, state) in politicians {
           let key = (last_name.to_lowercase(), state.to_uppercase());
           lookup.entry(key).or_default().push(pol_id.clone());
       }

       let mut mappings = Vec::new();

       for legislator in legislators {
           // Skip legislators with no FEC IDs
           let fec_ids = match &legislator.id.fec {
               Some(ids) if !ids.is_empty() => ids,
               _ => continue,
           };

           // Use most recent term's state for matching
           let state = match legislator.terms.last() {
               Some(term) => term.state.to_uppercase(),
               None => continue,
           };

           let key = (legislator.name.last.to_lowercase(), state);

           if let Some(pol_ids) = lookup.get(&key) {
               if pol_ids.len() > 1 {
                   tracing::warn!(
                       "Multiple politicians match ({}, {}): {:?} -- skipping to avoid incorrect mapping",
                       legislator.name.last, key.1, pol_ids
                   );
                   continue;
               }

               let pol_id = &pol_ids[0];
               for fec_id in fec_ids {
                   mappings.push(FecMapping {
                       politician_id: pol_id.clone(),
                       fec_candidate_id: fec_id.clone(),
                       bioguide_id: legislator.id.bioguide.clone(),
                   });
               }
           }
       }

       mappings
   }
   ```

   f. Unit tests in the module (under #[cfg(test)] mod tests):
   - Test parsing a minimal YAML snippet with serde_yml::from_str
   - Test matching with exact match (one legislator, one politician)
   - Test matching with no FEC IDs (should produce empty mappings)
   - Test matching with multiple FEC IDs per legislator (should produce multiple FecMapping entries)
   - Test matching with name collision (two politicians same last name + state) logs warning and skips
   - Test matching with no match in DB (legislator state/name not in politicians list)
   - Test case insensitivity of last name matching
   - Target: 7-9 unit tests

2. Export the new module from capitoltraders_lib/src/lib.rs:
   ```rust
   pub mod fec_mapping;
   ```
   And add re-exports:
   ```rust
   pub use fec_mapping::{FecMapping, FecMappingError, Legislator, download_legislators, match_legislators_to_politicians};
   ```
  </action>
  <verify>
    - `cargo test -p capitoltraders_lib fec_mapping` -- all new unit tests pass
    - `cargo check --workspace` -- compiles cleanly
    - `cargo clippy --workspace` -- no warnings
  </verify>
  <done>
    fec_mapping.rs module exists with YAML types (Legislator, LegislatorId, LegislatorName, Term), FecMappingError enum, download_legislators() async function, match_legislators_to_politicians() pure function, and 7-9 unit tests covering parsing, matching, edge cases. Module is exported from lib.rs.
  </done>
</task>

<task type="auto">
  <name>Task 2: DB operations for FEC mappings and sync-fec CLI command</name>
  <files>
    capitoltraders_lib/src/db.rs
    capitoltraders_cli/src/commands/sync_fec.rs
    capitoltraders_cli/src/commands/mod.rs
    capitoltraders_cli/src/main.rs
  </files>
  <action>
1. Add FEC mapping DB methods to capitoltraders_lib/src/db.rs:

   a. Add a method to get all politicians as (politician_id, last_name, state_id) tuples for matching:
   ```rust
   pub fn get_politicians_for_fec_matching(&self) -> Result<Vec<(String, String, String)>, DbError> {
       let mut stmt = self.conn.prepare(
           "SELECT politician_id, last_name, state_id FROM politicians"
       )?;
       let rows = stmt.query_map([], |row| {
           Ok((
               row.get::<_, String>(0)?,
               row.get::<_, String>(1)?,
               row.get::<_, String>(2)?,
           ))
       })?;
       let mut result = Vec::new();
       for row in rows {
           result.push(row?);
       }
       Ok(result)
   }
   ```

   b. Upsert FEC mappings (accepts FecMapping slice):
   ```rust
   pub fn upsert_fec_mappings(&mut self, mappings: &[crate::fec_mapping::FecMapping]) -> Result<usize, DbError> {
       let tx = self.conn.transaction()?;
       let mut count = 0;
       {
           let mut stmt = tx.prepare(
               "INSERT INTO fec_mappings (politician_id, fec_candidate_id, bioguide_id, last_synced)
                VALUES (?1, ?2, ?3, datetime('now'))
                ON CONFLICT(politician_id, fec_candidate_id) DO UPDATE SET
                  bioguide_id = excluded.bioguide_id,
                  last_synced = datetime('now')"
           )?;
           for mapping in mappings {
               stmt.execute(params![
                   mapping.politician_id,
                   mapping.fec_candidate_id,
                   mapping.bioguide_id,
               ])?;
               count += 1;
           }
       }
       tx.commit()?;
       Ok(count)
   }
   ```

   c. Lookup FEC IDs by politician_id:
   ```rust
   pub fn get_fec_ids_for_politician(&self, politician_id: &str) -> Result<Vec<String>, DbError> {
       let mut stmt = self.conn.prepare(
           "SELECT fec_candidate_id FROM fec_mappings WHERE politician_id = ?1"
       )?;
       let rows = stmt.query_map([politician_id], |row| row.get(0))?;
       let mut result = Vec::new();
       for row in rows {
           result.push(row?);
       }
       Ok(result)
   }
   ```

   d. Lookup politician_id by bioguide_id:
   ```rust
   pub fn get_politician_id_for_bioguide(&self, bioguide_id: &str) -> Result<Option<String>, DbError> {
       self.conn
           .query_row(
               "SELECT DISTINCT politician_id FROM fec_mappings WHERE bioguide_id = ?1 LIMIT 1",
               params![bioguide_id],
               |row| row.get(0),
           )
           .optional()
           .map_err(DbError::from)
   }
   ```

   e. Count total FEC mappings (for status reporting):
   ```rust
   pub fn count_fec_mappings(&self) -> Result<i64, DbError> {
       let count: i64 = self.conn.query_row(
           "SELECT COUNT(*) FROM fec_mappings", [], |row| row.get(0)
       )?;
       Ok(count)
   }
   ```

   f. Add DB tests (in existing #[cfg(test)] mod):
   - Test upsert_fec_mappings inserts and can be queried back
   - Test get_fec_ids_for_politician returns correct IDs
   - Test get_fec_ids_for_politician returns empty vec for unknown politician
   - Test get_politician_id_for_bioguide returns correct politician_id
   - Test get_politician_id_for_bioguide returns None for unknown bioguide
   - Test upsert_fec_mappings is idempotent (upsert twice, count stays same)
   - Target: 6 tests
   Note: These tests need a politician row in the DB first (FK constraint). Insert a test politician before inserting fec_mappings. Use the existing upsert_trades/upsert_politicians patterns from the test module.

2. Create capitoltraders_cli/src/commands/sync_fec.rs:
   ```rust
   use std::path::PathBuf;
   use anyhow::Result;
   use clap::Args;
   use capitoltraders_lib::{Db, download_legislators, match_legislators_to_politicians};

   #[derive(Args)]
   pub struct SyncFecArgs {
       /// Path to the SQLite database
       #[arg(long)]
       pub db: PathBuf,
   }

   pub async fn run(args: &SyncFecArgs) -> Result<()> {
       let mut db = Db::open(&args.db)?;
       db.init()?;

       // Step 1: Get existing politicians from DB for matching
       let politicians = db.get_politicians_for_fec_matching()?;
       if politicians.is_empty() {
           println!("No politicians found in database. Run 'capitoltraders sync --db {}' first to import politician data.", args.db.display());
           return Ok(());
       }
       println!("Found {} politicians in database", politicians.len());

       // Step 2: Download congress-legislators dataset
       println!("Downloading congress-legislators dataset...");
       let client = reqwest::Client::new();
       let legislators = download_legislators(&client).await?;
       println!("Loaded {} legislators from dataset", legislators.len());

       // Step 3: Match legislators to politicians
       let mappings = match_legislators_to_politicians(&legislators, &politicians);
       println!("Matched {} FEC ID mappings", mappings.len());

       if mappings.is_empty() {
           println!("No matches found. This may indicate the database has no overlapping politicians with the congress-legislators dataset.");
           return Ok(());
       }

       // Step 4: Persist to database
       let count = db.upsert_fec_mappings(&mappings)?;
       println!("Stored {} FEC ID mappings in database", count);

       // Step 5: Summary stats
       let total = db.count_fec_mappings()?;
       let unique_politicians: std::collections::HashSet<&str> = mappings.iter()
           .map(|m| m.politician_id.as_str())
           .collect();
       println!(
           "\nSync complete: {} total mappings for {} unique politicians",
           total, unique_politicians.len()
       );

       Ok(())
   }
   ```

3. Register the command in capitoltraders_cli/src/commands/mod.rs:
   Add `pub mod sync_fec;` to the module declarations.

4. Add the SyncFec variant to Commands enum in capitoltraders_cli/src/main.rs:
   ```rust
   /// Sync FEC candidate ID mappings from congress-legislators dataset
   SyncFec(commands::sync_fec::SyncFecArgs),
   ```
   And add the match arm:
   ```rust
   Commands::SyncFec(args) => commands::sync_fec::run(args).await?,
   ```

5. Verify the CLI help includes the new command:
   `cargo run -p capitoltraders_cli -- sync-fec --help`
  </action>
  <verify>
    - `cargo test --workspace` -- all tests pass (366+ existing + new DB tests + fec_mapping tests)
    - `cargo test -p capitoltraders_lib upsert_fec` -- DB upsert tests pass
    - `cargo test -p capitoltraders_lib get_fec_ids` -- lookup tests pass
    - `cargo test -p capitoltraders_lib bioguide` -- bioguide lookup tests pass
    - `cargo run -p capitoltraders_cli -- sync-fec --help` -- shows command help with --db flag
    - `cargo run -p capitoltraders_cli -- --help` -- lists sync-fec in available commands
    - `cargo clippy --workspace` -- no warnings
  </verify>
  <done>
    DB has upsert_fec_mappings(), get_fec_ids_for_politician(), get_politician_id_for_bioguide(), get_politicians_for_fec_matching(), and count_fec_mappings() methods with 6 tests. sync-fec CLI command is registered and wired, accepts --db flag, downloads congress-legislators YAML, matches by (last_name, state), and persists to fec_mappings table. All tests pass including 366+ existing. Clippy clean.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` compiles cleanly
2. `cargo test --workspace` passes all tests (366+ existing + ~15 new tests across fec_mapping and DB modules)
3. `cargo clippy --workspace` produces no warnings
4. `cargo run -p capitoltraders_cli -- sync-fec --help` shows expected help text with --db option
5. `cargo run -p capitoltraders_cli -- --help` lists sync-fec as available subcommand
6. FEC mapping unit tests verify: YAML parsing, name matching, edge cases (no FEC IDs, multiple IDs, collisions, case insensitivity)
7. DB tests verify: upsert, lookup by politician_id, lookup by bioguide_id, empty results, idempotency
</verification>

<success_criteria>
- fec_mapping.rs module with types, download, parse, and matching logic
- 7-9 unit tests for matching logic covering all edge cases
- DB methods for upsert and lookup of FEC mappings with 6 tests
- sync-fec CLI command registered and functional (compiles, shows help)
- All 366+ existing tests still pass plus ~15 new tests
- Zero clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation-environment-setup/07-02-SUMMARY.md`
</output>
