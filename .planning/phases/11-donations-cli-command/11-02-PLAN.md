---
phase: 11-donations-cli-command
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - capitoltraders_cli/src/commands/donations.rs
  - capitoltraders_cli/src/commands/mod.rs
  - capitoltraders_cli/src/main.rs
  - capitoltraders_cli/src/output.rs
  - capitoltraders_cli/src/xml_output.rs
autonomous: true

must_haves:
  truths:
    - "User can run 'capitoltraders donations --db trades.db --politician \"Nancy Pelosi\"' and see individual contributions sorted by amount"
    - "User can run '--group-by employer' to see aggregated donations by employer with total and count"
    - "User can run '--group-by contributor' to see aggregated donations by contributor"
    - "User can run '--group-by state' to see geographic breakdown of donations"
    - "User can apply '--top 10' to limit results to top N"
    - "User can filter with --cycle, --min-amount, --employer, --state"
    - "All 5 output formats work (table, JSON, CSV, markdown, XML)"
  artifacts:
    - path: "capitoltraders_cli/src/commands/donations.rs"
      provides: "DonationsArgs struct, run() function with filter validation and output dispatch"
      contains: "pub fn run"
    - path: "capitoltraders_cli/src/output.rs"
      provides: "Donation output row structs, print_donations_* functions, print_donations_agg_* functions"
      contains: "print_donations_table"
    - path: "capitoltraders_cli/src/xml_output.rs"
      provides: "donations_to_xml, donations_agg_to_xml functions"
      contains: "donations_to_xml"
    - path: "capitoltraders_cli/src/main.rs"
      provides: "Donations variant in Commands enum, dispatch in match block"
      contains: "Commands::Donations"
  key_links:
    - from: "capitoltraders_cli/src/commands/donations.rs"
      to: "capitoltraders_lib::Db"
      via: "db.query_donations / db.query_donations_by_* calls"
      pattern: "db\\.query_donations"
    - from: "capitoltraders_cli/src/commands/donations.rs"
      to: "capitoltraders_cli/src/output.rs"
      via: "print_donations_* function calls in output format match"
      pattern: "print_donations_"
    - from: "capitoltraders_cli/src/main.rs"
      to: "capitoltraders_cli/src/commands/donations.rs"
      via: "Commands::Donations dispatch"
      pattern: "Commands::Donations"
---

<objective>
Create the donations CLI subcommand with full output formatting support.

Purpose: Wire the DB query layer from Plan 01 into a user-facing CLI command with filter validation, group-by dispatch, and all 5 output formats (table, JSON, CSV, markdown, XML).

Output: Working `capitoltraders donations` subcommand that satisfies all Phase 11 success criteria from the roadmap.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-donations-cli-command/11-RESEARCH.md
@.planning/phases/11-donations-cli-command/11-01-SUMMARY.md
@capitoltraders_cli/src/commands/portfolio.rs
@capitoltraders_cli/src/main.rs
@capitoltraders_cli/src/output.rs
@capitoltraders_cli/src/xml_output.rs
@capitoltraders_cli/src/commands/mod.rs
@capitoltraders_lib/src/db.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Donations CLI command with filter validation</name>
  <files>capitoltraders_cli/src/commands/donations.rs, capitoltraders_cli/src/commands/mod.rs, capitoltraders_cli/src/main.rs</files>
  <action>
**Create `capitoltraders_cli/src/commands/donations.rs`:**

Follow the portfolio.rs pattern exactly. This is a DB-only command (no API calls, no async).

1. Module doc comment: `//! The \`donations\` subcommand: queries synced FEC donation data.`

2. Imports:
```rust
use anyhow::Result;
use capitoltraders_lib::{validation, Db, DonationFilter};
use clap::Args;
use std::path::PathBuf;

use crate::output::{
    print_donations_table, print_donations_csv, print_donations_markdown,
    print_donations_xml, print_donations_agg_table, print_donations_agg_csv,
    print_donations_agg_markdown, print_donations_agg_xml, print_json, OutputFormat,
};
```

3. `DonationsArgs` struct (clap derive):
```rust
#[derive(Args)]
pub struct DonationsArgs {
    /// SQLite database path (required)
    #[arg(long)]
    pub db: PathBuf,

    /// Filter by politician name (partial match, resolves to politician_id)
    #[arg(long)]
    pub politician: Option<String>,

    /// Filter by election cycle year (e.g., 2024)
    #[arg(long)]
    pub cycle: Option<i32>,

    /// Minimum contribution amount in dollars
    #[arg(long)]
    pub min_amount: Option<f64>,

    /// Filter by employer name (partial match)
    #[arg(long)]
    pub employer: Option<String>,

    /// Filter by contributor state (e.g., CA, TX)
    #[arg(long)]
    pub state: Option<String>,

    /// Show top N results
    #[arg(long)]
    pub top: Option<i64>,

    /// Group results by: contributor, employer, state
    #[arg(long)]
    pub group_by: Option<String>,
}
```

4. `pub fn run(args: &DonationsArgs, format: &OutputFormat) -> Result<()>`:

Implementation flow:
a. Open DB: `let db = Db::open(&args.db)?;`
b. Resolve politician name to ID using `db.find_politician_by_name()` (already exists from Phase 10). If --politician is provided:
   - Call `db.find_politician_by_name(name)`
   - If 0 matches: bail with "No politician found matching '{name}'"
   - If 1 match: use the politician_id
   - If >1 match: bail with "Multiple politicians match '{name}': {list}. Please be more specific."
   Note: Do NOT use validate_politician_id() because users pass names like "Nancy Pelosi", not IDs like "P000001".
c. Validate state if provided: `validation::validate_state(val.trim())?.to_string()`
d. Validate cycle if provided: cycle must be an even positive integer >= 1976. Simple check: `if cycle < 1976 || cycle % 2 != 0 { bail!("Invalid cycle: must be an even year >= 1976") }`
e. Validate min_amount if provided: must be >= 0. `if amount < 0.0 { bail!("--min-amount must be non-negative") }`
f. Validate top if provided: must be > 0. `if top <= 0 { bail!("--top must be a positive integer") }`
g. Build `DonationFilter` from validated args.
h. Validate group_by if provided: must be one of "contributor", "employer", "state". `bail!("Invalid --group-by value: '{}'. Valid options: contributor, employer, state", val)` for anything else.

i. Dispatch based on group_by:
   - `None` (individual listing):
     ```rust
     let donations = db.query_donations(&filter)?;
     if donations.is_empty() {
         eprintln!("No donations found matching the given filters.");
         eprintln!("Hint: Run 'capitoltraders sync-fec' and 'capitoltraders sync-donations' first.");
         return Ok(());
     }
     match format {
         OutputFormat::Table => print_donations_table(&donations),
         OutputFormat::Json => print_json(&donations),
         OutputFormat::Csv => print_donations_csv(&donations)?,
         OutputFormat::Markdown => print_donations_markdown(&donations),
         OutputFormat::Xml => print_donations_xml(&donations),
     }
     ```
   - `Some("contributor")`: call `db.query_donations_by_contributor(&filter)?`, dispatch to `print_donations_agg_table/csv/markdown/xml` (use print_json for JSON since ContributorAggRow derives Serialize)
   - `Some("employer")`: call `db.query_donations_by_employer(&filter)?`, same dispatch
   - `Some("state")`: call `db.query_donations_by_state(&filter)?`, same dispatch

   For aggregation modes, use a single generic approach: since all agg row types derive Serialize, `print_json` works for JSON. For table/CSV/markdown/XML, create separate print function sets OR use a single set that accepts `impl Tabled + Serialize`. The pragmatic approach: create one set of `print_donations_agg_*` functions that are generic over `T: Tabled + Serialize + Clone`.

**Update `capitoltraders_cli/src/commands/mod.rs`:**

Add `pub mod donations;` to the module list.

**Update `capitoltraders_cli/src/main.rs`:**

1. Add variant to Commands enum:
```rust
/// Query synced FEC donation data
Donations(commands::donations::DonationsArgs),
```

2. Add dispatch in the match block (near the Portfolio match arm):
```rust
Commands::Donations(args) => commands::donations::run(args, &format)?,
```

No async needed (DB-only read command, same as portfolio). No API key needed.

3. Update the module doc comment to include `donations` in the subcommand list.
  </action>
  <verify>
Run `cargo check -p capitoltraders_cli` -- should compile (may have warnings about unused imports if output functions not yet created; that is acceptable as Task 2 creates them).
Run `cargo run -p capitoltraders_cli -- donations --help` -- should show help text with all flags.
  </verify>
  <done>DonationsArgs defined with all filter flags. run() function validates inputs, resolves politician name to ID, builds DonationFilter, dispatches to correct query method based on --group-by, and dispatches to correct output format. Command registered in main.rs and mod.rs.</done>
</task>

<task type="auto">
  <name>Task 2: Output formatting for donations (all 5 formats) and tests</name>
  <files>capitoltraders_cli/src/output.rs, capitoltraders_cli/src/xml_output.rs</files>
  <action>
**Add to `capitoltraders_cli/src/output.rs`:**

Add new sections after the portfolio output section (before the JSON output section around line 670).

1. **Import additions** at top of file:
   Add `DonationRow, ContributorAggRow, EmployerAggRow, StateAggRow` to the capitoltraders_lib import line (alongside existing DbTradeRow, etc).

2. **DonationOutputRow** (individual listing display):
```rust
#[derive(Tabled, Serialize, Clone)]
struct DonationOutputRow {
    #[tabled(rename = "Date")]
    #[serde(rename = "Date")]
    date: String,
    #[tabled(rename = "Contributor")]
    #[serde(rename = "Contributor")]
    contributor: String,
    #[tabled(rename = "Employer")]
    #[serde(rename = "Employer")]
    employer: String,
    #[tabled(rename = "Amount")]
    #[serde(rename = "Amount")]
    amount: String,
    #[tabled(rename = "State")]
    #[serde(rename = "State")]
    state: String,
    #[tabled(rename = "Committee")]
    #[serde(rename = "Committee")]
    committee: String,
    #[tabled(rename = "Cycle")]
    #[serde(rename = "Cycle")]
    cycle: String,
}
```

3. **build_donation_rows** function:
```rust
fn build_donation_rows(donations: &[DonationRow]) -> Vec<DonationOutputRow> {
    donations.iter().map(|d| DonationOutputRow {
        date: d.date.clone(),
        contributor: d.contributor_name.clone(),
        employer: if d.contributor_employer.is_empty() { "-".to_string() } else { d.contributor_employer.clone() },
        amount: format_currency_with_commas(d.amount),
        state: if d.contributor_state.is_empty() { "-".to_string() } else { d.contributor_state.clone() },
        committee: if d.committee_name.is_empty() { "-".to_string() } else { d.committee_name.clone() },
        cycle: d.cycle.to_string(),
    }).collect()
}
```

4. **Individual donation print functions** (5 functions, following existing patterns exactly):

- `pub fn print_donations_table(donations: &[DonationRow])` -- Table::new + println
- `pub fn print_donations_markdown(donations: &[DonationRow])` -- Table::new + Style::markdown()
- `pub fn print_donations_csv(donations: &[DonationRow]) -> Result<()>` -- csv::Writer, sanitize contributor and employer fields using sanitize_csv_field()
- `pub fn print_donations_xml(donations: &[DonationRow])` -- call xml_output::donations_to_xml()

5. **Aggregation output rows** -- For the three aggregation types, create a single generic approach.

Define three Tabled+Serialize row structs for display:

```rust
#[derive(Tabled, Serialize, Clone)]
struct ContributorAggOutputRow {
    #[tabled(rename = "Contributor")]
    #[serde(rename = "Contributor")]
    name: String,
    #[tabled(rename = "State")]
    #[serde(rename = "State")]
    state: String,
    #[tabled(rename = "Total")]
    #[serde(rename = "Total")]
    total: String,
    #[tabled(rename = "Count")]
    #[serde(rename = "Count")]
    count: i64,
    #[tabled(rename = "Avg")]
    #[serde(rename = "Avg")]
    avg: String,
    #[tabled(rename = "Max")]
    #[serde(rename = "Max")]
    max: String,
    #[tabled(rename = "First")]
    #[serde(rename = "First")]
    first_date: String,
    #[tabled(rename = "Last")]
    #[serde(rename = "Last")]
    last_date: String,
}

#[derive(Tabled, Serialize, Clone)]
struct EmployerAggOutputRow {
    #[tabled(rename = "Employer")]
    #[serde(rename = "Employer")]
    employer: String,
    #[tabled(rename = "Total")]
    #[serde(rename = "Total")]
    total: String,
    #[tabled(rename = "Count")]
    #[serde(rename = "Count")]
    count: i64,
    #[tabled(rename = "Avg")]
    #[serde(rename = "Avg")]
    avg: String,
    #[tabled(rename = "Contributors")]
    #[serde(rename = "Contributors")]
    contributors: i64,
}

#[derive(Tabled, Serialize, Clone)]
struct StateAggOutputRow {
    #[tabled(rename = "State")]
    #[serde(rename = "State")]
    state: String,
    #[tabled(rename = "Total")]
    #[serde(rename = "Total")]
    total: String,
    #[tabled(rename = "Count")]
    #[serde(rename = "Count")]
    count: i64,
    #[tabled(rename = "Avg")]
    #[serde(rename = "Avg")]
    avg: String,
    #[tabled(rename = "Contributors")]
    #[serde(rename = "Contributors")]
    contributors: i64,
}
```

6. **Build functions and print functions for each aggregation type:**

For contributor aggregations:
- `fn build_contributor_agg_rows(rows: &[ContributorAggRow]) -> Vec<ContributorAggOutputRow>` -- format amounts with format_currency_with_commas
- `pub fn print_contributor_agg_table(rows: &[ContributorAggRow])` -- Table::new + println
- `pub fn print_contributor_agg_markdown(rows: &[ContributorAggRow])` -- Style::markdown()
- `pub fn print_contributor_agg_csv(rows: &[ContributorAggRow]) -> Result<()>` -- csv::Writer with sanitization
- `pub fn print_contributor_agg_xml(rows: &[ContributorAggRow])` -- xml_output::contributor_agg_to_xml

For employer aggregations:
- Same pattern: build_employer_agg_rows, print_employer_agg_table/markdown/csv/xml

For state aggregations:
- Same pattern: build_state_agg_rows, print_state_agg_table/markdown/csv/xml

**Important:** In the CSV output functions, sanitize the contributor name and employer fields using the existing `sanitize_csv_field()` function.

**Update the donations.rs imports** to reference the actual function names created here (update the import block from Task 1 to match actual names -- likely print_contributor_agg_table instead of generic print_donations_agg_table). Alternatively, update the donations.rs dispatch to call the type-specific functions directly:

```rust
Some("contributor") => {
    let rows = db.query_donations_by_contributor(&filter)?;
    // ... empty check
    match format {
        OutputFormat::Table => print_contributor_agg_table(&rows),
        OutputFormat::Json => print_json(&rows),
        OutputFormat::Csv => print_contributor_agg_csv(&rows)?,
        OutputFormat::Markdown => print_contributor_agg_markdown(&rows),
        OutputFormat::Xml => print_contributor_agg_xml(&rows),
    }
}
```

Same pattern for employer and state.

**Add to `capitoltraders_cli/src/xml_output.rs`:**

Add 4 new XML output functions after `portfolio_to_xml`:

```rust
/// Serializes donations into XML with `<donations>` root element.
pub fn donations_to_xml(donations: &[DonationRow]) -> String {
    items_to_xml("donations", "donation", donations)
}

/// Serializes contributor aggregations into XML.
pub fn contributor_agg_to_xml(rows: &[ContributorAggRow]) -> String {
    items_to_xml("contributors", "contributor", rows)
}

/// Serializes employer aggregations into XML.
pub fn employer_agg_to_xml(rows: &[EmployerAggRow]) -> String {
    items_to_xml("employers", "employer", rows)
}

/// Serializes state aggregations into XML.
pub fn state_agg_to_xml(rows: &[StateAggRow]) -> String {
    items_to_xml("states", "state", rows)
}
```

Add the necessary imports at the top of xml_output.rs:
`use capitoltraders_lib::{DonationRow, ContributorAggRow, EmployerAggRow, StateAggRow};`

Note: The DonationRow type already derives Serialize, but for `items_to_xml` to work it needs Serialize. The DB-layer types already have this. The xml_output functions use `items_to_xml` which calls `serde::Serialize`. So passing the DB row types directly to XML works because they derive Serialize. For the output row structs (DonationOutputRow etc), those are only used by table/CSV/markdown -- XML serializes the raw DB types directly (consistent with how portfolio_to_xml serializes PortfolioPosition, not PortfolioRow).

**Update donations.rs** to ensure the import list matches actual function names. Remove any generic `print_donations_agg_*` imports from Task 1 and replace with the specific ones:

```rust
use crate::output::{
    print_donations_table, print_donations_csv, print_donations_markdown,
    print_donations_xml, print_contributor_agg_table, print_contributor_agg_csv,
    print_contributor_agg_markdown, print_contributor_agg_xml,
    print_employer_agg_table, print_employer_agg_csv,
    print_employer_agg_markdown, print_employer_agg_xml,
    print_state_agg_table, print_state_agg_csv,
    print_state_agg_markdown, print_state_agg_xml,
    print_json, OutputFormat,
};
```
  </action>
  <verify>
Run `cargo check --workspace` -- entire workspace compiles clean.
Run `cargo clippy --workspace` -- no new warnings.
Run `cargo test --workspace` -- all tests pass (existing + new from Plan 01).
Run `cargo run -p capitoltraders_cli -- donations --help` -- shows help with all flags.
Run `cargo run -p capitoltraders_cli -- donations --db /tmp/nonexistent.db --politician "test"` -- should produce a DB open error (confirms wiring works).
  </verify>
  <done>
Donations CLI command fully functional with:
- 7 columns in individual listing (Date, Contributor, Employer, Amount, State, Committee, Cycle)
- Contributor aggregation view (8 columns: name, state, total, count, avg, max, first/last date)
- Employer aggregation view (5 columns: employer, total, count, avg, contributors)
- State aggregation view (5 columns: state, total, count, avg, contributors)
- All 5 output formats for each view mode (table, JSON, CSV, markdown, XML)
- CSV formula injection sanitization on contributor/employer fields
- Politician name resolution via find_politician_by_name
- Input validation for state, cycle, min-amount, top, group-by
- Helpful empty-result messages with hints
  </done>
</task>

</tasks>

<verification>
- `cargo check --workspace` compiles clean
- `cargo clippy --workspace` no new warnings
- `cargo test --workspace` all tests pass (464 existing + 8 new from Plan 01 = 472+)
- `capitoltraders donations --help` shows all flags with descriptions
- `capitoltraders donations --db trades.db --politician "Nancy Pelosi"` lists donations by amount (with real synced data)
- `capitoltraders donations --db trades.db --politician "Nancy Pelosi" --group-by employer --top 10` shows top 10 employers
- `capitoltraders donations --db trades.db --politician "Nancy Pelosi" --group-by contributor --top 10` shows top 10 contributors
- `capitoltraders donations --db trades.db --politician "Nancy Pelosi" --group-by state` shows geographic breakdown
- `capitoltraders donations --db trades.db --politician "Nancy Pelosi" --cycle 2024 --min-amount 1000` filters correctly
- All 5 output formats produce valid output (test with --output json, --output csv, --output md, --output xml)
</verification>

<success_criteria>
- `capitoltraders donations --db trades.db --politician "Nancy Pelosi"` lists individual contributions sorted by amount descending
- `--group-by employer` aggregates donations by employer with total amount and count
- `--group-by contributor` aggregates by contributor with total, count, date range
- `--group-by state` shows geographic breakdown
- `--top 10` limits results to top N
- Filters (--cycle, --min-amount, --employer, --state) narrow results correctly
- All 5 output formats work (table, JSON, CSV, markdown, XML)
- CSV output sanitizes fields against formula injection
- Invalid inputs produce clear error messages
- Empty results show helpful hints about running sync-fec and sync-donations first
</success_criteria>

<output>
After completion, create `.planning/phases/11-donations-cli-command/11-02-SUMMARY.md`
</output>
