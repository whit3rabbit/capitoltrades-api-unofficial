---
phase: 11-donations-cli-command
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - capitoltraders_lib/src/db.rs
  - capitoltraders_lib/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Individual donations can be queried by politician with optional filters (cycle, min-amount, employer, state, top N)"
    - "Donations can be aggregated by contributor with total amount, count, and date range"
    - "Donations can be aggregated by employer with total amount and count"
    - "Donations can be aggregated by state with total amount and count"
    - "NULL contributor names display as 'Unknown' in aggregations"
    - "All queries join through donation_sync_meta to link donations to politicians"
  artifacts:
    - path: "capitoltraders_lib/src/db.rs"
      provides: "DonationFilter, DonationRow, ContributorAggRow, EmployerAggRow, StateAggRow, query_donations, query_donations_by_contributor, query_donations_by_employer, query_donations_by_state"
      contains: "pub fn query_donations"
    - path: "capitoltraders_lib/src/lib.rs"
      provides: "Re-exports for DonationFilter, DonationRow, ContributorAggRow, EmployerAggRow, StateAggRow"
      contains: "DonationFilter"
  key_links:
    - from: "capitoltraders_lib/src/db.rs"
      to: "schema/sqlite.sql"
      via: "SQL queries joining donations, donation_sync_meta, politicians, fec_committees"
      pattern: "JOIN donation_sync_meta dsm ON d\\.committee_id = dsm\\.committee_id"
---

<objective>
Add donation query methods and types to the DB layer.

Purpose: Provide the data access foundation for the donations CLI command. Individual donation listing plus three aggregation modes (contributor, employer, state) with dynamic filter composition.

Output: DonationFilter/DonationRow/aggregation row types and 4 query methods in db.rs, re-exported via lib.rs.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-donations-cli-command/11-RESEARCH.md
@capitoltraders_lib/src/db.rs
@capitoltraders_lib/src/lib.rs
@schema/sqlite.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Donation filter and row types + individual query</name>
  <files>capitoltraders_lib/src/db.rs, capitoltraders_lib/src/lib.rs</files>
  <action>
Add the following types and methods to db.rs, placing them after the existing `count_donations_for_politician` method (around line 2487) and before the `PoliticianStatsRow` struct:

**Types to add:**

1. `DonationFilter` -- filter struct with these fields:
   - `politician_id: Option<String>` -- resolved politician ID
   - `cycle: Option<i32>` -- election cycle year
   - `min_amount: Option<f64>` -- minimum contribution amount
   - `employer: Option<String>` -- employer name (LIKE match)
   - `contributor_state: Option<String>` -- validated 2-letter state code
   - `limit: Option<i64>` -- max results (for --top N)
   Derive `Debug, Default`.

2. `DonationRow` -- individual donation row with these fields (all String or numeric, ready for output):
   - `sub_id: String`
   - `contributor_name: String` -- COALESCE with 'Unknown'
   - `contributor_employer: String` -- COALESCE with ''
   - `contributor_occupation: String` -- COALESCE with ''
   - `contributor_state: String` -- COALESCE with ''
   - `amount: f64`
   - `date: String` -- contribution_receipt_date
   - `cycle: i64` -- election_cycle
   - `committee_name: String` -- from fec_committees JOIN
   - `committee_designation: String` -- P/D/etc from fec_committees
   - `politician_name: String` -- first_name || ' ' || last_name
   Derive `Debug, Clone, Serialize`.

3. `ContributorAggRow` -- aggregated by contributor:
   - `contributor_name: String`
   - `contributor_state: String`
   - `total_amount: f64`
   - `donation_count: i64`
   - `avg_amount: f64`
   - `max_donation: f64`
   - `first_donation: String` -- MIN date
   - `last_donation: String` -- MAX date
   Derive `Debug, Clone, Serialize`.

4. `EmployerAggRow` -- aggregated by employer:
   - `employer: String`
   - `total_amount: f64`
   - `donation_count: i64`
   - `avg_amount: f64`
   - `contributor_count: i64` -- COUNT(DISTINCT contributor_name)
   Derive `Debug, Clone, Serialize`.

5. `StateAggRow` -- aggregated by state:
   - `state: String`
   - `total_amount: f64`
   - `donation_count: i64`
   - `avg_amount: f64`
   - `contributor_count: i64` -- COUNT(DISTINCT contributor_name)
   Derive `Debug, Clone, Serialize`.

**Method: `query_donations`**

Add `pub fn query_donations(&self, filter: &DonationFilter) -> Result<Vec<DonationRow>, DbError>` to the `impl Db` block.

SQL pattern:
```sql
SELECT
    d.sub_id,
    COALESCE(d.contributor_name, 'Unknown') as contributor_name,
    COALESCE(d.contributor_employer, '') as contributor_employer,
    COALESCE(d.contributor_occupation, '') as contributor_occupation,
    COALESCE(d.contributor_state, '') as contributor_state,
    d.contribution_receipt_amount,
    COALESCE(d.contribution_receipt_date, '') as contribution_receipt_date,
    COALESCE(d.election_cycle, 0) as election_cycle,
    COALESCE(fc.name, '') as committee_name,
    COALESCE(fc.designation, '') as designation,
    p.first_name || ' ' || p.last_name AS politician_name
FROM donations d
JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id
JOIN politicians p ON dsm.politician_id = p.politician_id
LEFT JOIN fec_committees fc ON d.committee_id = fc.committee_id
```

Use the dynamic WHERE clause builder pattern from `query_trades()`:
- Start with `WHERE 1=1`
- Append clauses for each non-None filter field using parameterized queries (`?N` notation)
- politician_id: `dsm.politician_id = ?N`
- cycle: `d.election_cycle = ?N`
- min_amount: `d.contribution_receipt_amount >= ?N`
- employer: `d.contributor_employer LIKE ?N` (wrap in `%..%`)
- contributor_state: `d.contributor_state = ?N`

Order by `d.contribution_receipt_amount DESC`.
Apply LIMIT if filter.limit is Some.

Map rows using positional `row.get(N)?` calls (not column names -- follow the existing query_trades pattern).

**lib.rs re-exports:**

Add to the `pub use db::{...}` block in lib.rs:
`DonationFilter, DonationRow, ContributorAggRow, EmployerAggRow, StateAggRow`
  </action>
  <verify>
Run `cargo check -p capitoltraders_lib` -- should compile without errors.
Run `cargo clippy -p capitoltraders_lib` -- should produce no new warnings.
  </verify>
  <done>DonationFilter and DonationRow types exist. query_donations method compiles and follows the dynamic WHERE clause pattern. All 5 types are re-exported from lib.rs.</done>
</task>

<task type="auto">
  <name>Task 2: Aggregation query methods and unit tests</name>
  <files>capitoltraders_lib/src/db.rs</files>
  <action>
Add three aggregation query methods to the `impl Db` block, plus unit tests for all four query methods.

**Method: `query_donations_by_contributor`**

`pub fn query_donations_by_contributor(&self, filter: &DonationFilter) -> Result<Vec<ContributorAggRow>, DbError>`

SQL:
```sql
SELECT
    COALESCE(d.contributor_name, 'Unknown') as contributor_name,
    COALESCE(d.contributor_state, '') as contributor_state,
    SUM(d.contribution_receipt_amount) as total_amount,
    COUNT(*) as donation_count,
    AVG(d.contribution_receipt_amount) as avg_amount,
    MAX(d.contribution_receipt_amount) as max_donation,
    MIN(d.contribution_receipt_date) as first_donation,
    MAX(d.contribution_receipt_date) as last_donation
FROM donations d
JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id
```

Same dynamic WHERE clause pattern as query_donations (all filters apply).
GROUP BY `COALESCE(d.contributor_name, 'Unknown'), COALESCE(d.contributor_state, '')`.
ORDER BY `total_amount DESC`.
Apply LIMIT if filter.limit is Some.

**Method: `query_donations_by_employer`**

`pub fn query_donations_by_employer(&self, filter: &DonationFilter) -> Result<Vec<EmployerAggRow>, DbError>`

SQL:
```sql
SELECT
    COALESCE(d.contributor_employer, 'Unknown') as employer,
    SUM(d.contribution_receipt_amount) as total_amount,
    COUNT(*) as donation_count,
    AVG(d.contribution_receipt_amount) as avg_amount,
    COUNT(DISTINCT d.contributor_name) as contributor_count
FROM donations d
JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id
```

Same dynamic WHERE clause pattern. GROUP BY `COALESCE(d.contributor_employer, 'Unknown')`.
ORDER BY `total_amount DESC`. Apply LIMIT.

**Method: `query_donations_by_state`**

`pub fn query_donations_by_state(&self, filter: &DonationFilter) -> Result<Vec<StateAggRow>, DbError>`

SQL:
```sql
SELECT
    COALESCE(d.contributor_state, 'Unknown') as state,
    SUM(d.contribution_receipt_amount) as total_amount,
    COUNT(*) as donation_count,
    AVG(d.contribution_receipt_amount) as avg_amount,
    COUNT(DISTINCT d.contributor_name) as contributor_count
FROM donations d
JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id
```

Same dynamic WHERE clause pattern. GROUP BY `COALESCE(d.contributor_state, 'Unknown')`.
ORDER BY `total_amount DESC`. Apply LIMIT.

**Helper function for shared WHERE clause logic:**

To avoid code duplication across the 4 query methods, create a private helper:

```rust
fn build_donation_where_clause(filter: &DonationFilter) -> (String, Vec<Box<dyn rusqlite::types::ToSql>>) {
    let mut clauses = Vec::new();
    let mut params: Vec<Box<dyn rusqlite::types::ToSql>> = Vec::new();
    let mut idx = 1;
    // ... build clauses for each filter field
    // return (where_clause_string, params)
}
```

Call this helper from all 4 query methods instead of duplicating the clause-building logic.

**Unit tests:**

Add to the `#[cfg(test)] mod tests` block at the bottom of db.rs. Use the existing `test_db()` or `setup_donation_test_db()` pattern (open in-memory, init schema, insert test data).

Test setup helper `setup_donation_query_test_db()`:
1. Open in-memory DB, call `db.init()`
2. Insert a politician (politician_id = "P000001", first_name = "Nancy", last_name = "Pelosi", state = "CA", party = "Democrat")
3. Insert fec_committees entries (committee_id = "C00001", name = "Pelosi for Congress", designation = "P")
4. Insert donation_sync_meta entry (politician_id = "P000001", committee_id = "C00001")
5. Insert 5-6 test donations with varying: contributor_name (some NULL), contributor_employer, contributor_state, amounts, dates, election_cycle values

Tests (8 total):
1. `test_query_donations_no_filter` -- returns all donations sorted by amount DESC
2. `test_query_donations_with_politician_filter` -- filters by politician_id
3. `test_query_donations_with_cycle_filter` -- filters by election_cycle
4. `test_query_donations_with_min_amount` -- filters by minimum amount
5. `test_query_donations_with_limit` -- respects --top N limit
6. `test_query_donations_by_contributor` -- groups correctly, sums amounts, counts donations
7. `test_query_donations_by_employer` -- groups by employer, counts distinct contributors
8. `test_query_donations_by_state` -- groups by state, counts distinct contributors

Each test should assert:
- Correct number of result rows
- Correct sort order (total_amount DESC for aggregations, amount DESC for individual)
- COALESCE handling of NULL values (contributor_name = "Unknown" when NULL in source)
- Filter actually reduces result set
  </action>
  <verify>
Run `cargo test -p capitoltraders_lib query_donations` -- all 8 new tests should pass.
Run `cargo clippy -p capitoltraders_lib` -- no new warnings.
Run `cargo test --workspace` -- all existing tests still pass.
  </verify>
  <done>Three aggregation query methods exist. Shared WHERE clause helper avoids duplication. 8 unit tests pass covering individual queries, all three aggregation modes, filter application, NULL handling, and sort order.</done>
</task>

</tasks>

<verification>
- `cargo check -p capitoltraders_lib` compiles clean
- `cargo test -p capitoltraders_lib query_donations` -- all 8 new tests pass
- `cargo clippy -p capitoltraders_lib` -- no new warnings
- `cargo test --workspace` -- all 464+ existing tests still pass plus 8 new ones
</verification>

<success_criteria>
- DonationFilter struct exists with politician_id, cycle, min_amount, employer, contributor_state, limit fields
- DonationRow struct exists with all 11 fields (sub_id through politician_name)
- ContributorAggRow, EmployerAggRow, StateAggRow structs exist
- query_donations returns individual donations with dynamic filtering
- query_donations_by_contributor returns contributor-grouped aggregations
- query_donations_by_employer returns employer-grouped aggregations
- query_donations_by_state returns state-grouped aggregations
- All queries JOIN through donation_sync_meta (not direct politician_id on donations)
- NULL values handled via COALESCE
- 8 new tests pass
- All types re-exported from lib.rs
</success_criteria>

<output>
After completion, create `.planning/phases/11-donations-cli-command/11-01-SUMMARY.md`
</output>
