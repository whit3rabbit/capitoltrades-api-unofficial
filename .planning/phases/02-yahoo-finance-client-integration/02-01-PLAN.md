---
phase: 02-yahoo-finance-client-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - capitoltraders_lib/Cargo.toml
  - capitoltraders_lib/src/yahoo.rs
  - capitoltraders_lib/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "YahooClient can fetch adjusted close price for any ticker on any historical date"
    - "YahooClient can fetch current price for any ticker"
    - "chrono::NaiveDate converts to time::OffsetDateTime and back without timezone issues"
    - "Weekend/holiday dates return nearest prior trading day's price"
    - "Invalid ticker symbols return None, not errors"
  artifacts:
    - path: "capitoltraders_lib/src/yahoo.rs"
      provides: "YahooClient wrapper, YahooError enum, time/chrono conversion helpers, DashMap price cache"
      min_lines: 150
    - path: "capitoltraders_lib/Cargo.toml"
      provides: "yahoo_finance_api and time dependencies"
      contains: "yahoo_finance_api"
  key_links:
    - from: "capitoltraders_lib/src/yahoo.rs"
      to: "yahoo_finance_api::YahooConnector"
      via: "YahooClient.connector field"
      pattern: "YahooConnector"
    - from: "capitoltraders_lib/src/yahoo.rs"
      to: "chrono::NaiveDate"
      via: "date_to_offset_datetime conversion"
      pattern: "date_to_offset_datetime"
    - from: "capitoltraders_lib/src/lib.rs"
      to: "capitoltraders_lib/src/yahoo.rs"
      via: "pub mod yahoo"
      pattern: "pub mod yahoo"
---

<objective>
Implement YahooClient wrapper in capitoltraders_lib that fetches historical and current stock prices from Yahoo Finance, with chrono/time conversion helpers, DashMap price caching, weekend/holiday fallback, and graceful invalid ticker handling.

Purpose: Phase 2 of the Yahoo Finance enrichment milestone. The YahooClient is the integration layer that all downstream phases (ticker validation, price enrichment pipeline, portfolio calculator) depend on for price data.

Output: Working yahoo.rs module with YahooClient struct, YahooError enum, time/chrono conversion functions, and comprehensive test suite.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-yahoo-finance-client-integration/02-RESEARCH.md
@.planning/phases/01-schema-migration-data-model/01-01-SUMMARY.md
@capitoltraders_lib/src/lib.rs
@capitoltraders_lib/src/error.rs
@capitoltraders_lib/Cargo.toml
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies, YahooError enum, and time/chrono conversion helpers with tests</name>
  <files>
    capitoltraders_lib/Cargo.toml
    capitoltraders_lib/src/yahoo.rs
    capitoltraders_lib/src/lib.rs
  </files>
  <action>
**Dependencies (Cargo.toml):**
Add to capitoltraders_lib/Cargo.toml [dependencies]:
```toml
yahoo_finance_api = "4.1.0"
time = { version = "0.3", features = ["macros"] }
```

**Module registration (lib.rs):**
Add `pub mod yahoo;` to lib.rs module list. Add `pub use yahoo::{YahooClient, YahooError};` to the pub use block.

**yahoo.rs -- Error types:**
Create `capitoltraders_lib/src/yahoo.rs` with:

1. `YahooError` enum using thiserror with variants:
   - `RateLimited` -- Yahoo Finance returned HTTP 429
   - `InvalidDate(String)` -- date conversion failed (include date string in message)
   - `ParseFailed(String)` -- response parsing failed
   - `Upstream(yahoo_finance_api::YahooError)` -- passthrough of upstream errors

2. Implement `From<yahoo_finance_api::YahooError>` for `YahooError` that maps `YahooError::EmptyDataSet` (the upstream crate's "no quotes" variant) to a transparent passthrough rather than swallowing it.

**yahoo.rs -- Conversion helpers:**

3. `pub fn date_to_offset_datetime(date: chrono::NaiveDate) -> Result<time::OffsetDateTime, YahooError>`:
   - Convert NaiveDate to NaiveDateTime at midnight (00:00:00) via `date.and_hms_opt(0, 0, 0)`
   - Convert to UTC timestamp via `.and_utc().timestamp()`
   - Convert to `time::OffsetDateTime::from_unix_timestamp(timestamp)`
   - Return `YahooError::InvalidDate` on failure

4. `pub fn offset_datetime_to_date(dt: time::OffsetDateTime) -> chrono::NaiveDate`:
   - Extract unix timestamp, convert back to NaiveDate
   - Use `chrono::DateTime::from_timestamp(dt.unix_timestamp(), 0).unwrap().date_naive()`

**Tests (RED then GREEN):**

Write these tests FIRST (they will fail until implementation exists):

- `test_date_to_offset_datetime_basic`: Convert 2024-01-15 to OffsetDateTime, verify year/month/day match, hour/minute/second are 0, offset is UTC
- `test_date_to_offset_datetime_epoch`: Convert 1970-01-01, verify unix timestamp is 0
- `test_date_to_offset_datetime_recent`: Convert 2025-12-31, verify roundtrip
- `test_offset_datetime_to_date_basic`: Convert a known OffsetDateTime back to NaiveDate, verify match
- `test_roundtrip_conversion`: date -> OffsetDateTime -> date, verify equality for several dates (2024-01-01, 2024-06-15, 2024-12-31, 2020-02-29 leap day)
- `test_yahoo_error_display`: Verify Display impl produces readable messages for each variant

Do NOT write tests that require network access in this task. All tests must be pure unit tests.
  </action>
  <verify>
```bash
cargo check -p capitoltraders_lib
cargo test -p capitoltraders_lib yahoo -- --nocapture
cargo clippy -p capitoltraders_lib -- -D warnings
```
All conversion tests pass. No clippy warnings.
  </verify>
  <done>
- yahoo_finance_api and time dependencies compile
- YahooError enum has 4 variants with Display/Debug
- date_to_offset_datetime converts NaiveDate to OffsetDateTime at UTC midnight
- offset_datetime_to_date converts back without data loss
- Roundtrip conversion preserves date for normal dates and leap days
- All tests pass, no clippy warnings
  </done>
</task>

<task type="auto">
  <name>Task 2: YahooClient struct with price fetching, weekend fallback, caching, and integration tests</name>
  <files>
    capitoltraders_lib/src/yahoo.rs
  </files>
  <action>
**YahooClient struct:**

Add to yahoo.rs:

1. `YahooClient` struct with fields:
   - `connector: yahoo_finance_api::YahooConnector`
   - `cache: Arc<DashMap<(String, chrono::NaiveDate), Option<f64>>>` -- keyed by (ticker, date), value is Option price (None = confirmed no data)

2. `YahooClient::new() -> Result<Self, YahooError>`:
   - Create `YahooConnector::new()` (uses default reqwest client)
   - Initialize empty DashMap cache
   - Return Ok(Self { connector, cache })

3. Derive `Clone` for `YahooClient` (YahooConnector is Arc-backed, DashMap is Arc-wrapped)

**get_price_on_date method:**

4. `pub async fn get_price_on_date(&self, ticker: &str, date: NaiveDate) -> Result<Option<f64>, YahooError>`:
   - Check cache first: if `(ticker, date)` exists in cache, return cached value
   - Convert date to OffsetDateTime range: start = midnight UTC on date, end = start + 1 day
   - Call `self.connector.get_quote_history(ticker, start, end).await`
   - On upstream `EmptyDataSet` error: cache None, return Ok(None) -- this handles invalid tickers gracefully
   - On success: extract `quotes()`, take first quote's `adjclose`, cache the result, return Ok(Some(price))
   - On other errors: map to YahooError and propagate (do NOT cache errors)

**get_price_on_date_with_fallback method (weekend/holiday handling):**

5. `pub async fn get_price_on_date_with_fallback(&self, ticker: &str, date: NaiveDate) -> Result<Option<f64>, YahooError>`:
   - First try `get_price_on_date(ticker, date)`
   - If result is Ok(None) and date falls on Saturday or Sunday (use `date.weekday()`), try the prior Friday
   - If still Ok(None), expand search window: fetch 7-day range ending on `date`, take the last (most recent) quote's adjclose
   - Cache the original (ticker, date) -> found price so subsequent lookups don't repeat the fallback
   - If no data found in 7-day window either, return Ok(None) -- ticker is genuinely invalid or has no data

**get_current_price method:**

6. `pub async fn get_current_price(&self, ticker: &str) -> Result<Option<f64>, YahooError>`:
   - Use today's date via `chrono::Utc::now().date_naive()`
   - Call `get_price_on_date_with_fallback(ticker, today)` -- this handles weekends (market closed) by falling back to Friday
   - Return the result

**cache_len helper (for testing):**

7. `pub fn cache_len(&self) -> usize` -- returns number of cached entries

**Tests (RED then GREEN):**

These tests use wiremock to mock HTTP responses. Do NOT make real network calls.

IMPORTANT: Before writing wiremock tests, check how yahoo_finance_api constructs its HTTP client. The crate's `YahooConnector::new()` creates its own reqwest client internally. For unit testing, you may need to either:
- (a) Create a `YahooClient::with_connector(connector)` constructor that accepts a pre-built YahooConnector, OR
- (b) Test at the integration level where the behavior can be verified against the public API

If wiremock is not feasible because YahooConnector does not expose base URL configuration, then:
- Write pure unit tests for conversion helpers and error mapping (already done in Task 1)
- Write tests that verify the caching logic using a mock/fake approach:
  - Create a `#[cfg(test)] mod tests` block with a helper that bypasses the connector
  - Or use `mockall` if already in dev-dependencies

Concrete tests to write:

- `test_yahoo_client_creation`: Verify `YahooClient::new()` returns Ok
- `test_cache_deduplication`: Call get_price_on_date twice for same (ticker, date), verify cache_len is 1 (not 2), demonstrating cache hit
- `test_cache_stores_none`: Verify that when a ticker returns no data, None is cached (cache_len increments)
- `test_weekend_detection`: Verify that a Saturday date (use chrono::Weekday check) triggers fallback logic. Test the weekday detection code path, not the full HTTP flow.
- `test_get_current_price_delegates`: Verify get_current_price calls get_price_on_date_with_fallback with today's date

If wiremock integration IS feasible (YahooConnector accepts custom reqwest client or base URL):
- `test_historical_price_returns_adjclose`: Mock Yahoo Finance response with known OHLCV data, verify adjclose is returned
- `test_invalid_ticker_returns_none`: Mock 404/empty response, verify Ok(None)
- `test_rate_limited_returns_error`: Mock 429 response, verify YahooError::RateLimited

Add `wiremock = "0.6"` to dev-dependencies if not already present. Also add `tokio = { workspace = true, features = ["test-util"] }` to dev-dependencies if needed for `#[tokio::test]`.
  </action>
  <verify>
```bash
cargo test -p capitoltraders_lib yahoo -- --nocapture
cargo test --workspace
cargo clippy --workspace -- -D warnings
```
All yahoo module tests pass. Full workspace test suite passes (no regressions). No clippy warnings.
  </verify>
  <done>
- YahooClient::new() creates working client with empty cache
- get_price_on_date returns Option<f64> (Some for valid ticker/date, None for invalid/missing)
- get_price_on_date uses adjclose (not raw close) from quotes
- get_price_on_date_with_fallback handles weekend dates by checking prior Friday and 7-day window
- get_current_price fetches today's price using fallback logic
- Invalid tickers return Ok(None), not Err
- Cache prevents duplicate API calls for same (ticker, date) pair
- Cache stores None results for invalid tickers (prevents re-fetching)
- All workspace tests pass (298+ baseline), no clippy warnings
  </done>
</task>

</tasks>

<feature>
  <name>Yahoo Finance Client Integration</name>
  <files>capitoltraders_lib/src/yahoo.rs, capitoltraders_lib/src/yahoo.rs (test module)</files>
  <behavior>
    Expected behavior in testable terms:

    Time/chrono conversion:
    - NaiveDate(2024, 1, 15) -> OffsetDateTime at 2024-01-15T00:00:00Z
    - OffsetDateTime(2024-01-15T00:00:00Z) -> NaiveDate(2024, 1, 15)
    - Roundtrip preserves date identity for normal and leap-year dates

    Price fetching:
    - get_price_on_date("AAPL", 2024-01-15) -> Ok(Some(185.xx)) (trading day)
    - get_price_on_date("INVALIDTICKER", any_date) -> Ok(None) (no error)
    - get_price_on_date("AAPL", Saturday) -> Ok(None) (no fallback in base method)
    - get_price_on_date_with_fallback("AAPL", Saturday) -> Ok(Some(Friday's price))
    - get_current_price("AAPL") -> Ok(Some(current price))

    Caching:
    - Two calls with same (ticker, date) -> only one upstream API call
    - None results cached to prevent re-fetching invalid tickers

    Error handling:
    - HTTP 429 -> YahooError::RateLimited
    - Parse failure -> YahooError::ParseFailed
    - Invalid date -> YahooError::InvalidDate
    - EmptyDataSet -> Ok(None) (not an error)
  </behavior>
  <implementation>
    1. Add yahoo_finance_api = "4.1.0" and time = "0.3" to Cargo.toml
    2. Create yahoo.rs with YahooError enum, conversion helpers, YahooClient struct
    3. Implement get_price_on_date with cache-first, upstream-fetch, adjclose extraction
    4. Implement weekend fallback via get_price_on_date_with_fallback
    5. Implement get_current_price as thin wrapper over fallback method
    6. Register module in lib.rs
  </implementation>
</feature>

<verification>
1. `cargo check --workspace` -- all crates compile with new dependencies
2. `cargo test -p capitoltraders_lib yahoo` -- all yahoo module tests pass
3. `cargo test --workspace` -- no regressions (298+ tests pass)
4. `cargo clippy --workspace -- -D warnings` -- no warnings
5. Verify yahoo.rs exports: YahooClient, YahooError, date_to_offset_datetime, offset_datetime_to_date
</verification>

<success_criteria>
- yahoo_finance_api 4.1.0 and time 0.3 dependencies added and compiling
- YahooError enum with RateLimited, InvalidDate, ParseFailed, Upstream variants
- Bidirectional NaiveDate/OffsetDateTime conversion at UTC midnight, roundtrip-verified
- YahooClient with get_price_on_date (uses adjclose), get_price_on_date_with_fallback (weekend handling), get_current_price
- DashMap cache prevents duplicate API calls, stores None for invalid tickers
- Invalid ticker symbols return Ok(None), not errors
- All workspace tests pass, no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-yahoo-finance-client-integration/02-01-SUMMARY.md`
</output>
