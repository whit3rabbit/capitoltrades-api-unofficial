---
phase: 10-donation-sync-pipeline
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - capitoltraders_lib/src/db.rs
  - capitoltraders_lib/src/openfec/types.rs
autonomous: true

must_haves:
  truths:
    - "Donations can be inserted with ON CONFLICT IGNORE deduplication by sub_id"
    - "Cursor state (last_index, last_contribution_receipt_date) can be loaded for resume"
    - "Cursor state and donations are saved atomically in a single transaction"
    - "Completed syncs are marked with a timestamp to avoid redundant API calls"
    - "A politician can be found by partial name match returning their politician_id"
    - "Donation count for a politician is queryable for progress reporting"
    - "ScheduleAQuery supports min_date and max_date for incremental sync filtering"
  artifacts:
    - path: "capitoltraders_lib/src/db.rs"
      provides: "Donation sync DB operations"
      contains: "insert_donation"
    - path: "capitoltraders_lib/src/openfec/types.rs"
      provides: "Extended ScheduleAQuery with date filters"
      contains: "min_date"
  key_links:
    - from: "capitoltraders_lib/src/db.rs"
      to: "schema/sqlite.sql"
      via: "SQL statements matching donations and donation_sync_meta table schemas"
      pattern: "INSERT OR IGNORE INTO donations"
    - from: "capitoltraders_lib/src/openfec/types.rs"
      to: "capitoltraders_lib/src/openfec/client.rs"
      via: "to_query_pairs() produces parameters consumed by get_schedule_a()"
      pattern: "min_date.*to_query_pairs"
---

<objective>
Add all database operations needed for the donation sync pipeline and extend ScheduleAQuery with date range filtering.

Purpose: Plan 02 (the sync-donations CLI pipeline) depends on these DB methods for inserting donations, persisting cursor state for resume, and querying politician information. These are testable I/O operations with defined inputs and outputs, making them ideal TDD candidates.

Output: 6 new DB methods with unit tests, 2 new ScheduleAQuery fields with tests. All existing 449 tests continue to pass.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-donation-sync-pipeline/10-RESEARCH.md
@.planning/phases/09-politician-to-committee-mapping-schema-v3/09-01-SUMMARY.md
@schema/sqlite.sql
@capitoltraders_lib/src/db.rs
@capitoltraders_lib/src/openfec/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add donation sync DB methods with unit tests</name>
  <files>capitoltraders_lib/src/db.rs</files>
  <action>
Add 6 new public methods to the Db impl block in db.rs, following the existing pattern from price enrichment and committee operations:

**1. insert_donation(&self, contribution: &Contribution, committee_id: &str, cycle: Option<i32>) -> Result<bool, DbError>**
- INSERT OR IGNORE INTO donations (sub_id, committee_id, contributor_name, contributor_employer, contributor_occupation, contributor_state, contributor_city, contributor_zip, contribution_receipt_amount, contribution_receipt_date, election_cycle, memo_text, receipt_type)
- The Contribution type is from `crate::openfec::types::Contribution`. The committee_id comes from the caller (not from contribution.committee which may be None or have a different committee_id).
- If contribution.sub_id is None, return Ok(false) with no insert (skip NULL sub_id per research recommendation).
- Return Ok(true) if row was inserted (changes() > 0), Ok(false) if duplicate.

**2. load_sync_cursor(&self, politician_id: &str, committee_id: &str) -> Result<Option<(i64, String)>, DbError>**
- SELECT last_index, last_contribution_receipt_date FROM donation_sync_meta WHERE politician_id = ?1 AND committee_id = ?2
- Use .optional()? to return None if no cursor saved yet.

**3. save_sync_cursor_with_donations(&self, politician_id: &str, committee_id: &str, contributions: &[Contribution], cycle: Option<i32>, last_index: i64, last_date: &str) -> Result<usize, DbError>**
- CRITICAL: This wraps donation inserts AND cursor update in a single unchecked_transaction to prevent cursor state desync (Pitfall 1 from research).
- For each contribution: call insert_donation logic (inline the INSERT OR IGNORE, skip NULL sub_id).
- After all inserts: INSERT OR REPLACE INTO donation_sync_meta (politician_id, committee_id, last_index, last_contribution_receipt_date, last_synced_at, total_synced) VALUES (?1, ?2, ?3, ?4, datetime('now'), COALESCE((SELECT total_synced FROM donation_sync_meta WHERE politician_id = ?1 AND committee_id = ?2), 0) + ?5)
- The ?5 param is the count of actually inserted donations (not skipped).
- tx.commit()? at end.
- Return the count of inserted donations.

**4. mark_sync_completed(&self, politician_id: &str, committee_id: &str) -> Result<(), DbError>**
- INSERT OR REPLACE INTO donation_sync_meta (politician_id, committee_id, last_index, last_contribution_receipt_date, last_synced_at, total_synced) VALUES (?1, ?2, NULL, NULL, datetime('now'), COALESCE((SELECT total_synced FROM donation_sync_meta WHERE politician_id = ?1 AND committee_id = ?2), 0))
- Setting last_index to NULL signals "sync completed, no more pages" so subsequent runs can check is_sync_completed.

**5. find_politician_by_name(&self, name: &str) -> Result<Vec<(String, String)>, DbError>**
- SELECT politician_id, first_name || ' ' || last_name AS full_name FROM politicians WHERE (first_name || ' ' || last_name) LIKE ?1
- Parameter: format!("%{}%", name)
- Returns Vec of (politician_id, full_name) tuples. Caller handles disambiguation if multiple matches.

**6. count_donations_for_politician(&self, politician_id: &str) -> Result<i64, DbError>**
- SELECT COUNT(*) FROM donations d JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id WHERE dsm.politician_id = ?1
- This joins through donation_sync_meta to link donations (which only have committee_id) to politicians.

**Unit tests (add in #[cfg(test)] mod tests block):**

Tests should use the test_db() in-memory pattern already established. Insert test politicians and fec_mappings data as setup.

- test_insert_donation_new: Insert a Contribution, verify returns true, query donations table to confirm row.
- test_insert_donation_duplicate: Insert same sub_id twice, verify second returns false (no duplicate).
- test_insert_donation_null_sub_id: Insert Contribution with sub_id: None, verify returns false (skipped).
- test_load_sync_cursor_none: Query cursor for non-existent politician/committee, verify None.
- test_save_and_load_cursor: Save cursor via save_sync_cursor_with_donations, then load_sync_cursor, verify values match.
- test_save_cursor_increments_total: Save twice with different contributions, verify total_synced accumulates.
- test_save_cursor_transaction_atomicity: Verify that contributions and cursor are in same transaction (both exist after save).
- test_mark_sync_completed: Mark completed, then load cursor -- last_index should be None.
- test_find_politician_by_name_found: Insert politician "Nancy Pelosi", search "Pelosi", verify match.
- test_find_politician_by_name_multiple: Insert "Pelosi" and "Pelosi Jr", search "Pelosi", verify both returned.
- test_find_politician_by_name_not_found: Search non-existent name, verify empty Vec.
- test_count_donations_for_politician: Insert donations via save_sync_cursor_with_donations, verify count.

Note: The Contribution struct is from crate::openfec::types. You'll need to add `use crate::openfec::types::Contribution;` in the test module. For creating test Contribution instances, all fields are Option except sub_id, so most can be None.
  </action>
  <verify>
cargo test -p capitoltraders_lib -- donation --nocapture
cargo test --workspace
cargo clippy --workspace
  </verify>
  <done>All 12 new donation DB tests pass. All 449+ existing tests pass. Zero clippy warnings. insert_donation skips NULL sub_id. save_sync_cursor_with_donations is transactional.</done>
</task>

<task type="auto">
  <name>Task 2: Extend ScheduleAQuery with min_date and max_date fields</name>
  <files>capitoltraders_lib/src/openfec/types.rs</files>
  <action>
Add two new optional fields to the ScheduleAQuery struct for incremental sync date filtering:

**Struct changes:**
```rust
pub struct ScheduleAQuery {
    // ... existing fields ...
    pub min_date: Option<String>,  // NEW: Filter contributions on or after this date (YYYY-MM-DD)
    pub max_date: Option<String>,  // NEW: Filter contributions on or before this date (YYYY-MM-DD)
}
```

**Builder methods:**
```rust
pub fn with_min_date(mut self, date: &str) -> Self {
    self.min_date = Some(date.to_string());
    self
}

pub fn with_max_date(mut self, date: &str) -> Self {
    self.max_date = Some(date.to_string());
    self
}
```

**to_query_pairs() additions (at end, before closing brace):**
```rust
if let Some(ref min_date) = self.min_date {
    params.push(("min_date".to_string(), min_date.clone()));
}
if let Some(ref max_date) = self.max_date {
    params.push(("max_date".to_string(), max_date.clone()));
}
```

**Unit tests (add to existing #[cfg(test)] mod tests block):**

- test_schedule_a_query_with_min_date: Build query with .with_min_date("2024-01-01"), verify "min_date" in pairs.
- test_schedule_a_query_with_date_range: Build query with both .with_min_date("2024-01-01").with_max_date("2024-12-31"), verify both present in pairs.
- test_schedule_a_query_dates_with_committee: Build with committee_id + min_date + per_page, verify all 3 params present. This simulates the actual incremental sync query pattern.
  </action>
  <verify>
cargo test -p capitoltraders_lib -- schedule_a_query --nocapture
cargo test --workspace
cargo clippy --workspace
  </verify>
  <done>3 new ScheduleAQuery tests pass. ScheduleAQuery Default still initializes min_date and max_date to None. Existing 6 query builder tests still pass. All workspace tests pass. Zero clippy warnings.</done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass (449 existing + 15 new = 464+)
2. `cargo clippy --workspace` -- zero warnings
3. `cargo check --workspace` -- compiles clean
4. Verify insert_donation handles NULL sub_id gracefully (returns false, no DB write)
5. Verify save_sync_cursor_with_donations uses unchecked_transaction (cursor + donations atomic)
6. Verify mark_sync_completed sets last_index to NULL (signals completion)
7. Verify ScheduleAQuery::default() has min_date: None, max_date: None (no breaking change)
</verification>

<success_criteria>
- 6 new DB methods exist and are public
- 12 new DB unit tests pass
- 3 new ScheduleAQuery unit tests pass
- save_sync_cursor_with_donations wraps inserts + cursor in single transaction
- insert_donation returns false for NULL sub_id (no panic, no insert)
- All existing 449 tests continue to pass
- Zero clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/10-donation-sync-pipeline/10-01-SUMMARY.md`
</output>
