---
phase: 10-donation-sync-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - capitoltraders_cli/src/commands/sync_donations.rs
  - capitoltraders_cli/src/commands/mod.rs
  - capitoltraders_cli/src/main.rs
autonomous: true

must_haves:
  truths:
    - "sync-donations command fetches Schedule A contributions for a politician's committees and stores them in SQLite"
    - "Sync resumes from where it left off when interrupted and re-run (keyset cursor persisted per committee)"
    - "Duplicate donations are silently ignored via ON CONFLICT (sub_id deduplication at DB layer)"
    - "Progress is displayed during sync showing donations synced count and elapsed time"
    - "Circuit breaker halts sync after 5 consecutive 429 errors with informative message"
    - "403 (invalid API key) causes immediate failure with helpful message"
    - "Missing committees triggers CommitteeResolver resolution before donation fetch"
  artifacts:
    - path: "capitoltraders_cli/src/commands/sync_donations.rs"
      provides: "Donation sync pipeline CLI command"
      contains: "sync_donations"
    - path: "capitoltraders_cli/src/commands/mod.rs"
      provides: "Module registration"
      contains: "pub mod sync_donations"
    - path: "capitoltraders_cli/src/main.rs"
      provides: "CLI dispatch for SyncDonations variant"
      contains: "SyncDonations"
  key_links:
    - from: "capitoltraders_cli/src/commands/sync_donations.rs"
      to: "capitoltraders_lib/src/db.rs"
      via: "DB methods for donation insert and cursor management"
      pattern: "save_sync_cursor_with_donations|load_sync_cursor|mark_sync_completed"
    - from: "capitoltraders_cli/src/commands/sync_donations.rs"
      to: "capitoltraders_lib/src/openfec/client.rs"
      via: "OpenFecClient for Schedule A API calls"
      pattern: "get_schedule_a"
    - from: "capitoltraders_cli/src/commands/sync_donations.rs"
      to: "capitoltraders_lib/src/committee.rs"
      via: "CommitteeResolver for resolving politician committees"
      pattern: "resolve_committees"
    - from: "capitoltraders_cli/src/main.rs"
      to: "capitoltraders_cli/src/commands/sync_donations.rs"
      via: "Commands enum dispatch"
      pattern: "Commands::SyncDonations"
---

<objective>
Create the sync-donations CLI command that fetches FEC Schedule A contributions for a politician's committees using the concurrent pipeline pattern from enrich_prices.rs.

Purpose: This is the core user-facing feature of Phase 10. It connects the OpenFEC API client (Phase 8), CommitteeResolver (Phase 9), and donation DB operations (Plan 01) into a working pipeline that users invoke from the command line.

Output: Working `capitoltraders sync-donations --db trades.db --politician "Nancy Pelosi"` command with progress reporting, circuit breaker, and resume support.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-donation-sync-pipeline/10-RESEARCH.md
@.planning/phases/10-donation-sync-pipeline/10-01-SUMMARY.md
@.planning/phases/04-price-enrichment-pipeline/04-01-SUMMARY.md
@.planning/phases/09-politician-to-committee-mapping-schema-v3/09-02-SUMMARY.md
@capitoltraders_cli/src/commands/enrich_prices.rs
@capitoltraders_cli/src/main.rs
@capitoltraders_lib/src/committee.rs
@capitoltraders_lib/src/openfec/client.rs
@capitoltraders_lib/src/openfec/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync_donations.rs with concurrent donation sync pipeline</name>
  <files>capitoltraders_cli/src/commands/sync_donations.rs</files>
  <action>
Create a new file `capitoltraders_cli/src/commands/sync_donations.rs` modeled after enrich_prices.rs but adapted for FEC donation syncing. The structure follows the Semaphore + JoinSet + mpsc pattern.

**CLI Args struct:**
```rust
#[derive(Args)]
pub struct SyncDonationsArgs {
    /// SQLite database path (required)
    #[arg(long)]
    pub db: PathBuf,

    /// Politician name to sync donations for (searches by partial match)
    #[arg(long)]
    pub politician: Option<String>,

    /// Election cycle year (e.g. 2024). If omitted, syncs all available cycles.
    #[arg(long)]
    pub cycle: Option<i32>,

    /// Donations per API page (default: 100)
    #[arg(long, default_value = "100")]
    pub batch_size: i32,
}
```

**Main run function flow:**

```rust
pub async fn run(args: &SyncDonationsArgs, api_key: String) -> Result<()> { ... }
```

1. **Setup:** Open DB, create OpenFecClient with api_key, create CommitteeResolver with Arc<Mutex<Db>> and Arc<OpenFecClient>.

2. **Politician resolution:**
   - If --politician provided: call db.find_politician_by_name(&name). If 0 results, bail with "No politician found matching '{name}'". If >1 result, print all matches and bail with "Multiple politicians match '{name}', please be more specific". If exactly 1, use that politician_id.
   - If --politician not provided: get ALL politicians that have fec_mappings entries. Use db.get_politicians_for_fec_matching() and filter to those with fec_mappings.

3. **For each politician (outer loop):**
   a. Resolve committees via CommitteeResolver::resolve_committees(politician_id). If empty, try resolving first, then skip if still empty with warning.
   b. Collect committee IDs from ResolvedCommittee vec.
   c. Check for already-completed syncs (load_sync_cursor returns None + donation_sync_meta exists with last_index IS NULL = completed). Skip those committees if completed within 24 hours (check last_synced_at).

4. **Concurrent committee fetch (inner pipeline):**
   - Constants: CONCURRENCY = 3 (lower than enrich_prices' 5 due to OpenFEC rate limits), CIRCUIT_BREAKER_THRESHOLD = 5.
   - Create progress bar via indicatif (total = number of committees to sync).
   - For each committee_id, spawn a task in JoinSet:
     * Acquire semaphore permit
     * Add jittered delay (200-500ms per existing pattern)
     * Run keyset pagination loop for that committee:
       - Load cursor from DB if resuming (NOTE: cursor loading must happen BEFORE spawning, since DB access needs to be synchronous. Pass loaded cursor into the spawned task.)
       - Actually, since Db is behind Arc<Mutex<>>, the spawned task can lock it. But the research says "Drop Mutex lock before any async operations." So load cursor before the loop, and inside the loop: fetch API page, then send results to channel.
     * REVISED APPROACH: The pagination loop runs inside the spawned task, but DB writes happen in the receiver. So the spawned task:
       1. Receives initial cursor (loaded before spawn)
       2. Loops: build ScheduleAQuery with cursor -> call client.get_schedule_a() -> send (committee_id, contributions, pagination) to channel -> update local cursor from response
       3. On empty results or no last_indexes: send a "completed" message to channel
       4. On 429 error: send error to channel (receiver handles circuit breaker)
       5. On 403 error: send fatal error to channel (receiver bails immediately)
   - Channel message type:
     ```rust
     enum DonationMessage {
         Page {
             politician_id: String,
             committee_id: String,
             contributions: Vec<Contribution>,
             cycle: Option<i32>,
             last_index: i64,
             last_date: String,
         },
         Completed {
             politician_id: String,
             committee_id: String,
         },
         Error {
             committee_id: String,
             error: OpenFecError,
         },
     }
     ```

5. **Receiver loop (single-threaded DB writes):**
   - DonationMessage::Page: call db.save_sync_cursor_with_donations(). Increment total_synced counter. Update progress bar message.
   - DonationMessage::Completed: call db.mark_sync_completed(). Increment progress bar.
   - DonationMessage::Error:
     * If OpenFecError::InvalidApiKey: print fatal message, abort_all, bail.
     * If OpenFecError::RateLimited: circuit_breaker.record_failure(). If tripped, print message, abort_all, break.
     * Other errors: warn and continue.
   - On success messages: circuit_breaker.record_success().

6. **Summary:**
   - Print total donations synced, committees processed, elapsed time.
   - If circuit breaker tripped, exit with non-zero (bail!).
   - Otherwise exit 0 (even with partial failures per requirements).

**Important implementation details:**
- Use `Arc<OpenFecClient>` for sharing across tasks (OpenFecClient contains reqwest::Client which is Arc-backed).
- Use `Arc<Mutex<Db>>` for CommitteeResolver. For the receiver loop's DB writes, use a SEPARATE Db instance (open the same path again) to avoid mutex contention with CommitteeResolver. This follows the pattern where CommitteeResolver owns one Db handle and the receiver owns another.
- Actually simpler: the receiver loop runs after all committee resolution is done. So drop the CommitteeResolver and its Arc<Mutex<Db>> before starting the pipeline. Then the receiver can use a plain &Db reference.
- REVISED: Open Db once. Use it for politician lookup and committee resolution (CommitteeResolver wraps Arc<Mutex<Db>>). After committee resolution completes, drop the CommitteeResolver (which drops the Arc<Mutex<Db>>). Then use the original Db handle (which was moved into Arc<Mutex<Db>>). Actually this won't work because Arc<Mutex<Db>> takes ownership.
- FINAL APPROACH: Open Db twice. First for setup (politician lookup, committee resolution via CommitteeResolver). Second for the pipeline receiver's DB writes. This is clean and avoids all mutex concerns in the hot path. SQLite handles concurrent readers fine with WAL mode, and the receiver is the only writer.
- Load cursors BEFORE spawning tasks. Pass loaded cursor into each spawned task as a parameter.
- The progress bar should show: `[elapsed] committee_name: N donations synced (total: M)`.

**CircuitBreaker:** Reuse the exact same struct from enrich_prices.rs (copy it -- it's only 20 lines and specific to this module). Threshold = 5 per requirements.

**Rate limiting:** Use the same 200-500ms jittered delay between API calls within each spawned task (rand::thread_rng().gen_range(200..500)).
  </action>
  <verify>
cargo check -p capitoltraders_cli
cargo clippy -p capitoltraders_cli
  </verify>
  <done>sync_donations.rs compiles without errors. Contains SyncDonationsArgs struct, run() async function, DonationMessage enum, CircuitBreaker, and full pipeline implementation. No clippy warnings.</done>
</task>

<task type="auto">
  <name>Task 2: Wire sync-donations into CLI and verify end-to-end compilation</name>
  <files>
    capitoltraders_cli/src/commands/mod.rs
    capitoltraders_cli/src/main.rs
  </files>
  <action>
**1. Register module in mod.rs:**
Add `pub mod sync_donations;` to `capitoltraders_cli/src/commands/mod.rs` (after the existing `pub mod sync_fec;` line to maintain alphabetical-ish order).

**2. Add variant to Commands enum in main.rs:**
Add a new variant to the Commands enum:
```rust
/// Sync FEC donation data for politicians
SyncDonations(commands::sync_donations::SyncDonationsArgs),
```

**3. Add dispatch in match block in main.rs:**
After the `Commands::SyncFec(args)` arm, add:
```rust
Commands::SyncDonations(args) => {
    let api_key = require_openfec_api_key()?;
    commands::sync_donations::run(args, api_key).await?
}
```

This follows the exact pattern established by sync_fec: require the API key at dispatch time, not at startup.

**4. Update module docstring in main.rs:**
Update the top-level docstring to mention the new command:
```rust
//! Provides seven subcommands (`trades`, `politicians`, `issuers`, `sync`, `sync-fec`, `enrich-prices`, `portfolio`, `sync-donations`) with
```
Wait, that's 8 commands. Just add `sync-donations` to the existing list.

**5. Verify the full workspace compiles and all tests pass:**
```bash
cargo check --workspace
cargo clippy --workspace
cargo test --workspace
```
  </action>
  <verify>
cargo check --workspace
cargo clippy --workspace
cargo test --workspace
cargo run -p capitoltraders_cli -- sync-donations --help
  </verify>
  <done>
- `cargo check --workspace` succeeds
- `cargo clippy --workspace` has zero warnings
- `cargo test --workspace` passes all tests (464+ from Plan 01 + any new)
- `cargo run -p capitoltraders_cli -- sync-donations --help` displays usage with --db, --politician, --cycle, --batch-size flags
- SyncDonations variant appears in Commands enum
- require_openfec_api_key() called only when SyncDonations is dispatched
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass
2. `cargo clippy --workspace` -- zero warnings
3. `cargo run -p capitoltraders_cli -- sync-donations --help` -- shows help with all flags
4. `cargo run -p capitoltraders_cli -- sync-donations --db /tmp/nonexistent.db` without OPENFEC_API_KEY -- produces actionable error about missing API key
5. Code review: sync_donations.rs uses CircuitBreaker with threshold 5
6. Code review: save_sync_cursor_with_donations called in receiver (not in spawned tasks)
7. Code review: 403 causes immediate bail, not circuit breaker increment
8. Code review: Cursors loaded before task spawn, passed as parameter
9. Code review: drop(tx) called before receiver loop
</verification>

<success_criteria>
- `capitoltraders sync-donations --help` works and shows --db, --politician, --cycle, --batch-size
- Pipeline compiles and structurally mirrors enrich_prices.rs (Semaphore + JoinSet + mpsc)
- Circuit breaker threshold is 5 (not 10 like enrich_prices)
- Concurrency is 3 (not 5 like enrich_prices)
- 403 errors cause immediate failure with API key help message
- 429 errors increment circuit breaker, tripping halts all tasks
- Cursor is loaded before spawn, persisted in receiver via save_sync_cursor_with_donations
- mark_sync_completed called when pagination exhausted
- Progress bar shows donations synced count and elapsed time
- All workspace tests pass, zero clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/10-donation-sync-pipeline/10-02-SUMMARY.md`
</output>
