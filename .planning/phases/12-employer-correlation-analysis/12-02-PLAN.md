---
phase: 12-employer-correlation-analysis
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - schema/sqlite.sql
  - capitoltraders_lib/src/db.rs
  - capitoltraders_lib/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Schema v5 migration adds employer_mappings table to existing databases without data loss"
    - "Fresh databases include employer_mappings table in base DDL"
    - "Employer mappings can be inserted and queried by normalized employer name"
    - "Donor context query returns top employers for a politician and sector combination"
    - "Donation summary returns total amount and top employer sectors for a politician"
    - "Queries gracefully return empty results when no employer mappings or donations exist"
  artifacts:
    - path: "schema/sqlite.sql"
      provides: "employer_mappings table definition with indexes"
      contains: "employer_mappings"
    - path: "capitoltraders_lib/src/db.rs"
      provides: "Schema v5 migration and employer/donor DB operations"
      exports: ["upsert_employer_mappings", "get_unmatched_employers", "get_all_issuers_for_matching", "issuer_exists_by_ticker", "get_donor_context_for_sector", "get_donation_summary", "DonorContext", "DonationSummary", "SectorTotal"]
  key_links:
    - from: "capitoltraders_lib/src/db.rs"
      to: "schema/sqlite.sql"
      via: "include_str! in init()"
      pattern: "include_str!"
    - from: "capitoltraders_lib/src/db.rs migrate_v5"
      to: "employer_mappings table"
      via: "ALTER TABLE / CREATE TABLE migration"
      pattern: "migrate_v5"
---

<objective>
Add schema v5 migration with employer_mappings table and all DB operations for employer correlation and donor context queries.

Purpose: Provides the data storage and query layer that Plan 03 (map-employers CLI) and Plan 04 (trades/portfolio donor context) depend on. This plan does not depend on Plan 01 (employer_mapping module) because the DB operations accept raw data -- the matching logic calls these methods.

Output: Schema v5 with employer_mappings table, migration for existing DBs, and 8+ DB methods with tests.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-employer-correlation-analysis/12-RESEARCH.md
@schema/sqlite.sql
@capitoltraders_lib/src/db.rs (lines 1-100 for init/migration pattern, plus struct definitions)
@capitoltraders_lib/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema v5 migration and employer_mappings table DDL</name>
  <files>
    schema/sqlite.sql
    capitoltraders_lib/src/db.rs
  </files>
  <action>
    1. Add employer_mappings table to `schema/sqlite.sql` (base DDL for fresh databases), after the donation_sync_meta table:

    ```sql
    CREATE TABLE IF NOT EXISTS employer_mappings (
        normalized_employer TEXT PRIMARY KEY,
        issuer_ticker TEXT NOT NULL,
        confidence REAL NOT NULL,
        match_type TEXT NOT NULL,
        created_at TEXT NOT NULL,
        last_updated TEXT NOT NULL,
        notes TEXT
    );
    ```

    Use issuer_ticker (not issuer_id) as the join key. This avoids FK constraint issues since issuer_id values are database-specific and the same employer mapping should work across re-synced databases. Queries JOIN through issuers table to get issuer_id when needed.

    Add indexes after existing indexes:
    ```sql
    CREATE INDEX IF NOT EXISTS idx_employer_mappings_ticker ON employer_mappings(issuer_ticker);
    CREATE INDEX IF NOT EXISTS idx_employer_mappings_confidence ON employer_mappings(confidence);
    CREATE INDEX IF NOT EXISTS idx_employer_mappings_type ON employer_mappings(match_type);
    ```

    2. Add `migrate_v5` method to db.rs following the existing migration pattern (see migrate_v1 through migrate_v4). The migration should:
    - CREATE TABLE IF NOT EXISTS employer_mappings (same DDL as above)
    - CREATE INDEX IF NOT EXISTS for the 3 indexes

    3. Update `init()` in db.rs to call migrate_v5 and bump user_version to 5:
    ```rust
    if version < 5 {
        self.migrate_v5()?;
        self.conn.pragma_update(None, "user_version", 5)?;
    }
    ```

    4. Add schema v5 migration tests following the v3/v4 test pattern:
    - test_migrate_v5_from_v4: Create a v4 DB (using V3_SCHEMA constant + migrate_v4), then run init(). Verify user_version is 5 and employer_mappings table exists.
    - test_fresh_db_has_employer_mappings: Open fresh in-memory DB, run init(), verify employer_mappings table is in schema.
    - test_migrate_v5_idempotent: Run init() twice, no error.
    - test_v5_version_check: After init(), user_version is 5.

    Update existing test constants: Add V4_SCHEMA constant if not present (or update existing test to expect version 5 after fresh init). Follow the pattern from v3/v4 tests.
  </action>
  <verify>
    `cargo test -p capitoltraders_lib migrate_v5` -- all 4 migration tests pass.
    `cargo test -p capitoltraders_lib schema` -- existing schema tests still pass (may need version expectation updates).
    `cargo check --workspace` -- compiles.
  </verify>
  <done>
    Schema v5 migration exists. employer_mappings table created for both fresh and migrated databases. 4 migration tests pass. Existing tests updated to expect version 5.
  </done>
</task>

<task type="auto">
  <name>Task 2: DB operations for employer mappings and donor context queries</name>
  <files>
    capitoltraders_lib/src/db.rs
    capitoltraders_lib/src/lib.rs
  </files>
  <action>
    Add the following types and methods to db.rs:

    **Types (add near other query result structs):**

    ```rust
    #[derive(Debug, Serialize, Clone)]
    pub struct DonorContext {
        pub employer: String,
        pub total_amount: f64,
        pub donation_count: i64,
    }

    #[derive(Debug, Serialize, Clone)]
    pub struct SectorTotal {
        pub sector: String,
        pub total_amount: f64,
        pub employer_count: i64,
    }

    #[derive(Debug, Serialize, Clone)]
    pub struct DonationSummary {
        pub total_amount: f64,
        pub donation_count: i64,
        pub top_sectors: Vec<SectorTotal>,
    }
    ```

    **Methods on Db (add after existing donation methods):**

    1. `pub fn upsert_employer_mappings(&self, mappings: &[(String, String, f64, &str)]) -> Result<usize, DbError>`
       - Each tuple: (normalized_employer, issuer_ticker, confidence, match_type)
       - Use INSERT OR REPLACE INTO employer_mappings with datetime('now') for created_at and last_updated
       - Use unchecked_transaction for batch insert
       - Return count of rows inserted

    2. `pub fn get_unmatched_employers(&self, limit: Option<i64>) -> Result<Vec<String>, DbError>`
       - SELECT DISTINCT LOWER(d.contributor_employer) as employer FROM donations d JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id WHERE d.contributor_employer IS NOT NULL AND d.contributor_employer != '' AND NOT EXISTS (SELECT 1 FROM employer_mappings em WHERE em.normalized_employer = LOWER(d.contributor_employer)) ORDER BY employer
       - Apply LIMIT if provided
       - Note: This returns raw employer names, not normalized. The caller (CLI) normalizes before matching.
       - Actually, for correctness the query should use normalized forms. But SQLite cannot call Rust normalize_employer(). Instead, return distinct raw employers and let the caller handle dedup after normalization. Keep it simple.

    3. `pub fn get_all_issuers_for_matching(&self) -> Result<Vec<(i64, String, String)>, DbError>`
       - SELECT issuer_id, issuer_name, COALESCE(issuer_ticker, '') as issuer_ticker FROM issuers WHERE issuer_name IS NOT NULL AND issuer_name != ''
       - Returns (issuer_id, issuer_name, issuer_ticker) tuples for the matching engine

    4. `pub fn issuer_exists_by_ticker(&self, ticker: &str) -> Result<bool, DbError>`
       - SELECT 1 FROM issuers WHERE issuer_ticker = ?1 LIMIT 1
       - Return true if row exists

    5. `pub fn get_employer_mapping_count(&self) -> Result<i64, DbError>`
       - SELECT COUNT(*) FROM employer_mappings

    6. `pub fn get_donor_context_for_sector(&self, politician_id: &str, sector: &str, limit: i64) -> Result<Vec<DonorContext>, DbError>`
       - Query: Find donations to this politician where the employer maps to an issuer in the given sector.
       ```sql
       SELECT d.contributor_employer as employer,
              SUM(d.contribution_receipt_amount) as total_amount,
              COUNT(*) as donation_count
       FROM donations d
       JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id
       JOIN employer_mappings em ON LOWER(TRIM(d.contributor_employer)) = em.normalized_employer
       JOIN issuers i ON em.issuer_ticker = i.issuer_ticker
       WHERE dsm.politician_id = ?1
         AND i.sector = ?2
         AND d.contributor_employer IS NOT NULL
       GROUP BY d.contributor_employer
       ORDER BY total_amount DESC
       LIMIT ?3
       ```
       - Note: LOWER(TRIM()) in SQL approximates normalization for simple cases. Full normalization (suffix stripping) happens at mapping creation time, so the employer_mappings.normalized_employer already stores the normalized form. The JOIN works because we stored the normalized employer when creating the mapping. This is good enough -- exact match on normalized_employer column.
       - Actually, this JOIN is wrong. The donations table has raw employer names, but employer_mappings has normalized keys. We need to normalize the donation employer before joining. SQLite cannot call Rust functions. Solution: The JOIN should use a simpler approach -- just LOWER(TRIM()) for the SQL side, and accept that some matches will be missed if suffix stripping is needed. Alternatively, add a denormalized lookup: store the raw employer names that map to each normalized key. That is complex.
       - Better approach: Use a subquery pattern. Since employer_mappings are created from the same donation employers (via map-employers export/import or seed loading), the normalized_employer values in the table already correspond to the normalized forms of actual donation employer strings. The export process normalizes employer -> stores in employer_mappings. So the query should normalize the donation employer to match. Since we cannot call Rust normalize in SQL, we can: (a) use LOWER(TRIM()) as a best-effort approximation, or (b) create a separate employer_name_lookup table mapping raw -> normalized.
       - Go with approach (a): LOWER(TRIM()) for the SQL JOIN. This handles case and whitespace. Suffix stripping is handled at mapping creation time -- the normalized_employer in the table matches LOWER(TRIM()) of common variants because we strip suffixes when creating the mapping. For "Goldman Sachs Group" (raw) vs "goldman sachs" (normalized), LOWER(TRIM()) gives "goldman sachs group" which does NOT match "goldman sachs". This is a real problem.
       - Final approach: Add an `employer_name_index` table for reverse lookup, or just accept the limitation and document it. Actually, the simpler solution: when creating employer mappings (upsert_employer_mappings), also store common raw form variants. OR: change the schema to have a many-to-one lookup table.
       - Simplest correct approach: Add a helper table `employer_lookup` with (raw_employer_lower TEXT PRIMARY KEY, normalized_employer TEXT NOT NULL). When the map-employers command processes employers, it inserts both the normalized mapping and the raw-to-normalized lookup. The donor context query JOINs through employer_lookup.

       Actually, let me reconsider. The requirement says "Employer names are normalized and matched against stock issuers." The matching happens at map-employers time, not query time. The map-employers command:
       1. Gets unmatched employers from donations
       2. Normalizes each one
       3. Matches against issuers
       4. User confirms
       5. Stores in employer_mappings: normalized_employer -> issuer_ticker

       The donor context query needs to: given a politician and sector, find donations whose employer has a mapping to an issuer in that sector. The bridge is: donation.contributor_employer -> (normalize) -> employer_mappings.normalized_employer -> issuer_ticker -> issuers.sector.

       Since SQLite cannot do the Rust normalization, add an `employer_lookup` table:
       ```sql
       CREATE TABLE IF NOT EXISTS employer_lookup (
           raw_employer_lower TEXT PRIMARY KEY,
           normalized_employer TEXT NOT NULL
       );
       ```
       When upsert_employer_mappings is called, also populate employer_lookup for each raw employer that was matched. The map-employers export command processes raw employers, normalizes them, and when importing confirmed mappings, stores the raw -> normalized lookup.

       Add a method: `pub fn insert_employer_lookups(&self, lookups: &[(String, String)]) -> Result<(), DbError>` where each tuple is (raw_employer_lower, normalized_employer).

       Then the donor context query becomes:
       ```sql
       SELECT d.contributor_employer, SUM(...), COUNT(*)
       FROM donations d
       JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id
       JOIN employer_lookup el ON LOWER(TRIM(d.contributor_employer)) = el.raw_employer_lower
       JOIN employer_mappings em ON el.normalized_employer = em.normalized_employer
       JOIN issuers i ON em.issuer_ticker = i.issuer_ticker
       WHERE dsm.politician_id = ?1 AND i.sector = ?2 AND d.contributor_employer IS NOT NULL
       GROUP BY d.contributor_employer
       ORDER BY total_amount DESC
       LIMIT ?3
       ```

       Add employer_lookup table to both base DDL and migrate_v5.

    7. `pub fn get_donation_summary(&self, politician_id: &str) -> Result<Option<DonationSummary>, DbError>`
       - First get total donations for politician:
       ```sql
       SELECT SUM(d.contribution_receipt_amount), COUNT(*)
       FROM donations d
       JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id
       WHERE dsm.politician_id = ?1
       ```
       - If no rows or sum is NULL, return None.
       - Then get top sectors:
       ```sql
       SELECT i.sector, SUM(d.contribution_receipt_amount) as total, COUNT(DISTINCT el.normalized_employer) as employer_count
       FROM donations d
       JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id
       JOIN employer_lookup el ON LOWER(TRIM(d.contributor_employer)) = el.raw_employer_lower
       JOIN employer_mappings em ON el.normalized_employer = em.normalized_employer
       JOIN issuers i ON em.issuer_ticker = i.issuer_ticker
       WHERE dsm.politician_id = ?1 AND i.sector IS NOT NULL
       GROUP BY i.sector
       ORDER BY total DESC
       LIMIT 5
       ```
       - Return DonationSummary with total_amount, donation_count (from first query, includes ALL donations), and top_sectors (from second query, only mapped employers).

    8. `pub fn insert_employer_lookups(&self, lookups: &[(String, String)]) -> Result<(), DbError>`
       - INSERT OR REPLACE INTO employer_lookup (raw_employer_lower, normalized_employer) VALUES (?1, ?2)
       - Use unchecked_transaction for batch

    **Add re-exports to lib.rs:** DonorContext, DonationSummary, SectorTotal

    **Unit tests (in db.rs #[cfg(test)] section):**
    - test_upsert_employer_mappings: Insert 3 mappings, verify count is 3
    - test_upsert_employer_mappings_update: Insert mapping, then upsert same normalized_employer with different ticker, verify updated
    - test_get_unmatched_employers: Insert donations for 3 employers, add mapping for 1, verify get_unmatched returns 2
    - test_get_all_issuers_for_matching: Insert 3 issuers, verify all 3 returned with correct fields
    - test_issuer_exists_by_ticker: Insert issuer with ticker "AAPL", verify exists. Verify "ZZZZ" does not exist.
    - test_get_employer_mapping_count: Insert 2 mappings, verify count is 2
    - test_donor_context_empty: No mappings, get_donor_context returns empty vec
    - test_donation_summary_no_donations: No donations, get_donation_summary returns None
    - test_employer_lookup_insert: Insert lookups, verify round-trip

    For tests that need donation data: create helper function that inserts a politician, issuer, fec_mapping, donation_sync_meta entry, and donations. Follow the pattern from existing donation tests in db.rs.
  </action>
  <verify>
    `cargo test -p capitoltraders_lib employer_mapping` -- Task 1 tests still pass.
    `cargo test -p capitoltraders_lib upsert_employer` -- new DB tests pass.
    `cargo test -p capitoltraders_lib donor_context` -- donor context tests pass.
    `cargo test -p capitoltraders_lib donation_summary` -- summary tests pass.
    `cargo test --workspace` -- all existing tests still pass.
    `cargo clippy --workspace` -- no warnings.
  </verify>
  <done>
    Schema v5 includes employer_mappings and employer_lookup tables. 8 DB methods implemented. 9+ DB tests pass. All existing tests pass. Types re-exported from lib.rs.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` -- all tests pass (existing + new)
- `cargo clippy --workspace` -- no warnings
- Schema version is 5 after fresh init
- employer_mappings and employer_lookup tables exist in DDL
- DB methods handle empty/no-data cases gracefully (empty vecs, None)
</verification>

<success_criteria>
- Schema v5 migration adds employer_mappings and employer_lookup tables
- Fresh databases include both tables in base DDL
- 8 DB methods: upsert_employer_mappings, get_unmatched_employers, get_all_issuers_for_matching, issuer_exists_by_ticker, get_employer_mapping_count, get_donor_context_for_sector, get_donation_summary, insert_employer_lookups
- 13+ tests (4 migration + 9 DB operation)
- DonorContext, DonationSummary, SectorTotal types exported
</success_criteria>

<output>
After completion, create `.planning/phases/12-employer-correlation-analysis/12-02-SUMMARY.md`
</output>
