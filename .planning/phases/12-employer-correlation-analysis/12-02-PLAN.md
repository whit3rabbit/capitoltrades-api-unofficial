---
phase: 12-employer-correlation-analysis
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - schema/sqlite.sql
  - capitoltraders_lib/src/db.rs
  - capitoltraders_lib/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Schema v5 migration adds employer_mappings and employer_lookup tables to existing databases without data loss"
    - "Fresh databases include employer_mappings and employer_lookup tables in base DDL"
    - "Employer mappings can be inserted and queried by normalized employer name"
    - "Employer lookup provides raw-to-normalized bridge for SQL JOINs"
    - "Donor context query returns top employers for a politician and sector combination"
    - "Donation summary returns total amount and top employer sectors for a politician"
    - "Queries gracefully return empty results when no employer mappings or donations exist"
  artifacts:
    - path: "schema/sqlite.sql"
      provides: "employer_mappings and employer_lookup table definitions with indexes"
      contains: "employer_mappings"
    - path: "capitoltraders_lib/src/db.rs"
      provides: "Schema v5 migration and employer/donor DB operations"
      exports: ["upsert_employer_mappings", "get_unmatched_employers", "get_all_issuers_for_matching", "issuer_exists_by_ticker", "get_donor_context_for_sector", "get_donation_summary", "insert_employer_lookups", "DonorContext", "DonationSummary", "SectorTotal"]
  key_links:
    - from: "capitoltraders_lib/src/db.rs"
      to: "schema/sqlite.sql"
      via: "include_str! in init()"
      pattern: "include_str!"
    - from: "capitoltraders_lib/src/db.rs migrate_v5"
      to: "employer_mappings table"
      via: "ALTER TABLE / CREATE TABLE migration"
      pattern: "migrate_v5"
    - from: "capitoltraders_lib/src/db.rs migrate_v5"
      to: "employer_lookup table"
      via: "CREATE TABLE migration"
      pattern: "employer_lookup"
---

<objective>
Add schema v5 migration with employer_mappings and employer_lookup tables, plus all DB operations for employer correlation and donor context queries.

Purpose: Provides the data storage and query layer that Plan 03 (map-employers CLI) and Plan 04 (trades/portfolio donor context) depend on. This plan does not depend on Plan 01 (employer_mapping module) because the DB operations accept raw data -- the matching logic calls these methods.

Output: Schema v5 with employer_mappings and employer_lookup tables, migration for existing DBs, and 8+ DB methods with tests.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-employer-correlation-analysis/12-RESEARCH.md
@schema/sqlite.sql
@capitoltraders_lib/src/db.rs (lines 1-100 for init/migration pattern, plus struct definitions)
@capitoltraders_lib/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema v5 migration with employer_mappings and employer_lookup table DDL</name>
  <files>
    schema/sqlite.sql
    capitoltraders_lib/src/db.rs
  </files>
  <action>
    1. Add employer_mappings AND employer_lookup tables to `schema/sqlite.sql` (base DDL for fresh databases), after the donation_sync_meta table:

    ```sql
    CREATE TABLE IF NOT EXISTS employer_mappings (
        normalized_employer TEXT PRIMARY KEY,
        issuer_ticker TEXT NOT NULL,
        confidence REAL NOT NULL,
        match_type TEXT NOT NULL,
        created_at TEXT NOT NULL,
        last_updated TEXT NOT NULL,
        notes TEXT
    );

    CREATE TABLE IF NOT EXISTS employer_lookup (
        raw_employer_lower TEXT PRIMARY KEY,
        normalized_employer TEXT NOT NULL
    );
    ```

    Use issuer_ticker (not issuer_id) as the join key. This avoids FK constraint issues since issuer_id values are database-specific and the same employer mapping should work across re-synced databases. Queries JOIN through issuers table to get issuer_id when needed.

    The employer_lookup table bridges raw donation employer names to normalized forms, enabling SQL JOINs without calling Rust normalization functions. When the map-employers command processes employers, it populates both tables: employer_mappings for the canonical normalized->ticker mapping, and employer_lookup for every raw employer string that was matched.

    Add indexes after existing indexes:
    ```sql
    CREATE INDEX IF NOT EXISTS idx_employer_mappings_ticker ON employer_mappings(issuer_ticker);
    CREATE INDEX IF NOT EXISTS idx_employer_mappings_confidence ON employer_mappings(confidence);
    CREATE INDEX IF NOT EXISTS idx_employer_mappings_type ON employer_mappings(match_type);
    CREATE INDEX IF NOT EXISTS idx_employer_lookup_normalized ON employer_lookup(normalized_employer);
    ```

    2. Add `migrate_v5` method to db.rs following the existing migration pattern (see migrate_v1 through migrate_v4). The migration should:
    - CREATE TABLE IF NOT EXISTS employer_mappings (same DDL as above)
    - CREATE TABLE IF NOT EXISTS employer_lookup (same DDL as above)
    - CREATE INDEX IF NOT EXISTS for all 4 indexes

    3. Update `init()` in db.rs to call migrate_v5 and bump user_version to 5:
    ```rust
    if version < 5 {
        self.migrate_v5()?;
        self.conn.pragma_update(None, "user_version", 5)?;
    }
    ```

    4. Add schema v5 migration tests following the v3/v4 test pattern:
    - test_migrate_v5_from_v4: Create a v4 DB (using V3_SCHEMA constant + migrate_v4), then run init(). Verify user_version is 5, employer_mappings table exists, and employer_lookup table exists.
    - test_fresh_db_has_employer_tables: Open fresh in-memory DB, run init(), verify both employer_mappings and employer_lookup tables are in schema.
    - test_migrate_v5_idempotent: Run init() twice, no error.
    - test_v5_version_check: After init(), user_version is 5.

    Update existing test constants: Add V4_SCHEMA constant if not present (or update existing test to expect version 5 after fresh init). Follow the pattern from v3/v4 tests.
  </action>
  <verify>
    `cargo test -p capitoltraders_lib migrate_v5` -- all 4 migration tests pass.
    `cargo test -p capitoltraders_lib schema` -- existing schema tests still pass (may need version expectation updates).
    `cargo check --workspace` -- compiles.
  </verify>
  <done>
    Schema v5 migration exists. Both employer_mappings and employer_lookup tables created for fresh and migrated databases. 4 migration tests pass. Existing tests updated to expect version 5.
  </done>
</task>

<task type="auto">
  <name>Task 2: DB operations for employer mappings, employer lookup, and donor context queries</name>
  <files>
    capitoltraders_lib/src/db.rs
    capitoltraders_lib/src/lib.rs
  </files>
  <action>
    Note on scope: This task is intentionally dense (8 methods, 3 types, 9 tests) because the methods are individually small (most are single-query wrappers) and closely related. Splitting would create artificial boundaries between methods that share test fixtures and setup helpers. The total context footprint is moderate since most methods are 5-15 lines of SQL + row mapping.

    Add the following types and methods to db.rs:

    **Types (add near other query result structs):**

    ```rust
    #[derive(Debug, Serialize, Clone)]
    pub struct DonorContext {
        pub employer: String,
        pub total_amount: f64,
        pub donation_count: i64,
    }

    #[derive(Debug, Serialize, Clone)]
    pub struct SectorTotal {
        pub sector: String,
        pub total_amount: f64,
        pub employer_count: i64,
    }

    #[derive(Debug, Serialize, Clone)]
    pub struct DonationSummary {
        pub total_amount: f64,
        pub donation_count: i64,
        pub top_sectors: Vec<SectorTotal>,
    }
    ```

    **Methods on Db (add after existing donation methods):**

    1. `pub fn upsert_employer_mappings(&self, mappings: &[(String, String, f64, &str)]) -> Result<usize, DbError>`
       - Each tuple: (normalized_employer, issuer_ticker, confidence, match_type)
       - Use INSERT OR REPLACE INTO employer_mappings with datetime('now') for created_at and last_updated
       - Use unchecked_transaction for batch insert
       - Return count of rows inserted

    2. `pub fn get_unmatched_employers(&self, limit: Option<i64>) -> Result<Vec<String>, DbError>`
       - SELECT DISTINCT LOWER(d.contributor_employer) as employer FROM donations d JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id WHERE d.contributor_employer IS NOT NULL AND d.contributor_employer != '' AND NOT EXISTS (SELECT 1 FROM employer_lookup el WHERE el.raw_employer_lower = LOWER(d.contributor_employer)) ORDER BY employer
       - Apply LIMIT if provided
       - Returns raw employer names (lowercased). The caller (CLI) normalizes before matching.

    3. `pub fn get_all_issuers_for_matching(&self) -> Result<Vec<(i64, String, String)>, DbError>`
       - SELECT issuer_id, issuer_name, COALESCE(issuer_ticker, '') as issuer_ticker FROM issuers WHERE issuer_name IS NOT NULL AND issuer_name != ''
       - Returns (issuer_id, issuer_name, issuer_ticker) tuples for the matching engine

    4. `pub fn issuer_exists_by_ticker(&self, ticker: &str) -> Result<bool, DbError>`
       - SELECT 1 FROM issuers WHERE issuer_ticker = ?1 LIMIT 1
       - Return true if row exists

    5. `pub fn get_employer_mapping_count(&self) -> Result<i64, DbError>`
       - SELECT COUNT(*) FROM employer_mappings

    6. `pub fn insert_employer_lookups(&self, lookups: &[(String, String)]) -> Result<(), DbError>`
       - INSERT OR REPLACE INTO employer_lookup (raw_employer_lower, normalized_employer) VALUES (?1, ?2)
       - Use unchecked_transaction for batch

    7. `pub fn get_donor_context_for_sector(&self, politician_id: &str, sector: &str, limit: i64) -> Result<Vec<DonorContext>, DbError>`
       - Query: Find donations to this politician where the employer maps to an issuer in the given sector.
       ```sql
       SELECT d.contributor_employer as employer,
              SUM(d.contribution_receipt_amount) as total_amount,
              COUNT(*) as donation_count
       FROM donations d
       JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id
       JOIN employer_lookup el ON LOWER(TRIM(d.contributor_employer)) = el.raw_employer_lower
       JOIN employer_mappings em ON el.normalized_employer = em.normalized_employer
       JOIN issuers i ON em.issuer_ticker = i.issuer_ticker
       WHERE dsm.politician_id = ?1
         AND i.sector = ?2
         AND d.contributor_employer IS NOT NULL
       GROUP BY d.contributor_employer
       ORDER BY total_amount DESC
       LIMIT ?3
       ```
       - The employer_lookup table bridges raw donation employer strings to normalized keys, enabling the JOIN chain without Rust-side normalization.

    8. `pub fn get_donation_summary(&self, politician_id: &str) -> Result<Option<DonationSummary>, DbError>`
       - First get total donations for politician:
       ```sql
       SELECT SUM(d.contribution_receipt_amount), COUNT(*)
       FROM donations d
       JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id
       WHERE dsm.politician_id = ?1
       ```
       - If no rows or sum is NULL, return None.
       - Then get top sectors:
       ```sql
       SELECT i.sector, SUM(d.contribution_receipt_amount) as total, COUNT(DISTINCT el.normalized_employer) as employer_count
       FROM donations d
       JOIN donation_sync_meta dsm ON d.committee_id = dsm.committee_id
       JOIN employer_lookup el ON LOWER(TRIM(d.contributor_employer)) = el.raw_employer_lower
       JOIN employer_mappings em ON el.normalized_employer = em.normalized_employer
       JOIN issuers i ON em.issuer_ticker = i.issuer_ticker
       WHERE dsm.politician_id = ?1 AND i.sector IS NOT NULL
       GROUP BY i.sector
       ORDER BY total DESC
       LIMIT 5
       ```
       - Return DonationSummary with total_amount, donation_count (from first query, includes ALL donations), and top_sectors (from second query, only mapped employers).

    **Add re-exports to lib.rs:** DonorContext, DonationSummary, SectorTotal

    **Unit tests (in db.rs #[cfg(test)] section):**
    - test_upsert_employer_mappings: Insert 3 mappings, verify count is 3
    - test_upsert_employer_mappings_update: Insert mapping, then upsert same normalized_employer with different ticker, verify updated
    - test_get_unmatched_employers: Insert donations for 3 employers, add employer_lookup entry for 1, verify get_unmatched returns 2
    - test_get_all_issuers_for_matching: Insert 3 issuers, verify all 3 returned with correct fields
    - test_issuer_exists_by_ticker: Insert issuer with ticker "AAPL", verify exists. Verify "ZZZZ" does not exist.
    - test_get_employer_mapping_count: Insert 2 mappings, verify count is 2
    - test_donor_context_empty: No mappings, get_donor_context returns empty vec
    - test_donation_summary_no_donations: No donations, get_donation_summary returns None
    - test_employer_lookup_insert: Insert lookups, verify round-trip

    For tests that need donation data: create helper function that inserts a politician, issuer, fec_mapping, donation_sync_meta entry, and donations. Follow the pattern from existing donation tests in db.rs.
  </action>
  <verify>
    `cargo test -p capitoltraders_lib employer_mapping` -- Task 1 tests still pass.
    `cargo test -p capitoltraders_lib upsert_employer` -- new DB tests pass.
    `cargo test -p capitoltraders_lib donor_context` -- donor context tests pass.
    `cargo test -p capitoltraders_lib donation_summary` -- summary tests pass.
    `cargo test --workspace` -- all existing tests still pass.
    `cargo clippy --workspace` -- no warnings.
  </verify>
  <done>
    Schema v5 includes employer_mappings and employer_lookup tables. 8 DB methods implemented with employer_lookup bridge for SQL JOINs. 9+ DB tests pass. All existing tests pass. Types re-exported from lib.rs.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` -- all tests pass (existing + new)
- `cargo clippy --workspace` -- no warnings
- Schema version is 5 after fresh init
- employer_mappings and employer_lookup tables exist in DDL
- DB methods handle empty/no-data cases gracefully (empty vecs, None)
- Donor context query JOINs through employer_lookup for raw-to-normalized bridging
</verification>

<success_criteria>
- Schema v5 migration adds employer_mappings and employer_lookup tables
- Fresh databases include both tables in base DDL
- 8 DB methods: upsert_employer_mappings, get_unmatched_employers, get_all_issuers_for_matching, issuer_exists_by_ticker, get_employer_mapping_count, insert_employer_lookups, get_donor_context_for_sector, get_donation_summary
- 13+ tests (4 migration + 9 DB operation)
- DonorContext, DonationSummary, SectorTotal types exported
</success_criteria>

<output>
After completion, create `.planning/phases/12-employer-correlation-analysis/12-02-SUMMARY.md`
</output>
