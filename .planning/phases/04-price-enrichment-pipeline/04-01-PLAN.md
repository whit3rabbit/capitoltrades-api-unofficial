---
phase: 04-price-enrichment-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - capitoltraders_lib/src/db.rs
  - capitoltraders_cli/src/commands/enrich_prices.rs
  - capitoltraders_cli/src/commands/mod.rs
  - capitoltraders_cli/src/main.rs
autonomous: true

must_haves:
  truths:
    - "enrich-prices command fetches trade_date_price for all unenriched trades"
    - "enrich-prices command fetches current_price deduplicated by ticker"
    - "Re-running enrich-prices skips already-enriched trades (resumable)"
    - "Circuit breaker trips after 10 consecutive failures and logs summary"
    - "Rate limiting with jittered delay (200-500ms) and max 5 concurrent requests"
    - "Enrichment progress displays ticker count and success/fail/skip counts"
  artifacts:
    - path: "capitoltraders_cli/src/commands/enrich_prices.rs"
      provides: "Price enrichment pipeline with historical + current price phases"
      min_lines: 150
    - path: "capitoltraders_lib/src/db.rs"
      provides: "update_current_price DB method"
      contains: "fn update_current_price"
    - path: "capitoltraders_cli/src/main.rs"
      provides: "EnrichPrices subcommand dispatch"
      contains: "EnrichPrices"
  key_links:
    - from: "capitoltraders_cli/src/commands/enrich_prices.rs"
      to: "capitoltraders_lib/src/db.rs"
      via: "db.get_unenriched_price_trades, db.update_trade_prices, db.update_current_price"
      pattern: "db\\.(get_unenriched_price_trades|update_trade_prices|update_current_price)"
    - from: "capitoltraders_cli/src/commands/enrich_prices.rs"
      to: "capitoltraders_lib/src/yahoo.rs"
      via: "yahoo.get_price_on_date_with_fallback, yahoo.get_current_price"
      pattern: "yahoo\\.(get_price_on_date_with_fallback|get_current_price)"
    - from: "capitoltraders_cli/src/commands/enrich_prices.rs"
      to: "capitoltraders_lib/src/pricing.rs"
      via: "parse_trade_range, estimate_shares"
      pattern: "(parse_trade_range|estimate_shares)"
    - from: "capitoltraders_cli/src/main.rs"
      to: "capitoltraders_cli/src/commands/enrich_prices.rs"
      via: "Commands::EnrichPrices dispatch"
      pattern: "Commands::EnrichPrices"
---

<objective>
Build the price enrichment pipeline and CLI subcommand that batch-fetches historical and current prices from Yahoo Finance, estimates share counts, and stores results in SQLite.

Purpose: This is the integration phase that connects all prior primitives (YahooClient, pricing module, DB operations) into a working pipeline. Without this, trades have no price data and portfolio calculations cannot proceed.

Output: Working `capitoltraders enrich-prices --db <path>` command that enriches trades with historical prices, current prices, and estimated shares.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-price-enrichment-pipeline/04-RESEARCH.md
@.planning/phases/02-yahoo-finance-client-integration/02-01-SUMMARY.md
@.planning/phases/03-ticker-validation-trade-value-estimation/03-01-SUMMARY.md
@capitoltraders_lib/src/yahoo.rs
@capitoltraders_lib/src/pricing.rs
@capitoltraders_lib/src/db.rs
@capitoltraders_cli/src/commands/sync.rs
@capitoltraders_cli/src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add update_current_price DB method and create enrich_prices pipeline module</name>
  <files>
    capitoltraders_lib/src/db.rs
    capitoltraders_cli/src/commands/enrich_prices.rs
    capitoltraders_cli/src/commands/mod.rs
  </files>
  <action>
**1. Add `update_current_price()` to `capitoltraders_lib/src/db.rs`:**

Add this method to the `Db` impl block, right after `update_trade_prices()` (around line 1177):

```rust
/// Update the current price for a trade by tx_id.
///
/// Sets current_price and refreshes price_enriched_at timestamp.
/// Called during the second phase of price enrichment (current prices by ticker).
pub fn update_current_price(
    &self,
    tx_id: i64,
    current_price: Option<f64>,
) -> Result<(), DbError> {
    self.conn.execute(
        "UPDATE trades
         SET current_price = ?1,
             price_enriched_at = datetime('now')
         WHERE tx_id = ?2",
        params![current_price, tx_id],
    )?;
    Ok(())
}
```

Also add a test in the `#[cfg(test)] mod tests` block for `update_current_price`:
- Insert a trade, call `update_current_price(tx_id, Some(155.50))`, verify the value is stored.
- Test with None: `update_current_price(tx_id, None)`, verify current_price is NULL but price_enriched_at is set.

**2. Create `capitoltraders_cli/src/commands/enrich_prices.rs`:**

This is the core pipeline module. Follow the proven Semaphore + JoinSet + mpsc pattern from `sync.rs` (lines 224-333).

Key design decisions:
- YahooClient does NOT implement Clone. Wrap in `Arc<YahooClient>` for sharing across tasks. The methods take `&self` so this works with Arc.
- Two-phase enrichment: (1) historical prices by (ticker, date), (2) current prices by ticker.
- `rand` dependency is in `capitoltraders_lib` -- add `rand = "0.8.5"` to `capitoltraders_cli/Cargo.toml`.

**Args struct:**
```rust
#[derive(Args)]
pub struct EnrichPricesArgs {
    /// SQLite database path (required)
    #[arg(long)]
    pub db: PathBuf,

    /// Maximum trades to process per run (default: all)
    #[arg(long)]
    pub batch_size: Option<i64>,

    /// Re-enrich already-enriched trades
    #[arg(long)]
    pub force: bool,
}
```

Note: --force is defined in the args but the actual re-enrichment behavior is deferred. For now, without --force the pipeline queries WHERE price_enriched_at IS NULL (default from `get_unenriched_price_trades`). With --force, a future version could clear price_enriched_at first. For now, document in the help text that --force is reserved for future use.

**Pipeline function `pub async fn run(args: &EnrichPricesArgs) -> Result<()>`:**

Step 1 - Setup:
- Open DB: `let db = Db::open(&args.db)?;`
- Create YahooClient: `let yahoo = Arc::new(YahooClient::new().map_err(|e| anyhow!("Failed to create Yahoo client: {}", e))?);`
- Fetch unenriched trades: `let trades = db.get_unenriched_price_trades(args.batch_size)?;`
- If empty, print "No trades need price enrichment" and return Ok.

Step 2 - Deduplicate by (ticker, date):
- Build `HashMap<(String, NaiveDate), Vec<usize>>` (call it `ticker_date_map`) where keys are unique (ticker, date) pairs and values are indices into the `trades` vec. Multiple trades may share the same ticker+date, so they map to the same key.
- Parse tx_date with `NaiveDate::parse_from_str(&trade.tx_date, "%Y-%m-%d")`. On parse error, log warning with tx_id and skip that trade (increment a `skipped` counter).
- This map is the input for Step 3: each entry becomes one Yahoo Finance API call, and the indices tell the receiver which trades to update with the result.

Step 3 - Historical price enrichment (Phase 1):
- Constants: `const CONCURRENCY: usize = 5;` and `const CIRCUIT_BREAKER_THRESHOLD: usize = 10;`
- Create ProgressBar for `ticker_date_map.len()` (unique ticker-date pairs count).
- Use Semaphore + JoinSet + mpsc pattern from sync.rs.
- **Spawn tasks by iterating over the HashMap:** `for ((ticker, date), indices) in ticker_date_map { ... }`. Each spawned task receives the ticker (String), date (NaiveDate), and indices (Vec<usize>). Inside the task: acquire permit, sleep for jittered delay `rand::thread_rng().gen_range(200..500)` ms, call `yahoo.get_price_on_date_with_fallback(&ticker, date).await`, send result on channel.
- Channel message type: a struct with ticker (String), date (NaiveDate), trade_indices (Vec<usize>), and result (Result<Option<f64>, YahooError>).
- Receiver loop processes messages single-threaded. The `trades` vec is a local variable accessible to the receiver. For each message:
  - On Ok(Some(price)) -- for each idx in trade_indices: get `trade = &trades[idx]`, call `parse_trade_range(trade.amount_lower, trade.amount_upper)` to get the dollar range, then `estimate_shares(&range, price)` to get estimated share count, then `db.update_trade_prices(trade.tx_id, Some(price), estimated_shares)`. Record success.
  - On Ok(None) -- mark as enriched with None values (invalid ticker or no data for that date). For each idx in trade_indices: `db.update_trade_prices(trade.tx_id, None, None)`. Record skip.
  - On Err -- log warning with ticker and error, increment failed counter, record circuit breaker failure. Check breaker, abort_all if tripped.

Step 4 - Current price enrichment (Phase 2):
- Build `HashMap<String, Vec<usize>>` from the same trades vec, grouping by ticker only.
- Create new ProgressBar, Semaphore, JoinSet, mpsc channel.
- Same concurrency pattern. Each task fetches `yahoo.get_current_price(&ticker).await`.
- Channel message: ticker (String), trade_indices (Vec<usize>), result.
- Receiver loop: On Ok(Some(price)) -- for each idx in trade_indices: get `trade = &trades[idx]`, call `db.update_current_price(trade.tx_id, Some(price))`. On Ok(None) or Err -- skip (current price is best-effort per research recommendation).

Step 5 - Summary:
- Print summary: "Price enrichment complete: {enriched} enriched, {failed} failed, {skipped} skipped (of {total} trades, {unique_pairs} unique ticker-date pairs, {unique_tickers} unique tickers)"
- If circuit breaker tripped, print warning: "Circuit breaker tripped after {threshold} consecutive failures -- some trades were not processed"

**Critical implementation notes:**
- Use `Arc<YahooClient>` (not clone). YahooConnector does not implement Clone.
- The `trades` vec must be accessible from the receiver loop to look up PriceEnrichmentRow fields by index. Keep it as a local variable; the spawned tasks only send indices, not the full rows. The receiver uses `trades[idx]` to access `amount_lower`, `amount_upper`, and `tx_id` for each trade.
- The `db` reference is only used in the receiver loop (single-threaded DB writes). Never call db methods from spawned tasks.
- Import `use rand::Rng;` for `gen_range`.

**3. Register the module in `capitoltraders_cli/src/commands/mod.rs`:**

Add `pub mod enrich_prices;` to the existing module list.
  </action>
  <verify>
    - `cargo check --workspace` compiles without errors
    - `cargo test -p capitoltraders_lib db::tests::test_update_current_price` passes (or similar test name)
    - `cargo clippy --workspace` has no new warnings
  </verify>
  <done>
    - update_current_price DB method exists and is tested
    - enrich_prices.rs module exists with EnrichPricesArgs struct and run() async function
    - Pipeline implements two-phase enrichment (historical then current) with Semaphore + JoinSet + mpsc pattern
    - Rate limiting (200-500ms jitter), concurrency cap (5), and circuit breaker (threshold 10) are implemented
    - Module registered in commands/mod.rs
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire enrich-prices CLI subcommand and verify end-to-end compilation</name>
  <files>
    capitoltraders_cli/src/main.rs
    capitoltraders_cli/Cargo.toml
  </files>
  <action>
**1. Add `rand` dependency to `capitoltraders_cli/Cargo.toml`:**

Add `rand = "0.8.5"` to the `[dependencies]` section (needed for jitter in enrich_prices.rs).

**2. Add EnrichPrices variant to Commands enum in main.rs:**

```rust
#[derive(Subcommand)]
enum Commands {
    /// List recent trades
    Trades(Box<commands::trades::TradesArgs>),
    /// List politicians
    Politicians(commands::politicians::PoliticiansArgs),
    /// List or lookup issuers
    Issuers(commands::issuers::IssuersArgs),
    /// Sync data into a SQLite database
    Sync(commands::sync::SyncArgs),
    /// Enrich trades with Yahoo Finance price data
    EnrichPrices(commands::enrich_prices::EnrichPricesArgs),
}
```

**3. Add dispatch in main() match block:**

```rust
Commands::EnrichPrices(args) => commands::enrich_prices::run(&args).await?,
```

This goes after the `Commands::Sync` arm. Note: enrich-prices does NOT need the scraper or format -- it's a DB-only operation.

**4. Verify full workspace builds and tests pass:**

Run `cargo test --workspace` to ensure everything compiles and existing tests still pass. Run `cargo clippy --workspace` for lint check.

**5. Verify CLI help output:**

Run `cargo run -p capitoltraders_cli -- enrich-prices --help` to confirm the subcommand appears and shows --db, --batch-size, --force flags.
  </action>
  <verify>
    - `cargo build -p capitoltraders_cli` succeeds
    - `cargo run -p capitoltraders_cli -- enrich-prices --help` shows usage with --db, --batch-size, --force
    - `cargo run -p capitoltraders_cli -- --help` lists enrich-prices in subcommands
    - `cargo test --workspace` all tests pass
    - `cargo clippy --workspace` no warnings
  </verify>
  <done>
    - EnrichPrices variant added to Commands enum in main.rs
    - Dispatch routes to enrich_prices::run() in main match block
    - rand dependency added to CLI crate
    - `capitoltraders enrich-prices --db <path>` command exists and shows help
    - All existing tests continue to pass
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Compilation:** `cargo check --workspace` succeeds
2. **Tests:** `cargo test --workspace` -- all existing tests pass plus new update_current_price tests
3. **Clippy:** `cargo clippy --workspace` -- no new warnings
4. **CLI exists:** `cargo run -p capitoltraders_cli -- enrich-prices --help` shows correct usage
5. **Dry run:** `cargo run -p capitoltraders_cli -- enrich-prices --db /tmp/test.db` -- should print "No trades need price enrichment" on empty/non-existent DB (after init)

Phase 4 success criteria mapping:
- SC1 (historical prices): Implemented in Phase 1 of pipeline (ticker-date deduplication + YahooClient)
- SC2 (current prices deduplicated): Implemented in Phase 2 of pipeline (ticker-only deduplication)
- SC3 (200 tickers < 2min): Concurrency (5) + jitter (200-500ms) handles this (200 * 400ms avg / 5 = ~16s)
- SC4 (resumable): get_unenriched_price_trades filters WHERE price_enriched_at IS NULL
- SC5 (circuit breaker): CircuitBreaker with threshold 10, abort_all on trip
- SC6 (rate limiting): 200-500ms jittered delay per request, Semaphore(5) concurrency cap
- SC7 (progress display): indicatif ProgressBar with success/fail/skip counts in message
</verification>

<success_criteria>
- `capitoltraders enrich-prices --db <path>` command compiles and runs
- Pipeline fetches historical prices with (ticker, date) deduplication
- Pipeline fetches current prices with ticker-only deduplication
- Rate limiting: 200-500ms jittered delay, max 5 concurrent Yahoo Finance requests
- Circuit breaker trips after 10 consecutive failures and aborts remaining tasks
- Progress bar shows enrichment progress with success/fail/skip counts
- DB writes happen single-threaded via mpsc channel (no SQLite contention)
- Resumability: already-enriched trades are skipped on re-run
- All workspace tests pass with no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/04-price-enrichment-pipeline/04-01-SUMMARY.md`
</output>
