---
phase: 14-benchmark-price-enrichment
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - capitoltraders_cli/src/commands/enrich_prices.rs
autonomous: true

must_haves:
  truths:
    - "Running enrich-prices fetches benchmark prices in a third phase after historical and current price enrichment"
    - "Benchmark prices are deduplicated by (ETF ticker, date) so each unique pair is fetched only once"
    - "Trades with GICS sector get sector-specific ETF benchmark; trades without get SPY fallback"
    - "Circuit breaker stops Phase 3 after 10 consecutive benchmark price failures"
    - "Weekend/holiday dates fall back to previous trading day for benchmark prices"
    - "Phase 3 runs independently -- works even if user already ran Phases 1 and 2 previously"
  artifacts:
    - path: "capitoltraders_cli/src/commands/enrich_prices.rs"
      provides: "Phase 3 benchmark enrichment loop, get_benchmark_ticker mapping, BenchmarkPriceResult struct"
      contains: "get_benchmark_ticker"
  key_links:
    - from: "enrich_prices.rs::run()"
      to: "db.get_benchmark_unenriched_trades()"
      via: "separate query for benchmark-unenriched trades"
      pattern: "get_benchmark_unenriched_trades"
    - from: "enrich_prices.rs::get_benchmark_ticker()"
      to: "GICS sector names"
      via: "const match on sector string"
      pattern: "match gics_sector"
    - from: "enrich_prices.rs Phase 3 loop"
      to: "yahoo.get_price_on_date_with_fallback()"
      via: "same YahooClient used in Phase 1"
      pattern: "get_price_on_date_with_fallback"
    - from: "enrich_prices.rs Phase 3 receiver"
      to: "db.update_benchmark_price()"
      via: "single-threaded DB writes from channel"
      pattern: "update_benchmark_price"
---

<objective>
Add Phase 3 (benchmark price enrichment) to the enrich-prices pipeline.

Purpose: Extends the existing two-phase enrichment pipeline with a third phase that fetches benchmark prices (SPY or sector ETF) for each trade. This enables Phase 15 to calculate alpha (trade return minus benchmark return). The implementation reuses the existing Semaphore + JoinSet + mpsc concurrency pattern, YahooClient with weekend fallback, and CircuitBreaker logic.

Output: Extended enrich_prices.rs with Phase 3 benchmark enrichment after Phase 2.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-benchmark-price-enrichment/14-RESEARCH.md
@.planning/phases/14-benchmark-price-enrichment/14-01-SUMMARY.md

@capitoltraders_cli/src/commands/enrich_prices.rs
@capitoltraders_lib/src/db.rs (focus: BenchmarkEnrichmentRow, get_benchmark_unenriched_trades, update_benchmark_price)
@capitoltraders_lib/src/sector_mapping.rs (focus: GICS_SECTORS constant for sector name validation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Phase 3 benchmark price enrichment in enrich_prices.rs</name>
  <files>capitoltraders_cli/src/commands/enrich_prices.rs</files>
  <action>
**Update module doc comment** at top of file to mention three-phase enrichment:
```
//! Implements three-phase enrichment:
//! - Phase 1: Historical prices deduplicated by (ticker, date)
//! - Phase 2: Current prices deduplicated by ticker
//! - Phase 3: Benchmark prices (sector ETF or SPY) deduplicated by (ETF ticker, date)
```

**Add BenchmarkPriceResult struct** after CurrentPriceResult:
```rust
/// Message sent from fetch tasks to receiver for benchmark price enrichment.
struct BenchmarkPriceResult {
    trade_indices: Vec<i64>,  // tx_ids of trades to update
    result: Result<Option<f64>, capitoltraders_lib::yahoo::YahooError>,
}
```
Note: Use tx_ids (i64) not indices (usize) since Phase 3 uses its own trades vec from a separate query.

**Add get_benchmark_ticker function** (private, at module level, NOT inside run):
```rust
/// Map GICS sector name to benchmark ETF ticker.
///
/// Returns sector-specific ETF if issuer has GICS sector mapping,
/// otherwise SPY (S&P 500 market benchmark).
fn get_benchmark_ticker(gics_sector: Option<&str>) -> &'static str {
    match gics_sector {
        Some("Communication Services") => "XLC",
        Some("Consumer Discretionary") => "XLY",
        Some("Consumer Staples") => "XLP",
        Some("Energy") => "XLE",
        Some("Financials") => "XLF",
        Some("Health Care") => "XLV",
        Some("Industrials") => "XLI",
        Some("Information Technology") => "XLK",
        Some("Materials") => "XLB",
        Some("Real Estate") => "XLRE",
        Some("Utilities") => "XLU",
        _ => "SPY",
    }
}
```
Use exact GICS sector names from GICS_SECTORS constant (these are the values stored in the issuers.gics_sector column by update_issuer_sectors).

**Add Phase 3 to run() function** -- insert AFTER the Phase 2 block (after pb2.finish_with_message) and BEFORE the Step 5 summary:

Step 5.5: Phase 3 -- Benchmark price enrichment.

1. Query benchmark-unenriched trades with a SEPARATE query:
```rust
let benchmark_trades = db.get_benchmark_unenriched_trades(args.batch_size)?;
```
This is independent of the Phase 1/2 `trades` vec. If user already ran Phases 1/2, `trades` would be empty but `benchmark_trades` will still have rows.

2. If benchmark_trades is empty, print "No trades need benchmark enrichment" and skip Phase 3.

3. Build dedup map: `HashMap<(String, NaiveDate), Vec<i64>>` where key is (benchmark_ticker, date) and value is list of tx_ids.
```rust
let mut benchmark_date_map: HashMap<(String, NaiveDate), Vec<i64>> = HashMap::new();
for trade in &benchmark_trades {
    let date = match NaiveDate::parse_from_str(&trade.tx_date, "%Y-%m-%d") {
        Ok(d) => d,
        Err(_) => continue,
    };
    let benchmark_ticker = get_benchmark_ticker(trade.gics_sector.as_deref());
    benchmark_date_map
        .entry((benchmark_ticker.to_string(), date))
        .or_default()
        .push(trade.tx_id);
}
```

4. Print: `"Phase 3: Fetching benchmark prices for {unique_pairs} unique (ETF, date) pairs across {benchmark_trades.len()} trades"`

5. Set up ProgressBar with same style as Phase 1/2.

6. Spawn concurrent fetch tasks using SAME pattern as Phase 1:
   - `Arc::clone(&semaphore)` (reuse existing semaphore, or create `semaphore3`)
   - Jittered delay 200-500ms (same as Phase 1)
   - Call `yahoo_clone.get_price_on_date_with_fallback(&ticker, date).await`
   - Send BenchmarkPriceResult with tx_ids and result

7. Receive results in single-threaded loop:
   - On Ok(Some(price)): call `db.update_benchmark_price(tx_id, Some(price))` for each tx_id, increment benchmark_enriched counter, record_success on circuit breaker
   - On Ok(None) or Err: call `db.update_benchmark_price(tx_id, None)` for each tx_id (marks as processed to avoid re-fetch), increment benchmark_skipped, record_failure on circuit breaker
   - Check circuit breaker after each result; if tripped, print warning and abort_all

8. Finish progress bar with "Phase 3 done: {enriched} enriched, {skipped} skipped".

**Update Step 5 summary** to include Phase 3 stats:
```rust
eprintln!(
    "Price enrichment complete: {} enriched, {} failed, {} skipped (historical)",
    enriched, failed, skipped + skipped_parse_errors
);
eprintln!(
    "  Phase 2: {} current prices enriched, {} skipped",
    current_enriched, current_skipped
);
eprintln!(
    "  Phase 3: {} benchmark prices enriched, {} skipped",
    benchmark_enriched, benchmark_skipped
);
```

**Update circuit breaker final check** to consider Phase 3 breaker too. If either Phase 1 or Phase 3 breaker tripped, report it.

**Important implementation notes:**
- Do NOT modify the Phase 1/2 code at all. Phase 3 is purely additive.
- The `yahoo` Arc<YahooClient> from Phase 1 is reused. DashMap cache means repeated (ETF, date) lookups are free.
- Create a new Semaphore for Phase 3 (semaphore3) rather than reusing semaphore from Phase 1 -- Phase 1 permits may not be fully released if circuit breaker tripped.
- Use CONCURRENCY (5) and CIRCUIT_BREAKER_THRESHOLD (10) constants already defined.
  </action>
  <verify>
Run `cargo check -p capitoltraders_cli` -- must compile without errors.
Run `cargo clippy -p capitoltraders_cli` -- must pass with no warnings.
Run `cargo clippy --workspace` -- must pass with no warnings (full workspace check).
Run `cargo test --workspace` -- all tests pass (no regressions).
  </verify>
  <done>
enrich_prices.rs has Phase 3 benchmark enrichment after Phase 2. get_benchmark_ticker maps 11 GICS sectors to ETF tickers with SPY fallback. BenchmarkPriceResult struct handles concurrent fetch results. Deduplication by (ETF ticker, date) prevents redundant API calls. Circuit breaker with threshold 10 protects against cascading failures. Phase 3 uses independent query (get_benchmark_unenriched_trades) so it works even when Phases 1/2 have no work. All existing tests pass. Clippy clean.
  </done>
</task>

</tasks>

<verification>
- `cargo test --workspace` passes with no regressions
- `cargo clippy --workspace` passes with no warnings
- `grep -q "Phase 3" capitoltraders_cli/src/commands/enrich_prices.rs` succeeds
- `grep -q "get_benchmark_ticker" capitoltraders_cli/src/commands/enrich_prices.rs` succeeds
- `grep -q "BenchmarkPriceResult" capitoltraders_cli/src/commands/enrich_prices.rs` succeeds
- `grep -q "get_benchmark_unenriched_trades" capitoltraders_cli/src/commands/enrich_prices.rs` succeeds
- `grep -q "update_benchmark_price" capitoltraders_cli/src/commands/enrich_prices.rs` succeeds
- The 11 GICS sector names in get_benchmark_ticker match GICS_SECTORS constant exactly
</verification>

<success_criteria>
User can run `capitoltraders enrich-prices --db path/to/db.sqlite` and see Phase 3 benchmark price enrichment after Phases 1 and 2. Benchmark prices are fetched from Yahoo Finance for SPY or sector-specific ETFs based on issuer GICS sector. Deduplication ensures each unique (ETF, date) pair is fetched once. Circuit breaker stops Phase 3 after 10 consecutive failures. Weekend/holiday fallback via existing YahooClient works for ETF tickers. Phase 3 is independent of Phases 1/2 (runs its own query).
</success_criteria>

<output>
After completion, create `.planning/phases/14-benchmark-price-enrichment/14-02-SUMMARY.md`
</output>
