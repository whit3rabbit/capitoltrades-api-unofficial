---
phase: 09-politician-to-committee-mapping-schema-v3
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - capitoltraders_lib/src/db.rs
  - schema/sqlite.sql
autonomous: true

must_haves:
  truths:
    - "Schema v4 migration adds donations, donation_sync_meta, and fec_committees tables to existing v3 databases"
    - "ALTER TABLE fec_mappings adds committee_ids TEXT column without breaking existing rows"
    - "Fresh databases include all v4 schema in base DDL"
    - "Committee IDs can be stored and retrieved as JSON on fec_mappings"
    - "Committee metadata can be upserted and queried from fec_committees table"
  artifacts:
    - path: "capitoltraders_lib/src/db.rs"
      provides: "migrate_v4(), committee DB operations, JSON column read/write"
      contains: "fn migrate_v4"
    - path: "schema/sqlite.sql"
      provides: "Base DDL with all v1-v4 tables"
      contains: "fec_committees"
  key_links:
    - from: "capitoltraders_lib/src/db.rs"
      to: "schema/sqlite.sql"
      via: "include_str! for fresh DB creation"
      pattern: "include_str.*sqlite\\.sql"
    - from: "capitoltraders_lib/src/db.rs migrate_v4"
      to: "fec_mappings table"
      via: "ALTER TABLE ADD COLUMN committee_ids"
      pattern: "ALTER TABLE fec_mappings ADD COLUMN committee_ids"
---

<objective>
Schema v4 migration and committee-related DB operations for Phase 9.

Purpose: Extend the database to support donation storage (donations, donation_sync_meta tables), committee metadata (fec_committees table), and committee ID caching on fec_mappings. This is the foundational data layer that Plan 02's CommitteeResolver will build on.

Output: Updated db.rs with migrate_v4(), updated sqlite.sql base schema, committee upsert/query DB methods, JSON column read/write for committee_ids, and comprehensive migration tests.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-politician-to-committee-mapping-schema-v3/09-RESEARCH.md
@capitoltraders_lib/src/db.rs
@schema/sqlite.sql
@capitoltraders_lib/src/openfec/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema v4 migration and base DDL update</name>
  <files>capitoltraders_lib/src/db.rs, schema/sqlite.sql</files>
  <action>
Add schema v4 migration to db.rs following the established migrate_v1/v2/v3 pattern.

**In db.rs -- add migrate_v4() method:**

Create `fn migrate_v4(&self) -> Result<(), DbError>` that:

1. Creates fec_committees table:
   ```sql
   CREATE TABLE IF NOT EXISTS fec_committees (
       committee_id TEXT PRIMARY KEY,
       name TEXT NOT NULL,
       committee_type TEXT,
       designation TEXT,
       party TEXT,
       state TEXT,
       cycles TEXT,
       last_synced TEXT NOT NULL
   )
   ```

2. Creates donations table:
   ```sql
   CREATE TABLE IF NOT EXISTS donations (
       sub_id TEXT PRIMARY KEY,
       committee_id TEXT NOT NULL,
       contributor_name TEXT,
       contributor_employer TEXT,
       contributor_occupation TEXT,
       contributor_state TEXT,
       contributor_city TEXT,
       contributor_zip TEXT,
       contribution_receipt_amount REAL,
       contribution_receipt_date TEXT,
       election_cycle INTEGER,
       memo_text TEXT,
       receipt_type TEXT
   )
   ```
   Note: No FOREIGN KEY to fec_committees here -- donations may be inserted before committee metadata is stored. The committee_id column is a logical reference only.

3. Creates donation_sync_meta table:
   ```sql
   CREATE TABLE IF NOT EXISTS donation_sync_meta (
       politician_id TEXT NOT NULL,
       committee_id TEXT NOT NULL,
       last_index INTEGER,
       last_contribution_receipt_date TEXT,
       last_synced_at TEXT NOT NULL,
       total_synced INTEGER NOT NULL DEFAULT 0,
       PRIMARY KEY (politician_id, committee_id)
   )
   ```
   Note: No FOREIGN KEY constraint -- sync_meta references politician_id which exists but the CASCADE behavior on the parent FK is unnecessary overhead for a metadata tracking table.

4. ALTER TABLE fec_mappings ADD COLUMN committee_ids TEXT. Handle "duplicate column name" error gracefully (same pattern as migrate_v1/v2):
   ```rust
   match self.conn.execute("ALTER TABLE fec_mappings ADD COLUMN committee_ids TEXT", []) {
       Ok(_) => {}
       Err(rusqlite::Error::SqliteFailure(_, Some(ref msg)))
           if msg.contains("duplicate column name") => {}
       Err(e) => return Err(e.into()),
   }
   ```

5. Create indexes:
   - idx_donations_committee ON donations(committee_id)
   - idx_donations_date ON donations(contribution_receipt_date)
   - idx_donations_cycle ON donations(election_cycle)
   - idx_donation_sync_meta_politician ON donation_sync_meta(politician_id)
   - idx_fec_committees_designation ON fec_committees(designation)

All using CREATE INDEX IF NOT EXISTS.

**In db.rs init() method:**

Add the version < 4 block after the existing version < 3 block:
```rust
if version < 4 {
    self.migrate_v4()?;
    self.conn.pragma_update(None, "user_version", 4)?;
}
```

**In schema/sqlite.sql -- add to base DDL:**

Add the three new tables (fec_committees, donations, donation_sync_meta) and the committee_ids column on fec_mappings. The fec_mappings CREATE TABLE should be updated to include committee_ids TEXT in its column list. Add the five new indexes at the bottom.

This ensures fresh databases get all v4 schema without running migrations.
  </action>
  <verify>
Run `cargo test --workspace` -- all 406 existing tests pass.
Run `cargo check --workspace` and `cargo clippy --workspace` -- no errors or warnings.
Create a quick in-memory DB test: open_in_memory() -> init() succeeds, verify user_version is 4 via PRAGMA query.
  </verify>
  <done>
migrate_v4() exists and is called from init(). Base sqlite.sql includes all v4 tables. Existing tests pass without regression. In-memory DB initializes to version 4.
  </done>
</task>

<task type="auto">
  <name>Task 2: Committee DB operations and JSON column methods</name>
  <files>capitoltraders_lib/src/db.rs</files>
  <action>
Add DB methods for committee storage, retrieval, and committee_ids JSON column management.

**Committee upsert (for storing committee metadata from OpenFEC API):**

```rust
pub fn upsert_committee(
    &self,
    committee_id: &str,
    name: &str,
    committee_type: Option<&str>,
    designation: Option<&str>,
    party: Option<&str>,
    state: Option<&str>,
    cycles: &[i32],
) -> Result<(), DbError>
```
Uses INSERT ... ON CONFLICT(committee_id) DO UPDATE SET for all fields. Store cycles as JSON TEXT via serde_json::to_string. Set last_synced = datetime('now').

**Batch committee upsert (convenience for Phase 10 consumption):**

```rust
pub fn upsert_committees_from_api(
    &mut self,
    committees: &[crate::openfec::types::Committee],
) -> Result<usize, DbError>
```
Wraps in a transaction, calls upsert_committee for each. Returns count inserted/updated.

**Get committees for politician (reads JSON column):**

```rust
pub fn get_committees_for_politician(
    &self,
    politician_id: &str,
) -> Result<Option<Vec<String>>, DbError>
```
Queries fec_mappings for committee_ids column. If multiple rows exist for this politician_id (multiple FEC candidate IDs), merge all committee_ids into one deduplicated Vec. Handle NULL and empty string: return None if no committee_ids stored.

Parse JSON with serde_json::from_str. Guard against empty string before parsing (empty string causes serde_json parse error).

**Update politician committee_ids (writes JSON column):**

```rust
pub fn update_politician_committees(
    &self,
    politician_id: &str,
    committee_ids: &[String],
) -> Result<(), DbError>
```
Serializes committee_ids to JSON via serde_json::to_string. Updates ALL fec_mappings rows for this politician_id (may have multiple FEC candidate IDs). Uses:
```sql
UPDATE fec_mappings SET committee_ids = ?1 WHERE politician_id = ?2
```

**Get politician name and state (for API fallback search):**

```rust
pub fn get_politician_info(
    &self,
    politician_id: &str,
) -> Result<Option<(String, String, String)>, DbError>
```
Returns (first_name, last_name, state_id) from politicians table. Returns None if politician not found.

**Tests (all in #[cfg(test)] mod tests):**

1. `test_migrate_v4_fresh_db` -- open_in_memory(), init(), verify user_version == 4, verify all three new tables exist via sqlite_master query
2. `test_migrate_v4_idempotent` -- init() twice on same connection, no error
3. `test_migrate_v4_from_v3` -- manually set user_version to 3, create fec_mappings table without committee_ids, call init(), verify committee_ids column exists
4. `test_upsert_committee` -- insert a committee, query it back, verify all fields
5. `test_upsert_committee_update` -- insert then update same committee_id, verify fields changed
6. `test_upsert_committees_from_api` -- create Vec of openfec::types::Committee, upsert, verify count
7. `test_update_and_get_politician_committees` -- insert a politician and fec_mapping row, update committee_ids, get them back, verify deserialization
8. `test_get_committees_null_returns_none` -- fec_mapping with no committee_ids returns None
9. `test_get_politician_info` -- insert politician, query info, verify (first, last, state)
10. `test_get_politician_info_not_found` -- query non-existent politician, verify None

For test setup: use open_in_memory() + init(). For tests that need politician data, insert via the existing upsert_politicians method or direct SQL insert with minimal required columns.
  </action>
  <verify>
Run `cargo test --workspace` -- all tests pass including 10+ new tests.
Run `cargo clippy --workspace` -- no warnings.
Verify each new method is exercised by at least one test.
  </verify>
  <done>
All committee DB operations exist and are tested. JSON column round-trips correctly (write Vec<String> as JSON, read back as Vec<String>). Migration v4 tests pass for fresh, idempotent, and upgrade-from-v3 scenarios. get_politician_info returns correct data for API fallback. Total test count increases by at least 10.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with zero failures (406 existing + ~10 new)
2. `cargo clippy --workspace` reports zero warnings
3. In-memory database initializes to schema version 4
4. Base sqlite.sql contains fec_committees, donations, donation_sync_meta, committee_ids column
5. migrate_v4 handles existing databases (upgrade from v3) and fresh databases
6. JSON column on fec_mappings round-trips correctly
</verification>

<success_criteria>
Schema v4 migration is complete, tested, and non-regressing. All committee-related DB operations (upsert, query, JSON column read/write) work correctly with comprehensive test coverage. Plan 02 can build the CommitteeResolver on top of these DB primitives.
</success_criteria>

<output>
After completion, create `.planning/phases/09-politician-to-committee-mapping-schema-v3/09-01-SUMMARY.md`
</output>
