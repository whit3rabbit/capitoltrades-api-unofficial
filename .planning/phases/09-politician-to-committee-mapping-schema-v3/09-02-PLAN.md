---
phase: 09-politician-to-committee-mapping-schema-v3
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - capitoltraders_lib/src/committee.rs
  - capitoltraders_lib/src/lib.rs
  - capitoltraders_lib/tests/committee_resolver_integration.rs
autonomous: true

must_haves:
  truths:
    - "Given a CapitolTrades politician_id, the system resolves all authorized FEC committee IDs"
    - "Committee resolution checks in-memory cache first, then SQLite, then OpenFEC API"
    - "Committees are classified as Campaign, LeadershipPac, JointFundraising, or Other"
    - "Politicians not found in FEC are handled gracefully (log warning, return empty)"
    - "API fallback uses congress-legislators crosswalk first, name search second"
  artifacts:
    - path: "capitoltraders_lib/src/committee.rs"
      provides: "CommitteeResolver struct, CommitteeClass enum, three-tier cache logic"
      exports: ["CommitteeResolver", "CommitteeClass"]
    - path: "capitoltraders_lib/tests/committee_resolver_integration.rs"
      provides: "Wiremock integration tests for CommitteeResolver API fallback"
      contains: "MockServer"
  key_links:
    - from: "capitoltraders_lib/src/committee.rs CommitteeResolver"
      to: "capitoltraders_lib/src/db.rs"
      via: "get_committees_for_politician, update_politician_committees, upsert_committees_from_api"
      pattern: "db\\.(get_committees|update_politician|upsert_committee)"
    - from: "capitoltraders_lib/src/committee.rs CommitteeResolver"
      to: "capitoltraders_lib/src/openfec/client.rs"
      via: "get_candidate_committees for API fallback"
      pattern: "client\\.get_candidate_committees"
    - from: "capitoltraders_lib/src/committee.rs CommitteeClass"
      to: "fec_committees table"
      via: "classify from designation + committee_type fields"
      pattern: "CommitteeClass::classify"
---

<objective>
CommitteeResolver with three-tier cache and committee type classification.

Purpose: Implement the core committee resolution pipeline that maps CapitolTrades politicians to their authorized FEC committees. This is the critical bridge between politician identity (Phase 7) and donation syncing (Phase 10). The three-tier cache (DashMap -> SQLite -> API) minimizes API calls while ensuring data availability.

Output: committee.rs module with CommitteeResolver struct, CommitteeClass enum, and comprehensive tests including wiremock integration tests for the API fallback path.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-politician-to-committee-mapping-schema-v3/09-RESEARCH.md
@.planning/phases/09-politician-to-committee-mapping-schema-v3/09-01-SUMMARY.md
@capitoltraders_lib/src/db.rs
@capitoltraders_lib/src/openfec/client.rs
@capitoltraders_lib/src/openfec/types.rs
@capitoltraders_lib/src/yahoo.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CommitteeClass enum and CommitteeResolver struct</name>
  <files>capitoltraders_lib/src/committee.rs, capitoltraders_lib/src/lib.rs</files>
  <action>
Create capitoltraders_lib/src/committee.rs with the CommitteeClass enum and CommitteeResolver struct.

**CommitteeClass enum:**

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum CommitteeClass {
    Campaign,
    LeadershipPac,
    JointFundraising,
    Party,
    Pac,
    Other,
}
```

Implement `CommitteeClass::classify(committee_type: Option<&str>, designation: Option<&str>) -> Self`:
- designation "D" -> LeadershipPac (CHECK DESIGNATION FIRST -- leadership PACs can have H/S/P committee_type)
- designation "J" -> JointFundraising
- committee_type H/S/P with designation A/P -> Campaign
- committee_type X/Y/Z -> Party
- committee_type N/Q/O -> Pac
- Everything else -> Other

Implement Display for CommitteeClass returning lowercase variants: "campaign", "leadership_pac", "joint_fundraising", "party", "pac", "other".

**CommitteeResolver struct:**

```rust
use dashmap::DashMap;
use std::sync::Arc;
use crate::db::Db;
use crate::openfec::OpenFecClient;
use crate::openfec::types::Committee;

pub struct CommitteeResolver {
    client: Arc<OpenFecClient>,
    db: Arc<std::sync::Mutex<Db>>,
    cache: DashMap<String, Vec<ResolvedCommittee>>,
}
```

Note: Db is not Send+Sync (rusqlite::Connection). Wrap in Mutex for shared access. The Mutex is acceptable here because DB operations are fast (local SQLite) and contention is minimal (committee resolution is sequential per politician).

**ResolvedCommittee struct:**

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResolvedCommittee {
    pub committee_id: String,
    pub name: String,
    pub classification: CommitteeClass,
}
```

**CommitteeResolver methods:**

`pub fn new(client: Arc<OpenFecClient>, db: Arc<Mutex<Db>>) -> Self`
Initialize with empty DashMap cache.

`pub async fn resolve_committees(&self, politician_id: &str) -> Result<Vec<ResolvedCommittee>, anyhow::Error>`

Three-tier resolution:

1. **Tier 1 -- Memory cache:** Check DashMap for politician_id. If found, return clone.

2. **Tier 2 -- SQLite:** Lock Db mutex, call get_committees_for_politician(politician_id). If Some(committee_ids) and not empty:
   - For each committee_id, query fec_committees table for metadata to build ResolvedCommittee.
   - If committee metadata is in fec_committees, classify it. If not (metadata missing), classify as Other with committee_id as name.
   - Insert into DashMap cache.
   - Return results.

3. **Tier 3 -- OpenFEC API:** Lock Db, call get_fec_ids_for_politician(politician_id).
   - If FEC IDs exist: for each fec_candidate_id, call client.get_candidate_committees(). Collect all committees.
   - If FEC IDs empty: call get_politician_info(politician_id) for (first, last, state). If found, build CandidateSearchQuery with name="{first} {last}" and state, call client.search_candidates(). Take first result's candidate_id. Call get_candidate_committees() on it.
   - If still no committees found: log with tracing::warn!, insert empty Vec into cache, return empty Vec.
   - For each Committee from API: classify, build ResolvedCommittee.
   - Lock Db, call upsert_committees_from_api() with the API committees.
   - Collect committee_ids, call update_politician_committees() to store in fec_mappings.
   - Insert into DashMap cache.
   - Return results.

`pub fn cache_len(&self) -> usize` -- Return DashMap.len() for testing.

`pub fn clear_cache(&self)` -- Clear DashMap for testing or cache invalidation.

**Module registration:**

In lib.rs, add `pub mod committee;` and re-export:
```rust
pub use committee::{CommitteeClass, CommitteeResolver, ResolvedCommittee};
```

**Unit tests in committee.rs:**

1. `test_classify_campaign_house` -- (Some("H"), Some("A")) -> Campaign
2. `test_classify_campaign_senate` -- (Some("S"), Some("P")) -> Campaign
3. `test_classify_campaign_presidential` -- (Some("P"), Some("A")) -> Campaign
4. `test_classify_leadership_pac` -- (Some("H"), Some("D")) -> LeadershipPac (designation D overrides H type)
5. `test_classify_leadership_pac_no_type` -- (None, Some("D")) -> LeadershipPac
6. `test_classify_joint_fundraising` -- (Some("N"), Some("J")) -> JointFundraising
7. `test_classify_party` -- (Some("X"), None) -> Party
8. `test_classify_pac` -- (Some("Q"), Some("B")) -> Pac
9. `test_classify_other_unknown` -- (Some("Z"), Some("X")) -> This maps to Party since Z is party type. Use (Some("W"), None) -> Other.
10. `test_classify_none_none` -- (None, None) -> Other
  </action>
  <verify>
Run `cargo check --workspace` -- compiles without errors.
Run `cargo test --workspace committee` -- all CommitteeClass classification tests pass.
Run `cargo clippy --workspace` -- no warnings.
Verify CommitteeResolver, CommitteeClass, ResolvedCommittee are exported from lib.rs.
  </verify>
  <done>
CommitteeClass enum classifies FEC committees correctly with designation-first priority. CommitteeResolver struct exists with three-tier resolve_committees() method. All types are exported from lib.rs. 10 classification unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: CommitteeResolver integration tests with wiremock</name>
  <files>capitoltraders_lib/tests/committee_resolver_integration.rs</files>
  <action>
Create integration tests that verify the full CommitteeResolver resolution pipeline, including API fallback via wiremock.

**Test setup helper:**

Create a helper function that:
- Opens in-memory Db, calls init()
- Inserts a test politician via direct SQL: politician_id "P000197", first_name "Nancy", last_name "Pelosi", state_id "CA", party "Democrat", dob "1940-03-26", gender "F", chamber "house"
- Inserts a fec_mapping row: politician_id "P000197", fec_candidate_id "H8CA05024", bioguide_id "P000197", last_synced = datetime('now')
- Wraps Db in Arc<Mutex<Db>>
- Creates OpenFecClient via with_base_url() using wiremock MockServer URI (include /v1 in base_url per Phase 8 pattern)
- Wraps client in Arc<OpenFecClient>
- Creates CommitteeResolver

**Tests:**

1. `test_resolve_from_api_stores_in_db` -- Mount wiremock mock for GET /v1/candidate/H8CA05024/committees/ returning a CommitteeResponse with 2 committees (one campaign designation "A" type "H", one leadership PAC designation "D" type "N"). Call resolve_committees("P000197"). Verify returns 2 ResolvedCommittee entries. Verify one is Campaign and one is LeadershipPac. Verify cache_len() == 1. Lock Db and verify committee_ids is stored on fec_mappings. Verify fec_committees table has 2 rows.

2. `test_resolve_from_cache_no_api_call` -- Pre-populate: resolve once (API call), then resolve again. Second call should NOT hit wiremock (verify via mock.expect(1) or just check that it works without mounting new mocks). Verify same results returned.

3. `test_resolve_from_sqlite_tier` -- Pre-populate: resolve once (populates DB), clear_cache(), resolve again. Should read from SQLite tier 2, not API tier 3. Mount wiremock mock with expect(1) for first call only. Verify second resolve returns same committees without API call.

4. `test_resolve_no_fec_ids_searches_by_name` -- Create politician without fec_mapping row. Mount wiremock mock for GET /v1/candidates/search/ returning a CandidateSearchResponse with candidate_id "H8CA05024". Mount wiremock mock for GET /v1/candidate/H8CA05024/committees/ returning committees. Call resolve_committees. Verify name search was used as fallback. Verify committees returned.

5. `test_resolve_not_found_returns_empty` -- Create politician without fec_mapping. Mount wiremock mock for candidates/search returning empty results. Call resolve_committees. Verify returns empty Vec. Verify cache contains empty entry (prevents repeated API calls).

6. `test_resolve_api_error_propagates` -- Mount wiremock mock returning 429 for committees endpoint. Call resolve_committees, verify error is propagated (not swallowed).

**Fixture data:**

Use inline JSON (serde_json::json!) for test responses rather than fixture files, since these are resolver-specific test data, not reusable fixtures.

**Important wiremock patterns (from Phase 8 lessons):**
- Base URL must include /v1: `format!("{}/v1", mock_server.uri())`
- Mount more specific mocks first (if using multiple mocks on same path)
- Use wiremock::matchers::path() and method() for matching
  </action>
  <verify>
Run `cargo test --workspace committee_resolver` -- all 6 integration tests pass.
Run `cargo test --workspace` -- all tests pass (406 existing + ~10 from Plan 01 + 10 classification + 6 integration = ~432).
Run `cargo clippy --workspace` -- no warnings.
  </verify>
  <done>
CommitteeResolver three-tier cache is verified end-to-end: API -> DB storage, cache hit, SQLite tier 2 hit, name search fallback, not-found handling, and error propagation. All integration tests pass with wiremock. Zero regressions on existing tests.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes with zero failures (~432 total tests)
2. `cargo clippy --workspace` reports zero warnings
3. CommitteeClass correctly classifies all FEC committee types with designation-first priority
4. CommitteeResolver resolves from memory cache on repeat calls (verified by wiremock expect counts)
5. CommitteeResolver falls back to SQLite when cache is cold but DB has data
6. CommitteeResolver falls back to OpenFEC API when neither cache nor DB has data
7. CommitteeResolver handles name search fallback when no fec_mapping exists
8. Politicians not in FEC produce empty results, not errors
9. Committee metadata is stored in fec_committees table after API fetch
10. Committee IDs are stored as JSON on fec_mappings after API fetch
</verification>

<success_criteria>
CommitteeResolver is a fully functional three-tier cached resolution pipeline. Given any politician_id, it returns classified committee information using the cheapest available tier. The pipeline is tested with wiremock for all API interaction paths. Phase 10's sync-donations command can consume CommitteeResolver directly to resolve committees before fetching donation data.
</success_criteria>

<output>
After completion, create `.planning/phases/09-politician-to-committee-mapping-schema-v3/09-02-SUMMARY.md`
</output>
