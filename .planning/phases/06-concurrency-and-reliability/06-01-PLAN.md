---
phase: 06-concurrency-and-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - capitoltraders_lib/src/scrape.rs
  - capitoltraders_cli/Cargo.toml
  - capitoltraders_cli/src/commands/sync.rs
autonomous: true

must_haves:
  truths:
    - "Trade enrichment runs with bounded concurrency (N parallel HTTP fetches via Semaphore) instead of sequentially"
    - "Issuer enrichment runs with bounded concurrency using the same pattern"
    - "A progress bar shows current position, total count, and ETA during trade and issuer enrichment"
    - "After N consecutive HTTP failures (post-retry), enrichment stops gracefully instead of continuing"
    - "User can control concurrency level via --concurrency flag (default 3, range 1-10)"
    - "User can control circuit breaker threshold via --max-failures flag (default 5)"
  artifacts:
    - path: "capitoltraders_lib/src/scrape.rs"
      provides: "Cloneable ScrapeClient for spawned tasks"
      contains: "derive.*Clone"
    - path: "capitoltraders_cli/Cargo.toml"
      provides: "indicatif dependency"
      contains: "indicatif"
    - path: "capitoltraders_cli/src/commands/sync.rs"
      provides: "CircuitBreaker struct, concurrent enrich_trades, concurrent enrich_issuers, --concurrency and --max-failures CLI args"
      contains: "CircuitBreaker"
  key_links:
    - from: "capitoltraders_cli/src/commands/sync.rs"
      to: "ScrapeClient"
      via: "scraper.clone() in spawned tasks"
      pattern: "scraper\\.clone\\(\\)"
    - from: "capitoltraders_cli/src/commands/sync.rs"
      to: "tokio::sync::Semaphore"
      via: "bounded concurrency in enrich_trades and enrich_issuers"
      pattern: "Semaphore::new"
    - from: "capitoltraders_cli/src/commands/sync.rs"
      to: "indicatif::ProgressBar"
      via: "progress reporting in enrichment loops"
      pattern: "ProgressBar::new"
    - from: "capitoltraders_cli/src/commands/sync.rs"
      to: "CircuitBreaker"
      via: "failure tracking in receive loop"
      pattern: "breaker\\.is_tripped"
---

<objective>
Rewrite the sequential trade and issuer enrichment functions to use bounded concurrency with progress bars and a circuit breaker.

Purpose: The current sequential enrichment processes items one at a time with a 500ms delay between requests. For large datasets (thousands of trades/issuers), this takes hours. Bounded concurrency (3-5 parallel HTTP fetches) reduces wall-clock time by ~3-5x while respecting server limits. Progress bars replace noisy eprintln logging with real-time ETA. A circuit breaker stops wasting requests when the server is clearly down.

Output: Concurrent enrichment pipeline in sync.rs with indicatif progress bars and circuit breaker halt-on-failure.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-concurrency-and-reliability/06-RESEARCH.md
@capitoltraders_lib/src/scrape.rs
@capitoltraders_cli/Cargo.toml
@capitoltraders_cli/src/commands/sync.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Clone to ScrapeClient, indicatif dependency, CLI args, and CircuitBreaker struct</name>
  <files>
    capitoltraders_lib/src/scrape.rs
    capitoltraders_cli/Cargo.toml
    capitoltraders_cli/src/commands/sync.rs
  </files>
  <action>
1. In `capitoltraders_lib/src/scrape.rs`, add `#[derive(Clone)]` to `ScrapeClient`. The struct has two fields: `base_url: String` and `http: reqwest::Client`. Both are Clone (reqwest::Client is Arc-backed internally, cloning is cheap). No other changes to scrape.rs.

2. In `capitoltraders_cli/Cargo.toml`, add `indicatif = "0.18"` to `[dependencies]`.

3. In `capitoltraders_cli/src/commands/sync.rs`, add the following:

   a. Add `--concurrency` arg to SyncArgs:
      ```rust
      /// Number of concurrent detail page fetches (1-10)
      #[arg(long, default_value = "3")]
      pub concurrency: usize,
      ```

   b. Add `--max-failures` arg to SyncArgs:
      ```rust
      /// Stop enrichment after N consecutive HTTP failures
      #[arg(long, default_value = "5")]
      pub max_failures: usize,
      ```

   c. Add `CircuitBreaker` struct (above the enrichment functions, below EnrichmentResult):
      ```rust
      /// Circuit breaker that trips after N consecutive failures.
      /// Not a full circuit breaker with half-open state -- just a kill switch.
      struct CircuitBreaker {
          consecutive_failures: usize,
          threshold: usize,
      }

      impl CircuitBreaker {
          fn new(threshold: usize) -> Self {
              Self { consecutive_failures: 0, threshold }
          }
          fn record_success(&mut self) {
              self.consecutive_failures = 0;
          }
          fn record_failure(&mut self) {
              self.consecutive_failures += 1;
          }
          fn is_tripped(&self) -> bool {
              self.consecutive_failures >= self.threshold
          }
      }
      ```

   d. Add validation at the top of `run()` for new args:
      ```rust
      if args.concurrency < 1 || args.concurrency > 10 {
          return Err(anyhow!("--concurrency must be between 1 and 10"));
      }
      if args.max_failures < 1 {
          return Err(anyhow!("--max-failures must be at least 1"));
      }
      ```

   e. Add a FetchResult generic struct for channel communication:
      ```rust
      struct FetchResult<T> {
          id: i64,
          result: Result<T, capitoltraders_lib::ScrapeError>,
      }
      ```

   f. Update the `enrich_trades` and `enrich_issuers` calls in `run()` to pass `args.concurrency` and `args.max_failures` as additional parameters.

   g. Add necessary imports at the top of sync.rs:
      ```rust
      use std::sync::Arc;
      use indicatif::{ProgressBar, ProgressStyle};
      use tokio::sync::{mpsc, Semaphore};
      use tokio::task::JoinSet;
      use capitoltraders_lib::ScrapeError;
      ```
  </action>
  <verify>
    Run `cargo check --workspace` to confirm everything compiles. The new CLI args should be visible in `cargo run -p capitoltraders_cli -- sync --help`.
  </verify>
  <done>
    ScrapeClient derives Clone. indicatif is a dependency. SyncArgs has --concurrency and --max-failures. CircuitBreaker struct exists. FetchResult struct exists. All imports in place. Workspace compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite enrich_trades and enrich_issuers to concurrent pattern</name>
  <files>
    capitoltraders_cli/src/commands/sync.rs
  </files>
  <action>
Rewrite both `enrich_trades` and `enrich_issuers` using the Semaphore+JoinSet+mpsc+ProgressBar+CircuitBreaker pattern from the research. The two functions are structurally identical so apply the same pattern to both.

**Updated enrich_trades signature:**
```rust
async fn enrich_trades(
    scraper: &ScrapeClient,
    db: &Db,
    batch_size: Option<i64>,
    detail_delay_ms: u64,
    dry_run: bool,
    concurrency: usize,
    max_failures: usize,
) -> Result<EnrichmentResult>
```

**Implementation for enrich_trades:**

1. Keep the existing dry-run and empty-queue early returns unchanged.

2. Replace the sequential for-loop with:
   a. Create `ProgressBar::new(total as u64)` with style template: `"[{elapsed_precise}] {bar:40.cyan/blue} {pos:>7}/{len:7} ({eta}) {msg}"`
   b. Set initial message: `pb.set_message("enriching trades...")`
   c. Create `Arc::new(Semaphore::new(concurrency))`
   d. Create `mpsc::channel::<FetchResult<ScrapedTradeDetail>>(concurrency * 2)`
   e. Create `JoinSet::new()`
   f. For each `tx_id` in queue, spawn a task that:
      - Clones semaphore, sender, and scraper
      - Acquires semaphore permit
      - Sleeps for throttle delay (if > 0)
      - Calls `scraper.trade_detail(tx_id).await`
      - Sends `FetchResult { id: tx_id, result }` through channel
      - The `_permit` is dropped when the async block completes
   g. Drop the original `tx` sender so `rx.recv()` returns None when all tasks finish
   h. Create `CircuitBreaker::new(max_failures)`
   i. Loop `while let Some(fetch) = rx.recv().await`:
      - On Ok: call `db.update_trade_detail(fetch.id, &detail)?`, increment enriched, call `breaker.record_success()`
      - On Err: use `pb.println()` for warning (NOT eprintln), increment failed, call `breaker.record_failure()`
      - Update progress: `pb.set_message(format!("{} ok, {} err", enriched, failed))` then `pb.inc(1)`
      - Check `breaker.is_tripped()`: if true, `pb.println()` the circuit breaker message, call `join_set.abort_all()`, break
   j. After loop: `pb.finish_with_message(format!("done: {} enriched, {} failed", enriched, failed))`

3. IMPORTANT: After `join_set.abort_all()` and breaking from the rx loop, the remaining messages in the channel will drain naturally since senders get dropped when tasks are aborted. The `drop(tx)` before the loop ensures `rx.recv()` returns None when all senders are gone. No explicit drain needed because we `break` out of the recv loop.

**Updated enrich_issuers** -- same pattern but:
- Uses `ScrapedIssuerDetail` instead of `ScrapedTradeDetail`
- Calls `scraper.issuer_detail(issuer_id).await` instead of `scraper.trade_detail(tx_id)`
- Calls `db.update_issuer_detail(fetch.id, &detail)?`
- Progress message says "enriching issuers..." and "issuer" in warnings

**Updated run() calls:**
Pass `args.concurrency` and `args.max_failures` to both `enrich_trades` and `enrich_issuers`.

**Key detail -- throttle semantics:** The throttle delay is per-task (each spawned task sleeps before its request). With concurrency=3 and delay=500ms, the effective rate is up to ~6 req/s in bursts. This is acceptable per the research recommendation. The existing retry/backoff handles 429s if the server complains.
  </action>
  <verify>
    Run `cargo check --workspace` to confirm compilation. Run `cargo test --workspace` to ensure existing tests still pass (enrichment tests do not exercise the concurrent path since they test DB methods directly). Run `cargo clippy --workspace` for lint cleanliness.
  </verify>
  <done>
    enrich_trades uses Semaphore+JoinSet+mpsc for bounded concurrent HTTP fetches, ProgressBar for progress reporting, CircuitBreaker for failure halt. enrich_issuers uses the same pattern. All existing tests pass. No clippy warnings.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` compiles without errors
2. `cargo test --workspace` passes all existing tests
3. `cargo clippy --workspace` produces no warnings
4. `cargo run -p capitoltraders_cli -- sync --help` shows --concurrency, --max-failures flags
5. ScrapeClient in scrape.rs has #[derive(Clone)]
6. indicatif is listed in capitoltraders_cli/Cargo.toml
7. CircuitBreaker struct exists in sync.rs with new, record_success, record_failure, is_tripped methods
8. enrich_trades and enrich_issuers use Semaphore, JoinSet, mpsc channel, ProgressBar
</verification>

<success_criteria>
- Trade and issuer enrichment functions use bounded concurrency via tokio Semaphore (default 3 permits)
- Progress bars show position/total/ETA during enrichment via indicatif
- Circuit breaker halts enrichment after N consecutive post-retry failures (default 5)
- --concurrency and --max-failures CLI flags are available on sync subcommand
- All existing tests pass, no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/06-concurrency-and-reliability/06-01-SUMMARY.md`
</output>
