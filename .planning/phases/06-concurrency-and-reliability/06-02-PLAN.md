---
phase: 06-concurrency-and-reliability
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - capitoltraders_cli/src/commands/sync.rs
autonomous: true

must_haves:
  truths:
    - "During committee enrichment, a progress spinner shows which committee is being processed and how many memberships have been collected"
    - "CircuitBreaker correctly tracks consecutive failures and resets on success"
    - "CircuitBreaker trips at exactly the threshold (not before, not after)"
    - "All enrichment output uses progress bars or spinners instead of raw eprintln"
  artifacts:
    - path: "capitoltraders_cli/src/commands/sync.rs"
      provides: "Committee enrichment with indicatif spinner, CircuitBreaker unit tests"
      contains: "ProgressBar::new_spinner"
  key_links:
    - from: "capitoltraders_cli/src/commands/sync.rs"
      to: "indicatif::ProgressBar"
      via: "spinner in enrich_politician_committees"
      pattern: "new_spinner"
---

<objective>
Add progress spinner to committee enrichment and unit tests for CircuitBreaker.

Purpose: Committee enrichment (48 sequential requests) currently logs per-committee with eprintln. A spinner with running membership count gives consistent UX across all enrichment types. CircuitBreaker tests ensure the failure-tracking logic is correct since it guards against runaway HTTP failures.

Output: Committee enrichment uses indicatif spinner. CircuitBreaker has comprehensive unit tests.
</objective>

<execution_context>
@/Users/whit3rabbit/.claude/get-shit-done/workflows/execute-plan.md
@/Users/whit3rabbit/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-concurrency-and-reliability/06-RESEARCH.md
@.planning/phases/06-concurrency-and-reliability/06-01-SUMMARY.md
@capitoltraders_cli/src/commands/sync.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add progress spinner to enrich_politician_committees and replace remaining eprintln calls</name>
  <files>
    capitoltraders_cli/src/commands/sync.rs
  </files>
  <action>
1. In `enrich_politician_committees`, replace the per-committee `eprintln!` and final summary `eprintln!` with an indicatif spinner:

   a. At the start of the function, create a spinner:
      ```rust
      let pb = ProgressBar::new_spinner();
      pb.set_style(
          ProgressStyle::with_template("{spinner:.green} [{elapsed_precise}] {msg}")
              .unwrap(),
      );
      pb.enable_steady_tick(Duration::from_millis(120));
      ```

   b. Replace the per-committee `eprintln!("  {}: {} members", name, committee_member_count)` with:
      ```rust
      pb.set_message(format!("{}: {} members ({} total)", name, committee_member_count, memberships.len()));
      ```

   c. Replace the final `eprintln!` summary with:
      ```rust
      pb.finish_with_message(format!(
          "done: {} memberships across {} committees",
          memberships.len(),
          validation::COMMITTEE_MAP.len()
      ));
      ```

2. In the `run()` function, replace the remaining `eprintln!` calls around enrichment with `eprintln!` (these stay as-is since they're one-shot status lines, not progress updates):
   - Keep "Sync complete: N trades ingested" as eprintln (one-shot, before progress bars)
   - Keep "Enrichment: X/Y trades processed (Z failed)" as eprintln (after progress bar finishes)
   - Keep "Issuer enrichment: X/Y issuers processed (Z failed)" as eprintln (after progress bar finishes)
   - Replace "Syncing politician committee memberships..." eprintln with nothing (the spinner's first message handles this)

3. In enrich_trades dry-run path, replace `eprintln!` with standard `eprintln!` (dry-run is not a progress scenario, one-shot output is fine).

4. In enrich_issuers dry-run path, same -- keep `eprintln!`.

Note: The key change is that during active loops (committee iteration), we use indicatif. One-shot status messages before/after enrichment stay as eprintln since they don't conflict with progress bars (the bars are already finished by then).
  </action>
  <verify>
    Run `cargo check --workspace` to confirm compilation. Run `cargo clippy --workspace` for lint check.
  </verify>
  <done>
    enrich_politician_committees uses an indicatif spinner showing current committee and running membership total. No eprintln calls conflict with active progress bars.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for CircuitBreaker</name>
  <files>
    capitoltraders_cli/src/commands/sync.rs
  </files>
  <action>
Add a `#[cfg(test)]` module at the bottom of sync.rs with unit tests for CircuitBreaker:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn circuit_breaker_new_not_tripped() {
        let cb = CircuitBreaker::new(3);
        assert!(!cb.is_tripped());
    }

    #[test]
    fn circuit_breaker_trips_at_threshold() {
        let mut cb = CircuitBreaker::new(3);
        cb.record_failure();
        cb.record_failure();
        assert!(!cb.is_tripped());
        cb.record_failure();
        assert!(cb.is_tripped());
    }

    #[test]
    fn circuit_breaker_success_resets_count() {
        let mut cb = CircuitBreaker::new(3);
        cb.record_failure();
        cb.record_failure();
        cb.record_success();
        cb.record_failure();
        cb.record_failure();
        assert!(!cb.is_tripped());
    }

    #[test]
    fn circuit_breaker_stays_tripped() {
        let mut cb = CircuitBreaker::new(2);
        cb.record_failure();
        cb.record_failure();
        assert!(cb.is_tripped());
        // Recording more failures keeps it tripped
        cb.record_failure();
        assert!(cb.is_tripped());
    }

    #[test]
    fn circuit_breaker_threshold_one() {
        let mut cb = CircuitBreaker::new(1);
        assert!(!cb.is_tripped());
        cb.record_failure();
        assert!(cb.is_tripped());
    }

    #[test]
    fn circuit_breaker_alternating_success_failure() {
        let mut cb = CircuitBreaker::new(3);
        for _ in 0..10 {
            cb.record_failure();
            cb.record_success();
        }
        assert!(!cb.is_tripped());
    }
}
```

These 6 tests cover:
- Initial state (not tripped)
- Trips at exact threshold (not before)
- Success resets consecutive counter
- Stays tripped after tripping
- Edge case: threshold of 1
- Alternating success/failure never trips
  </action>
  <verify>
    Run `cargo test -p capitoltraders_cli circuit_breaker` to verify all 6 tests pass. Run `cargo test --workspace` to confirm no regressions.
  </verify>
  <done>
    6 CircuitBreaker unit tests pass. All existing workspace tests pass. `cargo clippy --workspace` clean.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p capitoltraders_cli circuit_breaker` passes 6 tests
2. `cargo test --workspace` passes all tests (existing + new)
3. `cargo clippy --workspace` produces no warnings
4. enrich_politician_committees uses ProgressBar::new_spinner instead of eprintln for per-committee progress
5. No eprintln calls during active progress bar display
</verification>

<success_criteria>
- Committee enrichment shows a spinner with committee name and running membership total
- CircuitBreaker has 6 unit tests covering all edge cases
- All progress output uses indicatif (progress bars for trade/issuer, spinner for committees)
- Full workspace compiles, tests pass, no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/06-concurrency-and-reliability/06-02-SUMMARY.md`
</output>
